{"./":{"url":"./","title":"工作总结","keywords":"","body":"work-summary To record the key points of problems during working 乐享发布文档 首页 -> k吧 -> 前端开发 -> 文档 -> 新建 -> 文档 -> 选择模板 知识结构 https://www.processon.com/view/link/60960b635653bb147738b082#map 数据结构与算法 https://tomgou.github.io/algorithm-study/ 3D 相关知识总结 https://tomgou.github.io/3d-study-notes/ 3D 动效组件库 https://tomgou.github.io/vue-three-components/ 自动化 selenium https://tomgou.github.io/share_automation/pages/selenium/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-09 11:00:30 "},"pages/gitbook/":{"url":"pages/gitbook/","title":"Gitbook","keywords":"","body":"gitbook使用步骤 Step-1: 创建github仓库 Step-2: 克隆github仓库 git clone git@github.com:TOMGOU/work-summary.git Step-3: 进入项目并初始化 // npm初始化 npm init -y // gitbook初始化 gitbook init Step-4: 创建自动化发布shell脚本git.sh cd _book git init git add . git commit -m 'update' git push -f git@github.com:/.git master:gh-pages cd ../ 用户名：USERNAME = TOMGOU 仓库名：REPO = work-summary Step-5: 修改package.json \"scripts\": { \"gh-pages\": \"./git.sh\" }, Step-6: 本地编辑 gitbook init (新增文件夹的时候，需要初始化) gitbook serve Step-7: github发布 npm run gh-pages Step-8: gitbook plugin【添加文件：book.json，gitbook install】 { \"title\" : \"工作总结\", \"author\" : \"tomgou\", \"description\" : \"工作总结\", \"language\" : \"zh-hans\", \"plugins\": [ \"mathjax-pro\", \"github\", \"hide-element\", \"chapter-fold\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"copy-code-button\", \"back-to-top-button\", \"tbfed-pagefooter\", \"popup\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://tomgou.github.io/work-summary/\" }, \"hide-element\": { \"elements\": [\".gitbook-link\"] }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy tomgou 2022\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } mathjax 官方不再支持 mathjax: npm i mathjax@2.7.6（2.7.7版本有bug） mathjax-pro: npm i gitbook-plugin-mathjax-pro 页面地址：https://tomgou.github.io/work-summary/ 这样使用gitbook的好处 不暴露源码（只要不push主分支） 及时预览：gitbook serve 及时发布：npm run gh-pages Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/gitbook/mermaid/":{"url":"pages/gitbook/mermaid/","title":"Mermaid-gb3","keywords":"","body":"mermaid-gb3 Flow 流程图 graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] graph LR A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Sequence 时序图 sequenceDiagram Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! Gantt 甘特图 gantt title 排期 dateFormat YYYY-MM-DD section Part-A Completed: done, des1, 2022-01-07,2022-01-19 Active: active, des2, 2022-01-07, 3d taskA: des3, after des1, 5d taskB: des4, after des2, 5d taskC: des5, after des3, 5d taskD: des6, after des4, 5d section Part-B Completed: done, des1, 2022-01-07,2022-01-19 taskAA: crit, active, des1, 2022-01-07, 10d taskBB: crit, active, des2, after des1 , 10d taskCC: crit, after des2, 10d section Part-C Completed: done, des1, 2022-01-07,2022-01-19 taskAA: crit, active, des1, 2022-01-07, 10d taskBB: crit, active, des2, after des1 , 10d taskCC: crit, after des2, 10d gantt dateFormat YYYY-MM-DD title 为mermaid加入甘特图功能 section A部分 完成任务 :done, des1,2019-01-06,2019-01-08 正进行任务 :active, des2,2019-01-09,3d 待开始任务 :des3, after des2, 5d 待开始任务2 :des4, after des3, 5d section 紧急任务 完成任务 :crit,done,2019-01-06,24h 实现parser :crit,done,after des1, 2d 为parser编写test :crit, active, 3d 待完成任务 :crit,5d 为rendere编写test: 2d 将功能加入到mermaid: 1d Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/gitbook/markdown/":{"url":"pages/gitbook/markdown/","title":"Markdown","keywords":"","body":"markdown 常用语法 字体、字号、颜色 黑体 表格 项目 价格 Computer $1600 Phone $12 Pipe $1 图片 分割线 标题：Setext方式 大标题 小标题 嵌套列表 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 强调：星号与下划线都可以，单是斜体，双是粗体 一个人来到田纳西 毫无疑问 我做的馅饼是全天下 最好吃的 引用 引用 引用中的引用 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/":{"url":"pages/experience/","title":"KeyPoints","keywords":"","body":"key points 微信小程序与第三方应用跳转问题（web-view） 小程序滚动穿透问题（page-meta） 微信小程序预览 PDF 文件 模板消息订阅 国际化方案 eCharts 基础配置 数据可视化低代码平台 WEPY&TARO混合小程序 miniprogram-ci 微信小程序自动化上传代码 fullScreen 全屏事件切换 静默登录实现（PC 端） Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/webView/":{"url":"pages/experience/webView/","title":"Web-View","keywords":"","body":"微信小程序与第三方应用跳转问题 微信小程序存在衔接第三方应用的场景，例如：由第三方E签宝提供的在线签合同服务，我们需要从小程序跳转到第三方E签宝应用，签完合同后，再跳转回小程序。 web-view 承载网页的容器。会自动铺满整个小程序页面，个人类型的小程序暂不支持使用。 https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html Document wx.miniProgram.navigateTo({url: '/pages/login/application'}) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/pageMeta/":{"url":"pages/experience/pageMeta/","title":"Page-Meta","keywords":"","body":"小程序滚动穿透问题 page-meta 组件 页面属性配置节点，用于指定页面的一些属性、监听页面事件。只能是页面内的第一个节点。 https://developers.weixin.qq.com/miniprogram/dev/component/page-meta.html uni-app 代码示例 isShowStoreShare 是控制弹窗显示隐藏的变量 page-meta 设置 page 样式：overflow: hidden Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/PDFPreview/":{"url":"pages/experience/PDFPreview/","title":"PDF-Preview","keywords":"","body":"微信小程序预览 PDF 文件 方案一： web-view 直接展示 PDF 内容 使用场景：pdf 文件为非机密文件，可以直接从 CDN 读取文件。 方案二：wx.openDocument 利用手机自带的第三方应用打开 PDF 文件 使用场景：pdf 文件为机密文件，文件存储地址不能随意暴露，需要经过后台接口读取文件，然后直接把文件内容返回给前端。 由于是机密文件，接口往往有权限控制，需要设置请求头。 wx.downloadFile({ url: 'https://g.lxstatic.com/dos/ucma/dev/demo.pdf', header: { 'access-token': wx.getStorageSync('access_token') }, success (res) { if (res.statusCode === 200) { wx.openDocument({ filePath: res.tempFilePath, success: function (res) { console.log('打开文档成功') } }) } } }) 这种方式打开的 pdf 文件标题是源文件的名称，非常不美观。 为了解决 title 不美观的问题，需要通过 filePath 对文件重命名 wx.env.USER_DATA_PATH: http://usr【文件系统中的用户目录路径 (本地路径)】 // 查看我的合同 handleContract() { const filePath = `${wx.env.USER_DATA_PATH}/我的合同.pdf` wx.downloadFile({ url: `${appConfig.baseUrl}/my/esign_contract?application_id=${this.applicationId}`, header: { 'access-token': wx.getStorageSync('access_token') }, filePath, success (res) { if (res.statusCode === 200) { wx.openDocument({ filePath, success: function (res) { console.log('打开文档成功') } }) } }, fail (res) { wx.showToast({ icon: 'none', title: '打开文档失败' }) } }) } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/subscribeMessage/":{"url":"pages/experience/subscribeMessage/","title":"模板消息订阅","keywords":"","body":"模板消息订阅 step-1: 微信后台配置订阅消息模板 微信后台 - 功能 - 订阅消息 - 我的模板 step-2: 通过接口动态获取订阅消息模板 id 开发过程测试，可以直接在微信后台复制模板 id const { code, data: subscribeTmpl, message } = await this.$rest.subscribe.getSubscribeTmpl() if (code !== 0) { wx.showModal({ content: message || this.i18N.getTemError, showCancel: false }) return } const { review_result: reviewResult } = subscribeTmpl const tmplIds = [ reviewResult ] step-3: 将模板 id 作为参数调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果。 文档地址：https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html 用户订阅成功的判断条件：errMsg === 'requestSubscribeMessage:ok' && res[reviewResult] === 'accept' wx.requestSubscribeMessage({ tmplIds: tmplIds, success: async (res) => { const { errMsg } = res if (errMsg === 'requestSubscribeMessage:ok' && res[reviewResult] === 'accept') { wx.showModal({ title: this.i18N.tipsTitle, content: '订阅成功', showCancel: false }) } else { wx.showModal({ title: this.i18N.tipsTitle, content: '订阅失败', showCancel: false }) } }, fail: (res) => { console.log('fail', res) }, complete: () => { this.statusCode = 'DATA_UPLOADED' this.currentStatus = 2 this.$apply() } }) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/channelLive/":{"url":"pages/experience/channelLive/","title":"跳转视频号和直播","keywords":"","body":"小程序跳转视频号主页和直播页面 文档地址： API - 开放接口 - 视频号 openChannelsUserProfile: 跳转视频号主页 getChannelsLiveInfo: 获取直播信息 openChannelsLive: 跳转直播页面 代码示例 跳转视频号 跳转直播间 handleJumpVideoChannel() { wx.openChannelsUserProfile({ finderUserName: 'sphFavmZFOsxVZ2', success(res) { console.log({ res }) }, fail(err) { console.log({ err }) } }) } handleJumpVideoLive() { wx.getChannelsLiveInfo({ finderUserName: 'sphFavmZFOsxVZ2', success(res) { console.log({ res }) wx.openChannelsLive({ finderUserName: 'sphFavmZFOsxVZ2', feedId: res.feedId, nonceId: res.nonceId, success(res1) { console.log({ res1 }) }, fail(err1) { console.log({ err1 }) } }) }, fail(err) { console.log({ err }) } }) } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/internationalization/":{"url":"pages/experience/internationalization/","title":"国际化","keywords":"","body":"国际化方案 方案一： i18N + cnchar i18N 配置 vue3.0 + vue-i18n@next step-1: 下载最新vue-i18n@next【vue-il8n下载的il8n版本是无法支持vue3.0】 npm install vue-i18n@next -D step-2: 国际化语言配置 import { createI18n } from 'vue-i18n' const i18n = createI18n({ locale: 'ch', //默认显示的语言 messages: { ch: require('./ch.js'), //引入语言文件 en: require('./en.js') } }) export default i18n; step-3: 修改main.js import { createApp } from 'vue' import App from './App.vue' import VueI18n from './language' createApp(App).use(VueI18n).mount('#app') step-4: i18n 的基本使用 step-5: i18n 语言切换 import { getCurrentInstance } from \"vue\"; export default { name: \"App\", setup() { const { proxy } = getCurrentInstance(); function change(type) { proxy.$i18n.locale = type; } return { change }; } }; cnchar: 接口数据翻译 const cnchar = require('cnchar') const trad = require('cnchar-trad') cnchar.use(trad) const simpleText = '汉字' const tradText = 'english' // 简体转繁体 console.log(cnchar.convert.simpleToTrad(simpleText)) console.log(simpleText.convertSimpleToTrad()) // ajax 请求拦截器 function interceptSuccess(res) { const { statusCode, config, data } = res // 200 至 300 或 304：请求成功 if (validateStatus(statusCode)) { if (__LNG_TYPE__ === 'hk') { return JSON.parse(cnchar.convert.simpleToTrad(JSON.stringify(data))) } return data } // 401：登录态无效 if (statusCode === 401) { return handle401(config, data) } // 其他：非 4xx 状态码重试请求 if (!/^4\\d{2}/.test(statusCode)) { const [needRetry, request] = retry(config) if (needRetry) { return request } } // 异常提示信息 let message = '网络异常' if (statusCode === 400) message = '客户端异常' if (statusCode === 404) message = '请求链接未找到' if (/^5\\d{2}/.test(statusCode)) message = '服务器繁忙' return { code: -1, message } } 方案二：Translate【plugin / loader】 webpack plugin const cnchar = require('cnchar') const trad = require('cnchar-trad') cnchar.use(trad) module.exports = class SimpleToTrad { // 插件配置的参数 constructor(option = {}) { this.option = option; } // 固定的 apply(compiler) { compiler.hooks.emit.tap('simpleToTrad', compilation => { const assets = compilation.getAssets(); for (const file of assets) { if (/\\.js$/.test(file.name)) { const { source } = compilation.getAsset(file.name) let newSource = '' newSource = cnchar.convert.simpleToTrad(source.source()) const optionKeys = Object.keys(this.option) optionKeys.length && optionKeys.forEach(key => { newSource = newSource.replace(new RegExp(key, 'g'), this.option[key]) }) compilation.assets[file.name] = { source: function () { return newSource; }, size: function () { return newSource.length } } } } }) } } loader 的方式 module.exports = { chainWebpack(config) { config.module .rule('language') .test(/\\.(js|vue)$/) .use('language-hk-loader') .loader('language-hk-loader') .end() } } gulp plugin const through = require('through2') const PluginError = require('plugin-error') const cnchar = require('cnchar') const trad = require('cnchar-trad') cnchar.use(trad) module.exports = function(opt) { let options = opt || {} function simple2trad(file, encoding, callback) { if (file.isNull()) { this.push(file) return callback() } if (file.isStream()) { this.emit('end') return new callback(PluginError('gulp-simple2trad', 'Streaming not supported:' + file.path)) } let newSource = '' newSource = cnchar.convert.simpleToTrad(file.contents.toString()) const optionKeys = Object.keys(options) optionKeys.length && optionKeys.forEach(key => { newSource = newSource.replace(new RegExp(key, 'g'), options[key]) }) file.contents = Buffer.from(newSource) this.push(file) callback() } return through.obj(simple2trad) } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/biEcharts/":{"url":"pages/experience/biEcharts/","title":"BI-Echarts","keywords":"","body":"eCharts 基础配置 主题配置 { \"color\": [ \"#c12e34\", \"#e6b600\", \"#0098d9\", \"#2b821d\", \"#005eaa\", \"#339ca8\", \"#cda819\", \"#32a487\" ], \"backgroundColor\": \"rgba(12, 249, 255, 0)\", \"textStyle\": {}, \"title\": { \"textStyle\": { \"color\": \"#7982a9\", \"fontWeight\": \"normal\", \"fontSize\": \"16px\" }, \"subtextStyle\": { \"color\": \"#aaaaaa\" } }, \"line\": { \"itemStyle\": { \"normal\": { \"borderWidth\": 1 } }, \"lineStyle\": { \"normal\": { \"width\": 2 } }, \"symbolSize\": 4, \"symbol\": \"emptyCircle\", \"smooth\": false }, \"radar\": { \"itemStyle\": { \"normal\": { \"borderWidth\": 1 } }, \"lineStyle\": { \"normal\": { \"width\": 2 } }, \"symbolSize\": 4, \"symbol\": \"emptyCircle\", \"smooth\": false }, ... } 地图配置 map json 数据制作 https://hxkj.vip/demo/echartsMap/ 地图描边以及背景色配置 中国地图外部轮廓： geo.itemStyle 中国地图省份轮廓： series.itemStyle normal 为普通状态下的样式，emphasis 为选中状态下的样式 const itemStyle = { color:\"#fff\", // 颜色 borderColor:\"blue\", // 边框颜色 borderWidth:0, // 柱条的描边宽度，默认不描边。 borderType:\"solid\", // 柱条的描边类型，默认为实线，支持 'dashed', 'dotted'。 barBorderRadius:10, // 柱形边框圆角半径，单位px，支持传入数组分别指定柱形4个圆角半径。 shadowBlur:10, // 图形阴影的模糊大小。 shadowColor:\"#000\", // 阴影颜色 shadowOffsetX:0, // 阴影水平方向上的偏移距离。 shadowOffsetY:0, // 阴影垂直方向上的偏移距离。 opacity:1, // 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 } const options = { geo: { label: { normal: { show: false }, emphasis: { show: false } }, itemStyle: { normal: { areaColor: '#0c1022', label: { show: false } }, emphasis: { areaColor: '#0c1022', label: { show: false } }, }, }, series: { itemStyle: { normal: { areaColor: '#0c1022', label: { show: false } }, emphasis: { areaColor: '#0c1022', label: { show: false } }, }, } } 地图高亮部分省份 series.data const myItemStyle = { normal: { areaColor: 'rgba(255, 227, 144)', color: \"rgba(255, 227, 144)\", borderColor: \"rgba(255, 227, 144)\", borderWidth: 0, borderType: \"solid\", // opacity: .3, label: { show: false } }, emphasis: { areaColor: 'rgba(255, 227, 144)', label: { show: false } }, } series: [ { name: '中国地图', type: 'map', mapType: 'CHINA', label: { show: false, }, selectedMode: false, itemStyle: { normal: { areaColor: '#0c1022', label: { show: false } }, emphasis: { areaColor: '#0c1022', label: { show: false } }, }, data: [ {name: '广东省', value: 20057, itemStyle: myItemStyle}, {name: '湖南省', value: 31686, itemStyle: myItemStyle}, {name: '湖北省', value: 6992, itemStyle: myItemStyle}, {name: '四川省', value: 44045, itemStyle: myItemStyle}, {name: '河南省', value: 40689, itemStyle: myItemStyle}, {name: '江西省', value: 37659, itemStyle: myItemStyle}, {name: '福建省', value: 45180, itemStyle: myItemStyle}, {name: '青海省', value: 55204, itemStyle: myItemStyle}, {name: '西藏自治区', value: 21900, itemStyle: myItemStyle}, {name: '新疆维吾尔自治区', value: 4918, itemStyle: myItemStyle}, {name: '内蒙古自治区', value: 5881, itemStyle: myItemStyle}, {name: '广西壮族自治区', value: 5881, itemStyle: myItemStyle}, {name: '宁夏回族自治区', value: 5881, itemStyle: myItemStyle}, {name: '云南省', value: 4178, itemStyle: myItemStyle}, {name: '安徽省', value: 2227, itemStyle: myItemStyle}, {name: '浙江省', value: 2180, itemStyle: myItemStyle}, {name: '山东省', value: 9172, itemStyle: myItemStyle}, {name: '黑龙江省', value: 9172, itemStyle: myItemStyle}, {name: '江苏省', value: 9172, itemStyle: myItemStyle}, {name: '贵州省', value: 9172, itemStyle: myItemStyle}, {name: '吉林省', value: 9172, itemStyle: myItemStyle}, {name: '辽宁省', value: 9172, itemStyle: myItemStyle}, {name: '河北省', value: 9172, itemStyle: myItemStyle}, {name: '甘肃省', value: 9172, itemStyle: myItemStyle}, {name: '山西省', value: 9172, itemStyle: myItemStyle}, {name: '海南省', value: 9172, itemStyle: myItemStyle}, {name: '台湾省', value: 9172, itemStyle: myItemStyle}, {name: '天津市', value: 9172, itemStyle: myItemStyle}, {name: '北京市', value: 9172, itemStyle: myItemStyle}, {name: '上海市', value: 9172, itemStyle: myItemStyle}, ], } ] 通用配置说明 const option = { // 设置图表离容器的边距 grid: [{ left: '8%', bottom: '15%', top: '30%', right: '8%' }], // x 轴坐标配置 xAxis: { type: 'category', data: ['07.09', '07.20', '07.21', '07.22', '07.23', '07.24', '07.25'] }, // y 轴坐标配置 yAxis: [ { type: 'value', position: 'left', splitLine: { lineStyle: { color: 'rgba(255, 255, 255, .2)' }, show: true // 背景网格 } }, { type: 'value', position: 'right', axisLabel: { formatter: '{value}%' }, } ], // 图例组件展现了不同系列的标记，颜色和名字 legend: { data: ['上拍台次', '拍出台次', '台次拍出率'], textStyle: { color: '#fff' }, top: '5%' }, } 柱状图堆砌: stack const series = [ { data: [120, 200, 180], name: '上拍台数', type: 'bar', barWidth: '15%', yAxisIndex: 0, showBackground: true, backgroundStyle: { color: 'rgba(12, 249, 255, 0)' }, }, { name: '拍出台数', type: 'bar', stack: 'Ad', // 堆砌 barWidth: '15%', yAxisIndex: 0, emphasis: { focus: 'series' }, backgroundStyle: { color: 'rgba(12, 249, 255, 0)' }, itemStyle: { color: '#ff5a5a' }, data: [120, 132, 101] }, { name: '撮合台数', type: 'bar', stack: 'Ad', // 堆砌 barWidth: '15%', yAxisIndex: 0, emphasis: { focus: 'series' }, backgroundStyle: { color: '#ffc148' }, itemStyle: { color: '#ffc148' }, data: [220, 182, 191] }, ] 折线图设置 阴隐： areaStyle 曲线：smooth const series = [{ name: '成交率', type: 'line', yAxisIndex: 1, lineStyle: { color: '#4992ff' }, // 阴隐 areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(58, 77, 233, 0.3)' }, { offset: 1, color: 'rgba(58, 77, 233, 0.1)' }]) }, data: [20, 120, 150], label: { show: true, position: 'top', formatter: '{c}%', textStyle: { align: 'center', fontSize: 14, color: '#4992ff', // 文字阴影，还可以设置背景块颜色和阴影 textShadowColor: '#000', textShadowBlur: 4, textShadowOffsetX: 1, textShadowOffsetY: 1 }, }, }, { name: '月毛利率', type: 'line', smooth: 0.6, // 曲线 symbol: 'none', yAxisIndex: 1, lineStyle: { color: '#ff5a5a', type: 'dashed' }, data: [100, 110, 100, 90, 100], label: { show: false, position: 'top', formatter: '{c}%', textStyle: { align: 'center', fontSize: 14, color: '#4992ff' }, }, }] 坐标轴样式设置：刻度、坐标轴颜色 const xAxis = { type: 'category', data: ['11.19', '11.20', '11.21', '11.22', '11.23', '11.24', '11.25'], // 坐标轴刻度相关设置 axisTick: { lineStyle: { color: 'transparent', } }, // 坐标轴轴线相关设置 axisLine: { lineStyle: { color: \"rgba(255, 255, 255, .6)\" } }, // 坐标轴刻度标签的相关设置 axisLabel: { textStyle: { fontSize: this.fontSize } }, } 图例组件 legend 设置 const legend = { // icon: 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow', 'none' data: [ { name: '上拍台次', icon: 'rect' }, { name: '拍出台次', icon: 'rect' }, { name: '台次拍出率' }, ], // 文字字体大小和颜色，也可以设置背景和阴影 textStyle: { color: '#fff', fontSize: this.fontSize }, // 图例列表的布局朝向 orient: 'horizontal', top: '5%' } 仪表盘尺寸设置 刻度盘宽度 -> axisLine.lineStyle.width 长刻度线 -> axisTick: distance + length 短刻度线 -> splitLine: distance + length 刻度数字 -> axisLabel: distance 饼图的尺寸大小设置就比较简单，直接由内径和外径决定： radius: ['35%', '70%'] const gauge = { type: 'gauge', center: ['25%', '60%'], radius: '70%', axisLine: { lineStyle: { // 仪表盘刻度盘宽度 width: 15, // 仪表盘刻度盘颜色 color: [ [0.3, '#0CF9FF'], [0.7, '#4992ff'], [1, '#ff5a5a'] ] } }, pointer: { itemStyle: { color: 'auto' } }, // 长刻度线设置 axisTick: { // 长刻度线位置 distance: -15, // 长刻度线长度 length: 8, lineStyle: { color: '#fff', width: 1 } }, // 短刻度线设置 splitLine: { // 短刻度线位置 distance: -15, // 短刻度线长度 length: 15, lineStyle: { color: '#fff', width: 1 } }, // 刻度数字设置 axisLabel: { color: 'auto', // 刻度数字位置 distance: 20, fontSize: 6 }, title: { show : true, offsetCenter: [0, '75%'], textStyle: { fontSize: 14, color: '#ff5a5a' } }, detail: { valueAnimation: true, formatter: '{value}%', textStyle:{ fontSize: 14, color: '#ff5a5a' }, offsetCenter: [0, \"50%\"], }, data: [{ value: 70, name: '关单率', }] } formatter 字符串模板 {a}：系列名。 {b}：数据名。 {c}：数据值。 {@xxx}：数据中名为 'xxx' 的维度的值，如 {@product} 表示名为 'product' 的维度的值。 {@[n]}：数据中维度 n 的值，如 {@[3]} 表示维度 3 的值，从 0 开始计数。 回调函数 (params: Object|Array) => string const formatter = params => params.value === 0 ? `${params.value}%` : `${params.value.toFixed(1)}%` Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/lowCode/":{"url":"pages/experience/lowCode/","title":"低代码","keywords":"","body":"数据可视化低代码平台搭建 难点 如何动态引入组件库 组件数据分离，配置数据结构设计 如何递归渲染来实现组件嵌套 拖拽问题：1.物料堆拖拽到主舞台；2.组件在主舞台中的位置调整（目前还未实现） 配置面板人性化设计，如何抽离出需要修改的数据 四大组成部分 顶栏：标题 + 操作按钮 物料堆：物料图标 + 组件名称 主舞台：本质是渲染引擎，需要一次性全量引入所有组件 配置面板：本质是修改图表样式，部分逻辑可以转移到鼠标右击事件 动态引入组件库：全量引入 require.context(directory, useSubdirectories, regExp) directory: 表示检索的目录 useSubdirectories: 表示是否检索子目录 regExp: 匹配文件的正则表达式，一般是文件名 const parseReq = require.context('./', true, /(.+)Parse\\.ts/) export const parsers = parseReq.keys().reduce((parsers, module) => { const mod = parseReq(module) parsers[mod.default.key] = mod.default return parsers }, {}) // 测试 id, keys(), resolve(path) 和 parseReq(path) const test = parseReq.keys().map(item => { const mod = parseReq(item) const resolve = parseReq.resolve(item) return {name: mod, resolve, item} }) console.log({ keys: parseReq.keys(), id: parseReq.id, test, parseReq }) parseReq 对象有三个属性：resolve, keys, id。当然，它本省也是一个函数: id 是 context module 里面所包含的模块 id。 keys() 是一个函数，它返回一个数组，就是相对 directory 的路径。 resolve(path) 是一个函数，需要一个参数：keys()数组中的相对路径，它返回一个相对于根目录的路径（绝对路径）。 parseReq(path) 是一个函数，需要一个参数：keys()数组中的相对路径，它返回模块内容：module.default/module.default.name【此处尽量使用自己在模块中明确定义的静态属性，不要去使用 module.default.name 这种隐式属性】。 递归渲染，组件嵌套 首先想到的是 jsx 的 render 函数: https://cn.vuejs.org/v2/guide/render-function.html#JSX 此处要注意区分 on 和 nativeOn 的区别： on: 组件本身封装的方法，组件内部使用 vm.$emit 触发的事件。 nativeOn: 原生事件，类似于 native 修饰符： 组件 render 函数的三个参数： h: createElement 函数 section: 包含所有渲染组件需要的数据：图表类型、数据、标题、样式、拖拽事件和唯一标识 uuid children: 子组件，类似于 模板组件的 slot，这个参数可以实现组件嵌套 // 组件 class ChartBoxParse extends Vue { static options: any = options render (h, section, children) { const options = handleOptionsData(section.section.option.options) const _props = { props: { jsonSchema: section.section, // @ts-ignore title: options.cssStyle.title, cssStyle: options.cssStyle, } } const _propsOn = { on: { dragover: section.handleDragOver, drop: section.handleDrop }, nativeOn: { click: (e) => { e.stopPropagation() store.dispatch('biCharts/setSelectedType', { selectedType: 'ChartBoxParse' }) store.dispatch('biCharts/setUuid', { uuid: section.section.uuid, }) } } } return ( { children } ) } } // 渲染引擎 export default class RenderEngine extends Vue { @biCharts.Action('setSelectedType') setSelectedType @biCharts.Action('setUuid') setUuid @biCharts.State('selectedType') selectedType @Prop({default: () => ({})}) jsonSchema // 渲染根节点 renderRoot (h) { // TODO: 后期丰富全局配置逻辑入口 return ( { this.renderComponents(h, this.jsonSchema) } ) } // 渲染组件 renderComponents (h, section) { // 组件通用逻辑在此处理 // 是否有子节点 let _children = null if (section.children) { // 层级渲染 _children = this.renderChildren(h, section) } return this.startRender(h, section, _children) } // 遍历包含兄弟&子节点 renderChildren (h, section) { let _nodeArray = section.children || [].concat(section) // 后期可以在此拓展兄弟节点之间通信 return _nodeArray.map((n, i) => this.renderComponents(h, n, i)) } // 开始渲染 startRender (h, section, _children) { // console.log({ section }) const _type = section.type const renderMod = parsers[_type] // 直接渲染 if (renderMod) { return renderMod.extendOptions.render(h, { section, handleDrop: this.handleDrop, handleDragOver: this.handleDragOver }, _children) } return null } // 以下为配置系统统一化处理逻辑 // 拖拽组件经过触发 handleDragOver () { // TODO: 拖拽组件经过容器组件时触发高亮效果 } // 拖拽组件松手 handleDrop (event, vm) { const _json = vm.jsonSchema if (_json && (_json.type.includes('Container') || _json.type.includes('Map') || _json.type.includes('Box'))) { if (!_json.children) { this.$set(_json, 'children', []) } const uuid = uuidv4() _json.children.push({ type: this.selectedType, option: parsers[this.selectedType].options, uuid, }) this.setUuid({ uuid }) } } render (h) { let _vode = this.renderRoot(h) return _vode } } 拖拽 暂时使用原生拖拽事件，后续可优化： https://github.com/SortableJS/Vue.Draggable 主舞台和渲染引擎的思考 两种做法：1. 所见即所得，渲染引擎一体化；2. 多态舞台，分开维护。 所见即所得，渲染引擎一体化的特点：配置前后的差异小，维护成本低，主舞台和渲染引擎是一套代码，但是复杂度比较高，逻辑集成度高。 多态舞台，分开维护的特点：分开两拨人维护对用的主舞台和渲染引擎，效率高，逻辑相对简单，但配置前后会有差异问题。 折中方案：采用所见即所得的方案，在渲染引擎进行数据渲染之前先对数据进行预处理，并将预处理流程单独抽离。数据预处理要做的事情：1. 去掉拖拽事件；2. 去掉 dragover 或者选中时候的样式。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/taroWepy/":{"url":"pages/experience/taroWepy/","title":"wepy->taro","keywords":"","body":"WEPY&TARO混合小程序 知识点 lerna ✅ wepy 打包机制 taro 打包机制 child_process promise babel const babel = require(\"@babel/core\") const template = require(\"@babel/template\").default const generate = require(\"@babel/generator\").default const traverse = require(\"@babel/traverse\").default wepy 打包机制 const path = require('path') const globalInject = require('./src/config/globalVarInject.js') const { NODE_ENV } = process.env const isProd = NODE_ENV === 'production' const isTest = NODE_ENV === 'test' const uglifyjsFilterRegExp = /^((?!\\/npm\\/).)*\\.js$/ module.exports = { target: 'dist/lixin', // 占位符，将被替换成target: 'dist/lixin' or target: 'dist/lexus' wpyExt: '.wpy', resolve: { alias: { '@': path.join(__dirname, 'src') }, modules: ['node_modules'] }, eslint: true, compilers: { // 压缩less less: { compress: true, paths: [ // path.resolve(__dirname, 'src/assets/base') ] }, // babel babel: { sourceMap: false, presets: [ 'env' ], plugins: [ 'transform-class-properties', 'transform-decorators-legacy', 'transform-object-rest-spread', 'transform-export-extensions', 'transform-node-env-inline', ['global-define', globalInject] ] } }, appConfig: { noPromiseAPI: ['createSelectorQuery'] }, plugins: { // 压缩js uglifyjs: { filter: uglifyjsFilterRegExp, // uglifyjs 对第三方包可能会出现压缩出错不兼容情况，针对第三方包不在压缩 config: {} } } } taro 打包机制 const path = require('path') const wepyProjectRoot = path.posix.resolve(__dirname, '../../wepy-project') const wepyConfigPath = path.posix.join(wepyProjectRoot, 'wepy.config.js') const taroProjectRoot = path.posix.resolve(__dirname, '../') const target = require(wepyConfigPath).target // const wxappDistDir = path.posix.join(wepyProjectRoot, target) // const nameInDir = 'taro' const globalInject = require(path.posix.join(wepyProjectRoot, 'src/config/globalVarInject.js')) const injects = {} Object.keys(globalInject).forEach(key => { injects[key] = JSON.stringify(globalInject[key]) }) const config = { projectName: 'taro-project', date: '2021-7-7', designWidth: 750, deviceRatio: { 640: 2.34 / 2, 750: 1, 828: 1.81 / 2 }, sourceRoot: 'src', outputRoot: 'dist', plugins: [ '@tarojs/plugin-platform-weapp', '@tarojs/plugin-indie', path.posix.join(process.cwd(), 'plugins/taro-plugin-patch-addChunkPages/index.js'), // 将打包好的文件复制一份到wepy打包目录下 path.posix.join(process.cwd(), 'plugins/taro-plugin-mv/index.js') ], alias: { 'src': path.posix.join(taroProjectRoot, '/src'), // 这个要引用原项目文件，因为less文件中定义了一些变量，在taro中需要使用 '@@/style': path.posix.resolve(__dirname, '../../wepy-project/src/assets') }, env: { // DIST_WXAPP_DIR: JSON.stringify(wxappDistDir), TEMP_TYPE: JSON.stringify(target.split('/')[1]) }, defineConstants: { ...injects }, copy: { patterns: [ ], options: { } }, framework: 'react', mini: { addChunkPages (pages) { // taro对这里的处理由bug，所以利用taro-plugin-patch-addChunkPages插件打了补丁 pages.set('pages/auction/cardetail', ['pages/auction/auction-components']), pages.set('pages/auction/finishCarDetail', ['pages/auction/auction-components']) }, webpackChain (chain) { chain.merge({ externals: [ (context, request, callback) => { if (request.startsWith('@dist')) { const res = replaceRoute(request.replace('@dist', '')) return callback(null, res) } callback() }, { // 将taro包中的npm脚本指向wepy已经构建好的npm包，请确保wepy构建已经将npm包放在npm目录下 // __REPLACE__是提供给relative-lib-path-webpack-plugin插件识别的关键字 'dayjs': replaceRoute('/npm/dayjs/dayjs.min.js'), '@lx-frontend/report': replaceRoute('/npm/@lx-frontend/report/lib/index.js'), 'big.js': replaceRoute('/npm/big.js/big.js'), 'redux': replaceRoute('/npm/redux/lib/redux.js'), 'redux-thunk': replaceRoute('/npm/redux-thunk/lib/index.js'), 'cnchar-trad': replaceRoute('/npm/cnchar-trad/cnchar.trad.min.js'), 'cnchar': replaceRoute('/npm/cnchar/cnchar.min.js') }, (context, request, callback) => { // 处理lodash，lodash代码从venders.js中剔除，改从npm直接引用 // 依然需要借助relative-lib-path-webpack-plugin插件完成路径转化 // 如果直接引用的lodash而不是某一个明确的lodash函数，则不处理 const isLodash = /^lodash.+/.test(request) const extName = path.posix.extname(request) if (isLodash) { const fullRequestName = extName === '' ? `${request}.js` : request return callback(null, replaceRoute(`/npm/${fullRequestName}`)) } callback() }, ], plugin: { relativeLib: { plugin: require('../plugins/relative-lib-path-webpack-plugin') } }, optimization: { splitChunks: { cacheGroups: { auctionComps: { name: 'pages/auction/auction-components', minChunks: 1, test: (module) => { return /pages\\/auction\\/components/.test(module.resource) || /pages\\/auction\\/scripts/.test(module.resource) }, priority: 200 } } } } }) }, postcss: { pxtransform: { enable: false, config: {} }, url: { enable: true, config: { limit: 1024 // 设定转换尺寸上限 } }, cssModules: { enable: true, // 默认为 false，如需使用 css modules 功能，则设为 true config: { namingPattern: 'module', // 转换模式，取值为 global/module generateScopedName: '[name]__[local]___[hash:base64:5]' } } }, miniCssExtractPluginOption: { //忽略css文件引入顺序 ignoreOrder: true } } } wepy 与 taro 混合使用 打包后的小程序本质是，把一系列资源按照特定的规则进行整合，而这个规则的描述文件就是 app.json 所以只要满足小程序的规则，就可以将 wepy 与 taro 打包后的文件进行组合使用。 混合使用需要做的三件事： 在wepy 打包后的文件中，找到 app.js 引入 const taroApp = require('./taro/app.js').taroApp Promise.resolve().then(function() { var taroApp = require(\"./taro/app.js\"); }) 在wepy 打包后的文件中，找到 app.wxss 引入 @import './taro/app.wxss'; 在wepy 打包后的文件中，找到 app.json 加入新页面路径，比如： newTaroSubPackages: [ { root: 'taro/pages/auction', pages: [Array] }, { root: 'taro/pages/my', pages: [Array] }, { root: 'taro/pages/sources', pages: [Array] }, { root: 'taro/pages/follow', pages: [Array] }, { root: 'taro/pages/reviewManage', pages: [Array] } ] lerna 的好处 依赖安装：npm install && lerna bootstrap，不用切换项目目录。 版本控制：lerna 提供了检查自上一发行版以来已更改了哪些软件包的功能。 同时运行命令：npm run dev:lixin 先打包 wepy, 再打包 taro, 最后打补丁。 主包体积优化 taro 共享 wepy 的 npm 脚本 i18N -> translate taro 分包: taro 的 page 用空页面占位，把所有页面都写入分包 资源的共享方式 配置 alias alias: { 'src': path.posix.join(taroProjectRoot, '/src'), // 这个要引用原项目文件，因为less文件中定义了一些变量，在taro中需要使用 '@@/style': path.posix.resolve(__dirname, '../../wepy-project/src/assets') } 配置 externals The 'commonjs ' + request defines the type of module that needs to be externalized: https://www.webpackjs.com/configuration/externals/ const replaceRoute = (rt) => `commonjs __REPLACE__${rt}` webpackChain (chain) { chain.merge({ externals: [ // taro 直接使用 wepy 的资源文件，__REPLACE__ 是占位符，会被替换成相对路径，借助relative-lib-path-webpack-plugin插件完成路径转化。 (context, request, callback) => { if (request.startsWith('@dist')) { const res = replaceRoute(request.replace('@dist', '')) // console.log({ request, res }) return callback(null, res) } callback() }, // 第三方资源文件也直接使用 wepy 打包好的，都放在 npm 目录下。 { // 将taro包中的npm脚本指向wepy已经构建好的npm包，请确保wepy构建已经将npm包放在npm目录下 // __REPLACE__是提供给relative-lib-path-webpack-plugin插件识别的关键字 'dayjs': replaceRoute('/npm/dayjs/dayjs.min.js'), '@lx-frontend/report': replaceRoute('/npm/@lx-frontend/report/lib/index.js'), 'big.js': replaceRoute('/npm/big.js/big.js'), 'redux': replaceRoute('/npm/redux/lib/redux.js'), 'redux-thunk': replaceRoute('/npm/redux-thunk/lib/index.js'), 'cnchar-trad': replaceRoute('/npm/cnchar-trad/cnchar.trad.min.js'), 'cnchar': replaceRoute('/npm/cnchar/cnchar.min.js') }, (context, request, callback) => { // 处理lodash，lodash代码从venders.js中剔除，改从npm直接引用 // 依然需要借助relative-lib-path-webpack-plugin插件完成路径转化 // 如果直接引用的lodash而不是某一个明确的lodash函数，则不处理 const isLodash = /^lodash.+/.test(request) const extName = path.posix.extname(request) if (isLodash) { const fullRequestName = extName === '' ? `${request}.js` : request return callback(null, replaceRoute(`/npm/${fullRequestName}`)) } callback() }, ] }) } 打包及热更新 借助于node 的 child_process.spawn 监听输出: .standout.on() 灰度策略 后端开关 前端配置： export default [ // 已经稳定运行的页面 { '/pages/my/setting': '/taro/pages/my/setting/index', '/pages/my/personaldata': '/taro/pages/my/personaldata/index', '/pages/auction/cardetail': '/taro/pages/auction/cardetail/index' }, // 刚重构的不稳定页面 { '/pages/reviewManage/reviewList': '/taro/pages/reviewManage/reviewList/index', '/pages/reviewManage/reviewSubmit': '/taro/pages/reviewManage/reviewSubmit/index' } ] 路由跳转代理 function proxyWxRouterFunction(stableMap, unStableMap, isUseNew) { function generateProxyFunction(wx, funName) { return function(options) { const { url } = options const urlWithNoParams = url.split('?')[0] const urlParams = url.split('?')[1] if ( // 1. 如果不属于任何映射表，直接跳转 (!stableMap[urlWithNoParams] && !unStableMap[urlWithNoParams]) || // 2. 如果属于不稳定映射表，且灰度关闭，直接跳 (unStableMap[urlWithNoParams] && !isUseNew) ) { wx[funName](options) return } if ( // 3. 如果属于稳定映射表，跳新页面，忽略灰度策略开关，跳新页面 stableMap[urlWithNoParams] || // 4. 如果属于不稳定表，且灰度开启，尝试跳转新页面，失败后则跳转旧页面 (unStableMap[urlWithNoParams] && isUseNew) ) { const newUrl = `${stableMap[urlWithNoParams] || unStableMap[urlWithNoParams]}?${urlParams}` const newFail = function(err) { // 跳转失败，则再尝试跳回wepy页面，并上报 const extra = { wepyUrl: url, taroUrl: newUrl, errMsg: err } console.log('跳转失败，跳回wepy页面：', extra) reportBusinessException('跳转Taro页面失败，跳回Wepy页面', extra) wx[funName](options) } wx[funName]({ ...options, url: newUrl, fail: newFail }) } } } const wxProxy = new Proxy(wx, { get(target, property) { console.log('wx property:', property) if (['reLaunch', 'redirectTo', 'navigateTo'].includes(property)) { return generateProxyFunction(target, property) } if (property === 'isProxyOpen') { return isUseNew } return target[property] } }) return wxProxy } react hooks 问题 问题：useState 设置 state 后，无法立即获取最新值，导致流程原来的无法保持一致。 解决方案：1. 传参；2. redux. 官方解决方案：useEvent: https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/miniprogramCi/":{"url":"pages/experience/miniprogramCi/","title":"miniprogram-ci","keywords":"","body":"miniprogram-ci miniprogram-ci 是从微信开发者工具中抽离的关于小程序/小游戏项目代码的编译模块。 开发者可不打开小程序开发者工具，独立使用 miniprogram-ci 进行小程序代码的上传、预览等操作。 文档地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html 使用步骤 step-1: 密钥及 IP 白名单配置 【微信公众平台-开发-开发设置-下载代码上传密钥-配置 IP 白名单】=> 公网 IP step-2: 脚本调用 npm install miniprogram-ci --save step-3: 代码编写 const ci = require('miniprogram-ci') const path = require('path') const project = new ci.Project({ appid: 'wxc53b8fcb9acdd6c7', type: 'miniProgram', projectPath: path.resolve(__dirname, './stock_forecast_calculator_cloud'), privateKeyPath: path.resolve(__dirname, './private.key'), ignores: ['node_modules/**/*'], }) const upload = async () => { const uploadResult = await ci.upload({ project, version: '1.4.19', desc: 'update', setting: { es6: true, }, onProgressUpdate: () => {}, robot: Math.ceil(Math.random() * 29 + 1) }) } upload() 结合 gulp 使用，动态传入描述内容 gulp upload --desc=test const ci = require('miniprogram-ci') const path = require('path') const argv = require('yargs').argv const { desc } = argv const project = new ci.Project({ appid: 'wxc53b8fcb9acdd6c7', type: 'miniProgram', projectPath: path.resolve(__dirname, './stock_forecast_calculator_cloud'), privateKeyPath: path.resolve(__dirname, './private.key'), ignores: ['node_modules/**/*'], }) const upload = async () => { const uploadResult = await ci.upload({ project, version: '1.4.19', desc, setting: { es6: true, }, onProgressUpdate: () => {}, robot: Math.ceil(Math.random() * 29 + 1) }) } exports.upload = upload Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/fullScreen/":{"url":"pages/experience/fullScreen/","title":"full-screen","keywords":"","body":"fullScreen 全屏事件切换 进入全屏模式： Element.requestFullscreen(options) 退出全屏模式： Element.exitFullscreen(options) mounted 的时候，绑定全屏监听事件：window.addEventListener(\"fullscreenchange\", () => {}) destroyed 的时候，解除全屏监听事件：window.removeEventListener(\"fullscreenchange\", () => {}) mounted () { // 绑定全屏监听事件 window.addEventListener('fullscreenchange', e => { this.handleScreenChange() }) } destroyed () { // 解除全屏监听事件 window.removeEventListener('fullscreenchange', e => { this.handleScreenChange() }) } /** * 页面全屏事件 */ handleFullScreen () { if (!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement)) { const video = document.documentElement as any; const rfs = video.requestFullscreen || video.webkitRequestFullScreen || video.mozRequestFullScreen || video.msRequestFullscreen; rfs.call(video); } else { const rfs = document.exitFullscreen || document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen; rfs.call(document); } } /** * 全屏监听函数 */ handleScreenChange () { const isFullscreen = !(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) if (isFullscreen) { // 退出全屏 this.toggleNavCrumb(false) } else { // 全屏显示 this.toggleNavCrumb(true) } } /** * 切换导航栏和面包屑的显示隐藏 */ toggleNavCrumb (bool) { this.updateNav(bool) this.hideCrumb(bool) } 需要注意的细节点 fullscreenchange 的监听有浏览器兼容问题，可以直接将 toggleNavCrumb 放到 handleFullScreen 里面。 页面全屏事件，只能用户手动出发，不发自动全屏。类似声音和视频的自动播放。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/silentLogin/":{"url":"pages/experience/silentLogin/","title":"静默登录","keywords":"","body":"静默登录实现（PC 端） 原因：BI 报表大屏展示的过程中，用户登录态过期，导致需要重新扫码登录，用户体验极差。 思路 新增 refresh_token 比原来的 access_token 的有效期长，当 access_token 过期的时候，可以拿有效期更长的 refresh_token，重新自动登录。 难点 初步流程：页面发送请求 -> 登录态过期 -> refresh_token 重新登录 -> 更新 access_token -> 刷新页面 location.reload() 如何做到用户无感知静默登录？ 不调用 location.reload()，不刷新页面 优化流程：页面发送请求 -> 登录态过期 -> Promise 缓存请求 -> refresh_token 重新登录 -> 更新 access_token -> 重新发送请求 Promise 缓存请求核心代码 // 处理时机：axios 拦截器 let retryTasks = []; const responseErrorInterceptor = (ctx: typeof ajax) => (err) => { const { response } = err; if (response) { const { status } = response; switch (status) { case 401: // 用户没有登录态 // !!! 利用 Promise 缓存请求 new Promise(resolve => retryTasks.push(() => resolve(axios(response.config)))) return ajax.$rest.global.getRefreshToken().then(res => { if (res.code === 4001) { // refresh_token 也过期，跳转登录页，此函数内容省略 openNoneLogin(ctx); } if (res.code === 0) { cache.setLocalStorageData('access_token', res.data.access_token); cache.setLocalStorageData('refresh_token', res.data.refresh_token); // 静默登录后重新发起请求，调用 Promise 的 resolve retryTasks.forEach(fn => fn()) // location.reload() retryTasks = [] } }); break; default: ctx.showTips(`error:${err.response.status}`); break; } const res = normalizeRes(err.response); // return Promise.reject(res.data); // 返回接口返回的错误信息 return res; } return null; }; 需要注意的细节点 refresh_token 接口的参数不要使用 query 传递，不安全，直接放 headers 里面。 手动登出的时候，需要清空本地 localStorage 里面的 refresh_token，避免无法切换登录用户。 首次扫码登录成功，将 refresh_token 存储到 localStorage 后，需要删除 url 上面的 refresh_token，避免暴露关键信息。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/timeDiff/":{"url":"pages/experience/timeDiff/","title":"时间差异","keywords":"","body":"android 与 ios 时间上的区别 区别 adroid：时间一般以 YYYY - MM - DD hh:mm:ss 显示，年月日以横线分隔 ios：时间以 YYYY/MM/DD hh:mm:ss 显示，年月日以斜线分隔 兼容处理 const finishTime = '2022-12-12 12:12:12' if (new Date(finishTime.replace(/-/g, '/')).getTime() Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/issue/":{"url":"pages/experience/issue/","title":"issue模板","keywords":"","body":"issue-1 版本 1.8.3 tapd 地址 https://www.tapd.cn/20094861/bugtrace/bugs/view?bug_id=1120094861001007864&url_cache_key=9b1f1a5337cb7a2d86b2f33c22ba0337 复现步骤 打开拍卖小程序，进入拍卖大厅 点击拍卖中场次，进入场次详情 点击拍卖中车辆，进入车辆详情 期望的结果 出价动效顺畅 实际发生 出价动效卡顿 其他 引入版本： 1.8.3车辆详情改版，添加动画 具体原因：position设置的是DOM的样式，实现动画效果同时消耗CPU和内存，在性能不好的安卓手机上，会有很严重的卡顿 解决方案：absolute -> transform3d transform 使用的是显卡，性能开销低 反思：排版、定位使用position，动画效果使用transform issue-2 版本 1.3.22 tapd 地址 https://www.tapd.cn/20094861/bugtrace/bugs/view/1120094861001006897?corpid=ww4a62ce5c2c07b235&agentid=1000007&code=YrZx7Dn_4nvGxeqNW2PT0hl_K1itqP3L9zIROivTBqw&state=TAPD_QY_WECHAT 复现步骤 打开拍卖小程序竞拍大厅 点击开拍场次 点击正在拍卖的拍卖车辆 期望的结果 去出价按钮可点击 实际发生 去出价按钮不可点击 其他 引入版本： 委托报价版本 1.3.22 具体原因： 添加委托报价功能时，只修改了websocket，没有修改之前的轮询，用户网络状态不好，请求use_socket接口超时，依然走的轮询方式 解决方案： 在轮询中，修改去出价按钮状态 反思： 做需求的时候，没有整体走一遍流程，只关注需求相关业务 issue-3 企业微信版本 3.0.20 tapd 地址 https://www.tapd.cn/20094861/bugtrace/bugs/view?bug_id=1120094861001007394&url_cache_key=d567be72e43d651e68d3f9037b1cc8a1 手机型号 华为p20 复现步骤（部分安卓手机才会复现问题） 车辆管理 -> 零售微店 -> 展示中（辆）-> 分享 -> 确定生成 -> 保存图片 期望的结果 微店分享卡片保存相册成功 实际发生 微店分享卡片保存相册失败，并且没有打开图片保存权限提示 其他 具体原因： 未授权err.errMsg有两种情况，saveImageToPhotosAlbum:fail:auth denied和saveImageToPhotosAlbum:fail auth deny 而我们的判断是，err.errMsg.includes('saveImageToPhotosAlbum:fail auth') 解决方案： 权限判断改为：err.errMsg === 'saveImageToPhotosAlbum:fail:auth denied' || err.errMsg === 'saveImageToPhotosAlbum:fail auth deny' Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/webp/":{"url":"pages/experience/webp/","title":"webp","keywords":"","body":"webp 批量转换 webp const webp=require('webp-converter'); const { resolve, basename, extname } = require('path'); const glob = require(\"glob\") webp.grant_permission(); glob(\"./imgs/*.{gif,png,jp{,e}g}\", { root: resolve(__dirname, './')}, function (er, files) { files.forEach(file => { extname(file) === '.gif' ? webp.gwebp(file, resolve(__dirname,`./webp/${basename(file)}.webp`), \"-q 80\", logging=\"-v\") : webp.cwebp(file, resolve(__dirname,`./webp/${basename(file)}.webp`), \"-q 80\", logging=\"-v\"); }) }) 做一下并发控制，防止超过系统限制 const webp=require('webp-converter'); const { resolve, basename, extname } = require('path'); const glob = require(\"glob\") webp.grant_permission(); const limitGenerate = (files, handler, limit) => { const sequence = [].concat(files) let promises = [] promises = sequence.splice(0, limit).map((file, index) => handler(file).then(() => index)) let p = Promise.race(promises) for (let i = 0; i { promises[res] = handler(sequence[i]).then(() => res) return Promise.race(promises) }).then() } } const generateImg = file => { return new Promise((res) => { console.log(`${file} start`) const result = extname(file) === '.gif' ? webp.gwebp(file, resolve(__dirname,`./webp/${basename(file)}.webp`), \"-q 80\", logging=\"-v\") : webp.cwebp(file, resolve(__dirname,`./webp/${basename(file)}.webp`), \"-q 80\", logging=\"-v\"); result.then(() => { console.log(`${file} end`) res() }); }) } glob(\"./imgs/*.{gif,png,jp{,e}g}\", { root: resolve(__dirname, './')}, function (er, files) { limitGenerate(files, generateImg, 3) }) webp 在页面中的应用: image + background-image /* *注册全局自定义指令 `webp-bg``v-webp` * 是否支持 webp * @memberof isSupportWebp * 如果画布的高度或宽度是0，那么会返回字符串'data:', * 如果传入的类型非'image/png'，但是返回的值以'data:image/png'开头，那么该传入的类型是不支持的。 * */ const isSupportWebp = document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0; Vue.directive('webp', { inserted (el: any) { try { if (isSupportWebp) { if (process.env.RUN_ENV === 'development') { el.src = el.src.replace(/https*:\\/\\/[^/]+\\//, '/'); return; } if (el.src.indexOf('base64')) { return; } el.src = `${el.src}_.webp`; } } catch (err) { return false; } }, }); Vue.directive('webp-bg', { inserted (el: any) { try { if (isSupportWebp) { const str = (el).getAttribute('class').split(' '); str.push('webpa'); el.setAttribute('class', str.join(' ')); } } catch (err) { return false; } }, }); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/markdown/":{"url":"pages/experience/markdown/","title":"markdown","keywords":"","body":"vue 如何解析 markdown vue-markdown-loader const MarkdownItContainer = require('markdown-it-container') module.exports = { parallel: false, chainWebpack: config => { config.module.rule('md') .test(/\\.md/) .use('vue-loader') .loader('vue-loader') .options({ compilerOptions: { preserveWhitespace: false } }) .end() .use('vue-markdown-loader') .loader('vue-markdown-loader/lib/markdown-compiler') // .options({ // raw: true // }) .options({ raw: true, preprocess: (MarkdownIt, source) => { MarkdownIt.renderer.rules.table_open = function () { return '' } // MarkdownIt.renderer.rules.fence = handleFence(MarkdownIt.renderer.rules.fence) const render = MarkdownIt.renderer.rules.fence MarkdownIt.renderer.rules.fence = function (...args) { // console.log({ html: render(...args) }) const newSource = render(...args).replace('', '') return newSource } return source }, use: [ [ MarkdownItContainer, 'demo', { validate: function(params) { // console.log({ params, bool: params.trim().match(/^demo\\s+(.*)$/) }) return params.trim().match(/^demo\\s+(.*)$/); }, render: function (tokens, idx) { var m = tokens[idx].info.trim().match(/^demo\\s+(.*)$/); console.log({ con: tokens[idx], m }) if (tokens[idx].nesting === 1) { // opening tag return '' + m[1] + '\\n'; } else { // closing tag return '\\n'; } } } ] ] }) } } 路由配置: 把 md 文件当做 vue 文件即可 import { createRouter, createWebHistory } from 'vue-router'; console.log({ createRouter, createWebHistory }) const router = createRouter({ history: createWebHistory('/'), routes: [{ path: '/test', name: 'test', component: () => import(/* webpackChunkName: \"index\" */ '../components/index.md'), }] }); // 路由守护 export default router; markdown 文档解析的本质 与 babel 解析 JavaScript 类似，不同的地方是：babel 是先将 JavaScript 转化为 ast，处理完后还要转化为 JavaScript 代码，而 markdown-it 是直接将 md 文件转成 html 文件，例如：# test 转换成 test。所以没必要用 ast，而是更加简单的 Tokens，本质是一个数组。 markdown-it：https://markdown-it.github.io/ 主要流程：markdown -> Tokens -> html Parse：将 Markdown 文件 Parse 为 Tokens Render：遍历 Tokens 生成 HTML vue-markdown-loader options 说明： preprocess: 预处理函数，主要目的是为转换后的 html 标签添加各种属性: class 参数 MarkdownIt, MarkdownIt.renderer.rules 可以访问将 Tokens 生成 HTML 的 Render 函数。可以通过直接改写 MarkdownIt.renderer.rules 函数，或者执行 MarkdownIt.renderer.rules 函数得到结果后再进行处理。 参数 source, 源码 use: 使用各种自定义的插件，目的是新增 html 标签, 比如用自定义的组件包裹代码来实现显示隐藏的功能。 markdown-it-container 可以将 md 文件中的 ::: spoiler click me\\n*content*\\n:::替换成你想要的任何内容。 npm 地址：https://www.npmjs.com/package/markdown-it-container 参数: validate - optional, function to validate tail after opening marker, should return true on success. 参数: render - optional, renderer function for opening/closing tokens. 参数: marker - optional (:), character to use in delimiter. Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/experience/memoryAnalysis/":{"url":"pages/experience/memoryAnalysis/","title":"memoryAnalysis","keywords":"","body":"谷歌浏览器内存分析 - Memory Profiles Profile type heap snapshot 是一个静态分析工具，用于查看JavaScript堆中所有对象的内存使用情况。通过在JavaScript代码执行期间捕获堆快照，可以了解哪些对象正在使用大量内存以及它们的引用情况。堆快照可以提供一些基本的内存统计信息，例如对象数量、总内存使用量、内存泄漏情况等 分析面板 Summary：显示JavaScript堆内存使用情况的概览信息，包括内存占用总量、对象数量、构造函数调用次数等。它还提供了两个视图：构造函数视图和类视图，用于查看构造函数和类之间的关系。 \"Constructor\"（构造函数）指的是对象在内存中的构造函数。 \"Distance\"（距离）表示对象与选定的根对象之间的距离。 \"Shallow Size\"（浅层大小）指的是对象本身在内存中占用的空间大小。 \"Retained Size\"（保留大小）表示如果对象被从内存中删除，与之相关的其他对象也需要一起删除的空间大小。 Comparison：比较两个堆快照之间的内存使用情况，显示新创建的、删除的和变化的对象数量。它还提供了两个视图：Diff视图和Allocation View视图，用于查看堆快照之间的差异。 \"Constructor\"（构造函数）指的是对象在内存中的构造函数。 \"New\"：表示在当前 Heap Profiler Snapshot 中新创建的对象数量。 \"Deleted\"：表示在当前 Heap Profiler Snapshot 中被删除的对象数量。 \"Delta\"：表示从上一个 Heap Profiler Snapshot 到当前 Heap Profiler Snapshot 之间，增加或减少的对象数量。 \"Alloc. Size\"（分配大小）指的是当前内存池中已经分配的内存的大小，即已分配但尚未使用的内存大小。 \"Free Size\"（空闲大小）指的是当前内存池中可用的空闲内存的大小。 \"Size Delta\"（大小差异）表示自上一个 Heap Profiler Snapshot 到当前 Heap Profiler Snapshot 之间，内存使用情况增加或减少的大小。 Containment：查看一个对象的引用关系和被引用关系，包括直接引用和间接引用。它可以帮助定位内存泄漏和循环引用等问题。 Object：代表在 Heap Profiler 中分析到的 JavaScript 对象。 Distance：代表对象与根节点之间的最短路径长度，即从根节点开始依次访问每一个包含当前对象的父节点，经过的边数即为 Distance。 Shallow Size：代表对象本身所占的字节数，不包括对象引用的其他对象的大小。 Retained Size：代表一个对象及其子对象在 Heap 中总共占用的内存大小，即对象及其所有子对象被引用的内存总和，同时还考虑了循环引用的情况。 Statistics：提供一些常用的统计信息，包括JavaScript对象类型、构造函数调用次数、对象占用的内存大小等。它可以帮助了解应用程序的内存使用情况。 Allocation instrumentation on timeline 是一个动态分析工具，它可以记录JavaScript代码执行期间的内存分配情况，并将其显示在时间轴上。使用这个工具可以帮助你了解JavaScript代码在何时和何处分配了大量的内存，从而定位内存问题并进行优化。在Chrome DevTools中开启Allocation Instrumentation on Timeline后，可以在Memory面板上查看详细的内存使用情况和分配情况，并进行比较和分析。 分析面板: 类似于 heap snapshot 的 Summary Allocation sampling 它采用了采样的方式，定期对JavaScript对象进行采样，记录下每个采样时刻的堆内存使用情况，从而分析出内存泄漏和对象过多的情况。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/":{"url":"pages/css/","title":"CSS","keywords":"","body":"1. 修改默认滚动条样式 .tab-service ::-webkit-scrollbar{ width: 0; height: 0; color: transparent; } 2. position: fixed占位 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/UE/":{"url":"pages/css/UE/","title":"提升用户体验细节","keywords":"","body":"如何提升用户体验？ 1.移动端添加选中激活样式 .xxx:active { background-color: #ECECEC; } 2. 通过伪类加大可点击区域 #btn::before { content: \"\"; position: absolute; top: -20px; right: -20px; bottom: -20px; left: -20px; } 3. 平滑滚动 .scroll-view{ sroll-behavior: smooth } 4. 选择所有文本 .test { user-select: all } 5. PC 端显示鼠标指针，让用户感知这个地方是可以点击的 .box { cursor: pointer } 6. 超出省略号显示 .text { overflow: hidden; // 超出的文本隐藏 text-overflow: ellipsis; // 溢出用省略号显示 white-space: nowrap; // 溢出不换行 word-break: break-all; } 7. 图片自适应 img { width: 128px; height: 128px; object-fit: cover; } 8. 无图片展示 img.error { display: inline-block; transform: scale(1); content: ''; color: transparent; } img.error::before { content: ''; position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: #f5f5f5 url('https://cdn-images-1.medium.com/max/1600/1*we8wfyztsdo12e2Cww6oVA.jpeg') no-repeat center / 100% 100%; } 9. 通过阴影来弱化背景 .wrap{ margin: 0 auto; width: 200px; height: 100px; box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .8); } 10. 页面自适应 html { font-size: 16px; } @media screen and (min-width: 375px) { html { /* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */ font-size: calc(100% + 2 * (100vw - 375px) / 39); font-size: calc(16px + 2 * (100vw - 375px) / 39); } } @media screen and (min-width: 414px) { html { /* 414px-1000px每100像素宽字体增加1px(18px-22px) */ font-size: calc(112.5% + 4 * (100vw - 414px) / 586); font-size: calc(18px + 4 * (100vw - 414px) / 586); } } @media screen and (min-width: 600px) { html { /* 600px-1000px每100像素宽字体增加1px(20px-24px) */ font-size: calc(125% + 4 * (100vw - 600px) / 400); font-size: calc(20px + 4 * (100vw - 600px) / 400); } } @media screen and (min-width: 1000px) { html { /* 1000px往后是每100像素0.5px增加 */ font-size: calc(137.5% + 6 * (100vw - 1000px) / 1000); font-size: calc(22px + 6 * (100vw - 1000px) / 1000); } } /* 也可以分开写成多个 css 文件 */ @import \"../../assets/styles/modules/operate/screenloadverticle\" screen and (orientation:portrait); @import \"../../assets/styles/modules/operate/screenloadhorizontal\" screen and (orientation:landscape); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/flex/":{"url":"pages/css/flex/","title":"flex最后一行左对齐问题","keywords":"","body":"flex布局单行多个元素最后一行左对齐问题 业务开发过程中，经常会碰到单行多个元素的布局，并且元素个数不确定。 碰到这种情况，我们会使用 float 布局，或者 justify-content: flex-start 布局，中间间距无法自动分配。 解决方案 单行3个元素原理说明 当最后一行有一个元素的时候，本身就是对齐的。 当最后一行有两个元素的时候，加上新添加的带宽度的隐形占位元素，正好凑足3各元素，完美对齐。 当最后一行有三个元素的时候，由于新添加的隐形占位元素没有高度，不影响原来的布局。 单行4个元素，只需要添加两个隐形占位元素即可，只是不能使用伪类了，原理相同。 单行3个元素 1 2 3 4 5 6 7 8 --> 9 10 --> /* 单行3个元素 */ .box { display: flex; justify-content: space-between; flex-wrap: wrap; } .box:after { content: ''; width: 30%; } .item { width: 24%; height: 50px; line-height: 50px; text-align: center; background: red; margin-top: 10px; } 单行4个元素 1 2 3 4 5 6 7 8 --> 9 10 --> /* 单行4个元素 */ .box { display: flex; justify-content: space-between; flex-wrap: wrap; } .item { width: 24%; height: 50px; line-height: 50px; text-align: center; background: red; margin-top: 10px; } .add { width: 24%; } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/fixed/":{"url":"pages/css/fixed/","title":"神奇的固定定位","keywords":"","body":"position: fixed占位 父元素指定高度，子元素不指定top值，整块保持原位置不变，后续元素文档流布局，可避免繁琐的页面高度计算问题。 应用场景 顶部输入框元素固定（下面有个动态展示的指示栏），中间下拉列表内容，底部按钮元素固定 实际项目例子 // html代码 // css代码 .car-list { overflow-x: hidden; &__search-box { width: 100%; height: 120rpx; } &__search-input { position: fixed; z-index: 1; left: 0; width: 100%; } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/layout/":{"url":"pages/css/layout/","title":"布局与居中","keywords":"","body":"三栏布局的方案 浮动 绝对定位 flex布局 百分比布局 calc 布局 网格布局（grid布局） Document * { margin: 0px; padding: 0px; } .left { background-color: aqua; } .main { background-color: brown; } .right { background-color: aquamarine; } .container { display: grid; grid-template-columns: 100px auto 200px; grid-template-rows: 700px; } Left Main Right table布局 Document * { margin: 0px; padding: 0px; height: 700px; } .left { width: 100px; background-color: aqua; display: table-cell; } .main { background-color: brown; display: table-cell; } .right { width: 200px; background-color: aquamarine; display: table-cell; } .container { display: table; width: 100%; } Left Main Right 垂直居中的方法 方案一：verticle-align: middle; .child { display: inline-block; /* verticle-align 前提 */ verticle-align: middle; } 方案二：line-height 与 height 相等; .child { height：100px; line-height: 100px; } 方案三：display:flex； .parent { display: flex; align-items: center; } 方案四：transform: translateY(-50%); .parent { position: relative; } .child { display: absolute; top: 50%; transform: translateY(-50%); } 方案五：display: table-cell; .parent { display: table; } .child { display: table-cell; } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/pollution/":{"url":"pages/css/pollution/","title":"样式污染","keywords":"","body":"如何防止css命名污染 vue scoped 强规范命名空间 + BEM css module css in js 最佳方案 规范命名空间 + BEM 顶级class名：module + page Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/img/":{"url":"pages/css/img/","title":"图片尺寸","keywords":"","body":"缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来，对长边进行居中截取 1. 微信小程序(mode) 2. 非小程序(object-fit) // html // css img { width: 100%; height: calc(100vw * 32 / 67 ); object-fit: cover; } 3. 自定义(clip-path) // html // css width: 670rpx; height: 320rpx; clip-path: polygon(0 91rpx, 670rpx 91rpx, 670rpx 411rpx, 0 411rpx); margin-top: -91.5rpx; 缩放模式，保持纵横比缩放图片，允许长边留白毛玻璃效果（filter: blur(10px)） width: 411rpx; height: 294rpx; filter: blur(10px); transform: scale(1.2); overflow: hidden; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/ipxFit/":{"url":"pages/css/ipxFit/","title":"ipx适配","keywords":"","body":"iPhoneX 适配问题（微信小程序） 问题描述 通过 wx.getSystemInfoSync().model 判断机型，设置全局变量 isIpX, 然后页面通过获取全局变量 isIpX 区分样式。 随着苹果手机新机型的发布，我们需要不断添加新机型判断，由于目前拍卖小程序还没有添加 iPhone 11和12 机型，所有适配效果在这些手机上失效。 const res = wx.getSystemInfoSync() const model = res.model if (model.includes('iPhone X') || model.includes('iPhone 11 Pro') || model === 'unknown') { this.globalData.isIpX = true } env(safe-area-inset-bottom) 问题 env(safe-area-inset-bottom) 默认边距太大，无法与设计保持一致，不美观。 padding-bottom: env(safe-area-inset-bottom); 第一次尝试 失败：iPhoneX 手机 ❌ 普通手机 ✅ 普通手机上面，env(safe-area-inset-bottom， -30rpx) 无效 MDN文档地址 .entrust-entry { padding-bottom: 10rpx; margin-bottom: env(safe-area-inset-bottom， -30rpx); } 第二次尝试 失败：iPhoneX 手机 ✅ 普通手机 ❌ 普通手机上面，calc(env(safe-area-inset-bottom) - 30rpx) 为 -30rpx .entrust-entry { padding-bottom: 10rpx; margin-bottom: calc(env(safe-area-inset-bottom) - 30rpx); } 第三次尝试 失败：iPhoneX 手机 ❌ 普通手机 ✅ when (env(safe-area-inset-bottom) > 0) 判断失效 .inset () when (env(safe-area-inset-bottom) > 0){ margin-bottom: calc(env(safe-area-inset-bottom) - 30rpx); } .entrust-entry { padding-bottom: 10rpx; .inset() } 第四次尝试 失败：iPhoneX 手机 ❌ 普通手机 ✅ @supports (margin-bottom: env(safe-area-inset-bottom)) 判断失效 .entrust-entry { padding-bottom: 10rpx; @supports (margin-bottom: env(safe-area-inset-bottom)) { margin-bottom: calc(env(safe-area-inset-bottom) - 30rpx); } } 最佳解决方案（新项目） 成功：iPhoneX 手机 ✅ 普通手机 ✅ 关键点： padding 不能为负数 .entrust-entry { margin-bottom: 10rpx; padding-bottom: calc(env(safe-area-inset-bottom) - 30rpx); } 改动最少修改方案（旧项目） 成功：iPhoneX 手机 ✅ 普通手机 ✅ 关键点： 通过 res.screenHeight > res.safeArea.bottom 判断需要适配的机型，不用添加新机型 const res = wx.getSystemInfoSync() const model = res.model if (res.screenHeight > res.safeArea.bottom || model === 'unknown') { this.globalData.isIpX = true } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/radio/":{"url":"pages/css/radio/","title":"radio样式","keywords":"","body":"微信小程序 radio 样式 radio 样式使用了两张图片 点击文字无法切换状态 {{i18N.readAndAgree}}{{i18N.fixedPriceProtocol}} 纯 css 样式 ✅ {{i18N.readAndAgree}}{{i18N.fixedPriceProtocol}} .quote-enter{ &__radio { color: #666666; .wx-radio-input { height: 25rpx; width: 25rpx; border: none; // background: #d2d2d2; border: 2rpx solid #d2d2d2; } .wx-radio-input.wx-radio-input-checked { border: 2rpx solid #ffdf7f; } .wx-radio-input.wx-radio-input-checked::before { border-radius: 50%; /* 圆角 */ width: 25rpx; /* 选中后对勾大小，不要超过背景的尺寸 */ height: 25rpx; /* 选中后对勾大小，不要超过背景的尺寸 */ line-height: 25rpx; text-align: center; font-size: 20rpx; /* 对勾大小 30rpx */ color: #fff; /* 对勾颜色 白色 */ background: #ffdf7f; border: 2rpx solid #ffdf7f; transform: translate(-50%, -50%) scale(1); -webkit-transform: translate(-50%, -50%) scale(1); } } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/BFC/":{"url":"pages/css/BFC/","title":"BFC","keywords":"","body":"BFC (Block Formatting Context) 定义 块级格式化上下文：它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Box: CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。 Box 类型： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: css3 Formatting Context: 它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 BFC 的布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 如何创建BFC 1.float的值不是none。 2.position的值不是static或者relative。 3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex 4.overflow的值不是visible BFC 的作用 1.利用BFC避免margin重叠。 2.自适应两栏布局 3.清楚浮动。 BFC 总结 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/css/REM/":{"url":"pages/css/REM/","title":"REM","keywords":"","body":"REM 应用 rem 的定义 这个单位代表根元素的 font-size 大小。当用在根元素的 font-size 上面时，它代表了它的初始值。- MDN 移动端 rem 原理 使用 rem 单位适配的本质就是把 rem 单位当做一个百分比单位，进行元素的等比缩放。 手机的屏幕宽度是 320px，设计稿的宽度是 750px，假设设计稿的跟字体大小是：100px。 320 / 750 = x / 100 => document.documentElement.style.fontSize = 100 * 320 / 750 这样，手机的屏幕宽度就是：7.5rem。 pc 端也能使用 rem !function(window){ // 基准大小 const baseSize = 100 // 设置 rem 函数 function setRem () { // 当前页面宽度相对于 1920 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 1920 // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整） document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + 'px' } // 初始化 setRem() // 改变窗口大小时重新设置 rem window.onresize = function () { setRem() } }(window); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/":{"url":"pages/js/","title":"JavaScript","keywords":"","body":"主要内容 js基础知识 作用域模型 词法作用域和动态作用域 闭包 原型范式与原型链 this指向 内存泄漏与垃圾回收机制 事件循环机制 ✅ 防抖与节流 ✅ call/apply/bind ✅ es6主要内容 let/const ✅ 解构 ✅ 箭头函数 ✅ class ✅ promise ✅ set/map proxy 🔥 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/performance/":{"url":"pages/js/performance/","title":"性能优化细节","keywords":"","body":"如何提升性能？ 1.数据处理优先：先过滤数据，避免渲染的时候使用条件判断 这样处理数据可以规避 v-for 与 v-if 同时出现的尴尬场景 a.渲染的时候使用条件判断 ❎ 零售微店 我要分享 {{ item.value }} {{ item.name }} b.过滤数据 ✅ methods: { async fetchMicroShopManage() { const {code, data} = await this.$rest.microShop.fetchMicroShopManage() if (code === 0) { this.retailInfo = data.map(item => item.value !== null) } } } 2.iconfont 制作 svg 转 iconfont, 生成字体文件的同时，生成 less 文件，方便组件使用 手动制作地址：https://icomoon.io/app/#/select 防止错乱：导入原项目的 svg 文件后，先生成 font，再添加新的 svg 图标。 gulpfile.js 文件 const gulp = require('gulp') const iconfont = require('gulp-iconfont') const iconfontCss = require('gulp-iconfont-css') const fontIconVersion = require('./package.json').fontIconVersion const generateIconfont = () => { return gulp .src(['./svg-icon/**/*.svg']) .pipe(iconfontCss({ fontName: 'lxSvgFont.' + fontIconVersion, cssClass: 'lx-icon', path: './svg-icon/template.less', targetPath: '../fonticon/icon.less' })) .pipe(iconfont({ fontName: 'lxSvgFont.' + fontIconVersion, prependUnicode: true, formats: ['ttf', 'eot', 'woff'], timestamp: Math.round(Date.now() / 1000) })) .pipe(gulp.dest('./lx-svg-font/')) } exports.default = generateIconfont 组件 export default { props: { iconName: { type: String, default: '' }, xClass: { type: String, default: '' } }, data() { return { iconLoaded: true } }, onLoad () { }, methods: { handleOnClick () { this.$emit('handleOnClick') } } } @font-face { font-family: \"lxSvgFont\"; src: url('@cdnUrl/static/lx-svg-font/@fontIconName.woff'); } @import url('./icon.less'); 3.css3 动画和 js 动画性能对比 css3 动画 CSS 动画运行在 GPU。 CSS3 动画也被称为补间动画，原因是只需要添加关键帧的位置，其他的未定义的帧会被自动生成。 浏览器可以对动画进行优化，帧速不好的浏览器，CSS3 可以自然降级兼容。 只设置了几个关键帧的位置，不能再半路暂停动画。 js 动画 JS 动画运行在 CPU。 JS 动画是逐帧动画，在时间帧上绘制内容，一帧一帧的，所以他的可再造性很高，几乎可以完成任何你想要的动画形式。 逐帧动画的内容不一样，会增加制作的负担，占用比较大的资源空间。 细腻的动画，可控性高。 结论：只要能用 CSS 实现的动画，就不要采用 JS 去实现。 4.前端性能分析 思路：根据具体指标分析，解决前20%的问题，提升80%的性能。 lighthouse 前端性能指标 ⽩屏时间 FP(First Paint): 指的是当我输⼊URL开始，到⻚⾯开始有变化，只要有任意像素点变化，都算是⽩屏时间的完结。 ⾸次内容绘制 FCP(First Contentful Paint): 指的是⻚⾯上绘制了第⼀个元素。 ⾸次有效绘制 FMP: 指的是⻚⾯中有效内容绘制。 最⼤内容绘制 LCP(Largest Contentful Paint): ⽤于记录视窗内最⼤的元素绘制的时间，该时间会随着⻚⾯渲染变化⽽变化，因为⻚⾯中的最⼤元素在渲染过程中可能会发⽣改变，另外该指标会在⽤户第⼀次交互后停⽌记录。 ⾸次可交互时间 TTI(Time to Interactive) 从 FCP 指标后开始计算 持续 5 秒内⽆⻓任务（执⾏时间超过 50 ms）且⽆两个以上正在进⾏中的 GET 请求 往前回溯⾄ 5 秒前的最后⼀个⻓任务结束的时间 前端框架检测工具 web-vitals ：是⼀个前端框架，他可以不需要你书写上⾯代码只需要轻松的引⽤即可, https://www.npmjs.com/package/web-vitals。 缺点是：⽬前只能统计 'CLS' | 'FCP' | 'FID' | 'LCP' | 'TTFB' 在⾕歌的标准中，⼀般我们只需要关⼼以上⼏个，分别是LCP, FID, CLS; 影响性能的因素 影响⽩屏的时间 ⽹速问题 JS包⼤⼩问题 是否启⽤了JS异步加载 解决⽅案 提⾼带宽 需要使⽤webpack进⾏tree-shaking 使⽤路由懒加载，只有在使⽤的时候在进⾏路由加载 尽量使⽤CDN进⾏加速 建⽴缓存，提⾼下次加载速度 开启gzip压缩 chrome 浏览器 Network 面板请求 Timing 分析 Queueing 请求文件顺序的排序。浏览器是有线程限制的，发请求也不能所有的请求同时发送，会将请求加入队列中（Chrome的最大并发连接数是6）。此参数表示从添加到待处理队列，到实际开始处理的时间间隔标示。 Stalled（阻塞) 浏览器得到要发出这个请求的指令，到请求可以发出的等待时间，一般是代理协商、以及等待可复用的TCP连接释放的时间，不包括DNS查询、建立TCP连接等时间等。浏览器对同一个主机域名的并发连接数有限制，因此如果当前的连接数已经超过上限，那么其余请求就会被阻塞，等待新的可用连接；此外脚本也会阻塞其他组件的下载； 优化措施： 1、将资源合理分布到多台主机上，可以提高并发数，但是增加并行下载数量也会增大开销，这取决于带宽和CPU速度，过多的并行下载会降低性能； 2、脚本置于页面底部； DNS Lookup 请求某域名下的资源，浏览器需要先通过DNS解析器得到该域名服务器的IP地址。在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西。DNS查询的时间，当本地DNS缓存没有的时候，这个时间可能是有一段长度的，但是比如你一旦在host中设置了DNS，或者第二次访问，由于浏览器的DNS缓存还在，这个时间就为0了。 优化措施： 1、利用DNS缓存（设置TTL时间）； 2、利用Connection:keep-alive特性建立持久连接，可以在当前连接上进行多个请求，无需再进行域名解析； Initial connection 建立TCP连接的时间，就相当于客户端从发请求开始到TCP握手结束这一段，包括DNS查询+Proxy时间+TCP握手时间。 SSL http是超文本传输协议，以明文方式发送内容，不提供任何方式的数据加密，如果被不法分子截取浏览器和服务器之间的传输报文，会获取其中的信息。 https 是安全套接字层超文本传输协议，就是在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。因此建立HTTPS连接的时间相当于三次握手的时间+SSL时间。 Request sent 发送HTTP请求的时间（从第一个字节发出前到最后一个字节发出后的时间 优化措施： 1、减少HTTP请求，可以使用CSS Sprites、内联图片、合并脚本和样式表等； 2、对不常变化的组件添加长久的Expires头（相当于设置久远的过期时间），在后续的页面浏览中可以避免不必要的HTTP请求； Waiting for server response 请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte)，发送请求完毕到接收请求开始的时间；通常是耗费时间最长的。从发送请求到收到服务器响应的第一字节之间的时间，受到线路、服务器距离等因素的影响。注意：网页重定向越多，TTFB越高，所以要减少重定向。 优化措施: 使用CDN，将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求，提高响应速度；能使用第三方的 CDN 资源直接使用，不能使用的可以通过 webpack 的 dllPlugin 和 dllReferencePlugin 生成动态链接库，然后手动放到 CDN 上面。 Content Download 收到响应的第一个字节，到接受完最后一个字节的时间，就是下载时间。 优化措施： 1、通过条件Get请求，对比If-Modified-Since和Last-Modified时间，确定是否使用缓存中的组件，服务器会返回“304 Not Modified”状态码，减小响应的大小； 2、移除重复脚本，精简和压缩代码，如借助自动化构建工具grunt、gulp等； 3、压缩响应内容，服务器端启用gzip压缩，可以减少下载时间； 4、使用 webpack splitChunks 抽离公共代码减少主包体积 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/promise/":{"url":"pages/js/promise/","title":"Promise","keywords":"","body":"promise的由来 js异步问题发展历程： 函数回调 promise generator async/await Promise的理解 Promise 对象是一个代理对象。它接受你传入的 executor（执行器）作为入参，允许你把异步任务的成功和失败分别绑定到对应的处理方法上去。一个 Promise 实例有三种状态： pending 状态，表示进行中。这是 Promise 实例创建后的一个初始态； fulfilled 状态，表示成功完成。这是我们在执行器中调用 resolve 后，达成的状态； rejected 状态，表示操作失败、被拒绝。这是我们在执行器中调用 reject后，达成的状态 Promise 常见方法 Promise.all(iterable) 参数是一个 promise 的 iterable 类型，如果参数中的元素不是 promise 对象，则需要通过 Promise.resolve 转换成 promise 对象。 返回的结果是个数组，且数组内数据要与传参数据对应。 只要一个报错，立马调用 reject 返回错误信息。 参数调用 then 方法得到需要返回的结果：item.then(res => ...) const PromiseAll = (iterator) => { const promises = Array.from(iterator) const data = [] let i = 0 return new Promise((resolve, reject) => { for (let [index, item] of promises.entries()) { Promise.resolve(item).then(res => { data[index] = res i ++ if (i === promises.length) resolve(data) }).catch(err => reject(err)) } }) } const promise1 = Promise.resolve('promise1'); const promise2 = new Promise(function (resolve, reject) { setTimeout(resolve, 2000, 'promise2'); }); const promise3 = new Promise(function (resolve, reject) { setTimeout(resolve, 3000, 'promise3'); }); PromiseAll([11, promise1, promise2, promise3]).then(function(values) { console.log(values); }); Promise.race(iterable) const PromiseRace = (iterator) => { const promises = Array.from(iterator) return new Promise((resolve, reject) => { for (let item of promises) { Promise.resolve(item).then(res => { resolve(res) }).catch(err => reject(err)) } }) } const promise1 = Promise.resolve('promise1'); const promise2 = new Promise(function (resolve, reject) { setTimeout(resolve, 2000, 'promise2'); }); const promise3 = new Promise(function (resolve, reject) { setTimeout(resolve, 3000, 'promise3'); }); PromiseRace([promise2, promise3]).then(function(values) { console.log(values); }); Promise.allSettled(iterable) const PromiseSettled = () => { } Promise.any(iterable) const PromiseAny = () => { } Promise.reject(reason) Promise.then(result => {···}).catch(error => {···}) Promise.resolve().resolve(value) Promise.then(result => {···}).catch(error => {···}).finally(() => {···}) Promise.race 实现并发控制 const urls = [ { info: 'img-1', time: 1000 }, { info: 'img-2', time: 2000 }, { info: 'img-3', time: 4000 }, { info: 'img-4', time: 5000 }, { info: 'img-5', time: 4000 }, { info: 'img-6', time: 3000 }, { info: 'img-7', time: 2000 }, { info: 'img-8', time: 3000 }, { info: 'img-9', time: 2000 }, { info: 'img-10', time: 4000 }, { info: 'img-11', time: 2000 }, { info: 'img-12', time: 3000 }, ] const limitLoad = (urls, handler, limit) => { const sequence = [].concat(urls) let promises = [] promises = sequence.splice(0, limit).map((url, index) => handler(url).then(() => index)) let p = Promise.race(promises) for (let i = 0; i { promises[res] = handler(sequence[i]).then(() => res) return Promise.race(promises) }).then() } } const loadImg = url => { return new Promise((resolve) => { console.log(`${url.info} start`) setTimeout(() => { console.log(`${url.info} end`) resolve() }, url.time) }) } limitLoad(urls, loadImg, 3) var urls = [ 'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg', 'https://www.kkkk1000.com/images/getImgData/gray.gif', 'https://www.kkkk1000.com/images/getImgData/Particle.gif', 'https://www.kkkk1000.com/images/getImgData/arithmetic.png', 'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif', 'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg', 'https://www.kkkk1000.com/images/getImgData/arithmetic.gif', 'https://www.kkkk1000.com/images/wxQrCode2.png' ]; function loadImg(url) { return new Promise((resolve, reject) => { const img = new Image() img.onload = function () { console.log('一张图片加载完成:', url); resolve(); } img.onerror = reject console.log('一张图片开始加载:', url); img.src = url }) }; function limitLoad(urls, handler, limit) { // 对数组做一个拷贝 const sequence = [].concat(urls) let promises = []; //并发请求到最大数 promises = sequence.splice(0, limit).map((url, index) => { // 这里返回的 index 是任务在 promises 的脚标， //用于在 Promise.race 之后找到完成的任务脚标 return handler(url).then(() => { return index }); }); (async function loop() { let p = Promise.race(promises); for (let i = 0; i { promises[res] = handler(sequence[i]).then(() => { return res }); return Promise.race(promises) }) } })() } limitLoad(urls, loadImg, 3) promisify const promisify = (fn) => { return function(...args) { return new Promise((resolve, reject) => { fn(...args, (err, data) => { if(err) { reject(err); return; } resolve(data); }) }) } } 实际项目：登录流程改造 获取微信 code 请求登录拿到登录态 切换⻔店完成登录 promise链式调用 1. 获取微信 code /** * 获取微信 code （企业微信平台） * */ function getWxworkCode() { return new Promise((resolve, reject) => { wx.qy.login({ success(res) { if (res.code) { resolve(res.code) } else { // 标准化返回 err reject({ message: '获取微信 code 失败' }) } }, fail() { // 标准化返回 err reject({ message: '获取微信 code 失败' }) } }) }) } 2. 请求登录(未使用async await) /** * 登录（企业微信平台） * @param {string} code 企业微信code */ function login(code) { return rest.auth.loginWithWxwork(code).then((res) => { const { code, data } = res // success：缓存 token，返回⻔店 id if ([0, 101].includes(code)) { commit('UPDATE_ACCESS_TOKEN', data['access-token']) return data.store_config.stores_config[0].store_id } // fail throw res }) } 3. 切换⻔店(未使用async await) /** * 切换⻔店 * @param {number} storeId ⻔店id * @param {number} storeId ⻔店id */ function selectStore(storeId) { return rest.auth.selectStore(storeId).then((res) => { const { code, data } = res // success：更新 token，维护⽤户状态 if (code === 0) { commit('UPDATE_ACCESS_TOKEN', data['access-token']) commit('UPDATE_COMMON_DATA', { userInfo: data.current_user_info, groupInfo: data.store_config.group_config, storeList: data.store_config.stores_config, storeInfo: data.store_config.store_config }) return true } // fail throw res }) } 4. 对外授权接⼝（企业微信） /** * 登录授权 * / export function auth() { wx.showLoading({ title: '加载中', mask: true }) return getWxworkCode() .then((code) => login(code)) .then((storeId) => selectStore(storeId)) .catch((err) => { /** * err 标准化 * { message: '' } */ wx.showModal({ title: '登录失败', confirmColor: '#1890FF', content: `${err.message || '⽹络异常'}，您可点击确定重新登录`, mask: true, showCancel: false, success: (res) => { if (res.confirm) { resolve(auth()) } } }) }) .finally(wx.hideLoading) }) } 5. 对外授权接口（async await） /** * 登录授权 */ export async function auth() { try { wx.showLoading({ title: '加载中', mask: true }) const code = await getWxworkCode() const storeId = await login(code) await selectStore(storeId) wx.hideLoading() } catch (e) { wx.hideLoading() return new Promise((resolve) => { wx.showModal({ title: '登录失败', confirmColor: '#1890FF', content: `${err.message || '⽹络异常'}，您可点击确定重新登录`, mask: true, showCancel: false, success: (res) => { if (res.confirm) { resolve(auth()) } } }) }) } } 异常处理： 标准化返回 promise 异常信息 若调⽤处需要得到 promise 结果状态，则 promise 内部应该往外抛出异常 若调⽤处⽆需得到 promise 结果状态，则 promise 内部⾃⾏处理异常，⽆需往 外抛出异常 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/proto/":{"url":"pages/js/proto/","title":"原型及原型链","keywords":"","body":"原型及原型链 几个概念 构造函数: 用 new 关键字来调用的函数 实例：构造函数用 new 关键字实例化的结果 new 关键字干了啥？(const whitePlayer = new Player()) 一个继承自 Player.prototype 的新对象 whitePlayer 被创建 whitePlayer.__proto__ 指向 Player.prototype，即 whitePlayer.__proto__ = Player.prototype 将 this 指向新创建的对象 whitePlayer 返回新对象 4.1 如果构造函数没有显式返回值，则返回 this 4.2 如果构造函数有显式返回值，是基本类型，比如 number,string,boolean, 那么还是返回 this 4.3 如果构造函数有显式返回值，是对象类型，比如{ a: 1 }, 则返回这个对象{ a: 1 } 原型链的理解 实例的 __proto__ 指向构造函数的 prototype es5 继承 function Rectangle(height, width) { this.name = 'Rectangle'; this.height = height; this.width = width; this.getName = function() { console.log('name:', this.name); } this.getArea = function() { console.log('area:', this.width * this.height); } } function FilledRectangle(height, width, color){ Rectangle.call(this, height, width,); this.color = color; this.name = 'Filled rectangle'; this.getColor = function() { console.log('color:', this.color); } } function Mid(){}; Mid.prototype = Rectangle.prototype; FilledRectangle.prototype = new Mid(); const rect = new Rectangle(10, 20) const FR = new FilledRectangle(10, 20, 'red') rect.getName() rect.getArea() FR.getName() FR.getArea() FR.getColor() es6 class class Rectangle { constructor(height, width) { this.name = 'Rectangle'; this.height = height; this.width = width; } getName() { console.log('name:', this.name); } getArea() { console.log('area:', this.width * this.height); } } class FilledRectangle extends Rectangle { constructor(height, width, color) { super(height, width); this.name = 'Filled rectangle'; this.color = color; } getColor() { console.log('color:', this.color); } } const rect = new Rectangle(10, 20) const FR = new FilledRectangle(10, 20, 'red') rect.getName() rect.getArea() FR.getName() FR.getArea() FR.getColor() 原型链的应用 const arrayProto = Array.prototype const arrayMethods = Object.create(arrayProto) const methodsToPatch = ['push', 'pop', 'unshift', 'shift', 'splice', 'sort', 'reverse'] // array数组，这7种方法是终会改变数组本身。 methodsToPatch.forEach(method => { // 通过代理，重新返回一个额新的函数 Object.defineProperty(arrayMethods, method, { value: function (...args) { // 通过apply，实现数组方法原有的功能 return arrayProto[method].apply(this, args) }, configurable: true, writable: true, enumerable: true }) }) export default function protoArguments(arr) { // 覆盖数组原有的原型对象 arr.__proto__ = arrayMethods } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/module/":{"url":"pages/js/module/","title":"模块化","keywords":"","body":"前端模块化和组件化理解 模块化主要体现的是一种分而治之的思想。分而治之是软件工程的重要思想，是复杂系统开发和维护的基石。模块化则是前端最流行的分治手段。 为什么需要模块化 我们都知道在早期 JavaScript 没有模块这一概念，都是通过script标签引入js文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的js文件就会越多，这时就会出现以下问题： js 文件作用域都是顶层，这会造成变量污染。 js 文件多，变得不好维护。 js 文件依赖问题，稍微不注意顺序引入错，代码全报错。 前端模块化历史和方案 函数封装 对象封装 闭包，立即执行函数 AMD(Asynchronous Module Definition) CMD(Common Module Definition) ES6 import export/export default 函数封装 造成全局变量污染 对象封装 造成全局变量污染 闭包，立即执行函数 下面是好多年前封装的一个模块 /** * 占用全局变量 Semiauto（半自动）和 Auto（自动轮播） * 启动函数.exec() */ (function (win) { function Semiauto($ul, $li, $tab) { this.$ul = $ul; this.$tab = $tab; this.width = $li.width(); this.index = 0; } Semiauto.prototype = { exec: function () { this.addEvent(); }, addEvent: function () { var This = this; this.$tab.mouseenter(function () { This.index = This.$tab.index($(this)); $(this).addClass(\"on\").siblings().removeClass(\"on\"); This.$ul.finish().animate({ left: -This.width * This.index }, 500) }) } }; //inhert and extend function Auto($ul, $li, $tab, $box) { Semiauto.call(this, $ul, $li, $tab); this.$box = $box; this.timer = null; this.len = $li.length; } //prototype inhert function Fn() { }; Fn.prototype = Semiauto.prototype; Auto.prototype = new Fn(); //extend Auto.prototype.doit = Auto.prototype.exec; Auto.prototype.exec = function () { this.doit(); this.autoplay(); this.clear(); } Auto.prototype.autoplay = function () { var This = this; this.timer = setInterval(function () { This.index++; This.index %= This.len; This.$tab.eq(This.index).addClass(\"on\").siblings().removeClass(\"on\"); This.$ul.finish().animate({ left: -This.width * This.index }) }, 3000) } Auto.prototype.clear = function () { var This = this; this.$box.hover(function () { clearInterval(This.timer); }, function () { This.autoplay(); }); } win.Semiauto = Semiauto; win.Auto = Auto; })(window); Commonjs(node)：同步的 commonJS用同步的方式加载模块,在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。 但是在浏览器端，限于网络原因，更合理的方案是使用异步加载，这种方式在加载多个模块时，并没有平行加载。同时，浏览器也并不兼容CommonJS，原因就是浏览器缺少Nodejs的四个变量module、exports，require、global 。 要想浏览器支持，那么我们可以使用Browserify，它是目前 CommonJS 格式转换的工具。Browserify的实现原理主要是将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。 [ { \"id\":1, \"source\":\"module.exports = function(x) {\\n console.log(x);\\n};\", \"deps\":{} }, { \"id\":2, \"source\":\"var foo = require(\\\"./foo\\\");\\nfoo(\\\"Hi\\\");\", \"deps\":{\"./foo\":1}, \"entry\":true } ] //模块定义 model.js var name = 'old man'; function printName(){ console.log(name); } module.exports = { printName: printName } // 加载模块 var nameModule = require('./model.js'); nameModule.printName() AMD(Asynchronous Module Definition) Commonjs 是同步的，在浏览器并不支持，所以AMD应运而生，它支持异步的require。因为AMD并不是javascript原生支持的所以需要我们引入RequireJS这个库。 /** 网页中引入require.js及main.js **/ /** main.js 入口文件/主模块 **/ // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); // 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数； // 如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数 // 定义math.js模块 define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum }; }); // 定义一个依赖underscore.js的模块 define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify }; }) // 引用模块，将模块放在[]内 require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum); }); CMD(Common Module Definition) CMD是另一种随着sea.js发展起来的模块化方案，它与之前介绍的AMD相比不同的是二者执行的依赖的时机不同，而不是加载依赖的时机。 AMD加载依赖时依赖前置，js可以立刻加载所声明的模块。而CMD则是就近依赖需要把模板解析完一遍才可以知道依赖的事哪些方面，所以性能方面比AMD略差。 /** AMD写法 **/ define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } }); /** CMD写法 **/ define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); } }); /** sea.js **/ // 定义模块 math.js define(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add; }); // 加载模块 seajs.use(['math.js'], function(math){ var sum = math.add(1+2); }); AMD与CMD区别: AMD推崇依赖前置，提前执行: AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。 CMD推崇就近依赖，延迟执行: CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。 ES6 import export/export default 使用前提：，浏览器中ES Module是异步加载，不会堵塞浏览器，即等到整个页面渲染完，再执行模块脚本。如果网页有多个ESM，它们会按照在页面出现的顺序依次执行。 export { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } export default { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } ES Modules 工作流程： 流程简析: 创建AST -> 生成 Module Record -> 转化 Module Instance 模块加载: 构造：查找、下载并解析所有文件到模块记录中。 1、根据入口创建依赖关系的AST; 2、下载module文件，用于解析; 3、解析每个module文件，生成 Module Record（包含当前module的AST、变量等）; 4、将Module Record 映射到 Module Map中，保持每个module文件的唯一性; 实例化：在内存中寻找一块区域来存储所有导出的变量（但还没有填充值）。然后让 export 和 import 都指向这些内存块。这个过程叫做链接（linking） 1、生成模每个Module Record的块环境记录(Module Enviroment Record)，用来管理 Module Record 的变量等； 2、在内存中写入每个Module的数据，同时 Module文件的导出export和引用文件的 import指向该地址； 求值：在内存块中填入变量的实际值。 1、执行对应Module文件中顶层作用域的代码，确定实例化阶段中定义变量的值，放入内存中； Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/ES6/":{"url":"pages/js/ES6/","title":"ES6","keywords":"","body":"ES6及以后新增的常用API解析 1. let 和 const 与 var 的区别 let 和 const 引入了块级作用域，var是全局作用域 let 和 const 不存在变量提升，var会变量提升 const 声明的是常量，声明后不可更改，引用类型的数据可以修改属性值。let和var声明的变量，声明之后可以更改 const 声明的时候必须赋值, let 和 var 声明时可以不赋值 var允许重复声明变量，后一个变量会覆盖前一个变量。let 和 const 在同一作用域不允许重复声明变量，会报错。 2. 箭头函数 1. 箭头函数与普通函数的最大区别：箭头函数里的this是定义的时候决定的, 普通函数里的this是使用的时候决定的。 2. 简写箭头函数 // 单行不需要写return，单个参数可以不加括号 const square = a => a * a // 可以用（）包裹代替return const func = () => ({}) 3. 箭头函数不能被用作构造函数 构造函数会干嘛? 改变this指向到新实例出来的对象. 箭头函数会干嘛？this指向是定义的时候决定的. new 关键字干了啥？(const whitePlayer = new Player()) 一个继承自 Player.prototype 的新对象 whitePlayer 被创建 whitePlayer.__proto__ 指向 Player.prototype，即 whitePlayer.__proto__ = Player.prototype 将 this 指向新创建的对象 whitePlayer 返回新对象 4.1 如果构造函数没有显式返回值，则返回 this 4.2 如果构造函数有显式返回值，是基本类型，比如 number,string,boolean, 那么还是返回 this 4.3 如果构造函数有显式返回值，是对象类型，比如{ a: 1 }, 则返回这个对象{ a: 1 } 3. class class Test { _name = '' constructor () { this.name = 'tommy' } static getName() { return `${this.name}-mark` } get name() { return this._name } set name(name) { this._name = name } } 4. 模板字符串 1. 换行方便 console.log(`first second third`) 2. 变量拼接方便 const a = 'test' console.log(`${a}`123) 3. js函数模拟模板字符串 const year = '2021'; const month = '10'; const day = '01'; let template = '${year}-${month}-${day}'; let context = { year, month, day }; const render = tem => { return (obj) => { // ?的意思是非贪婪模式（https://regex101.com/） return tem.replace(/\\$\\{(.+?)\\}/g, (args, key) => { return context[key] }) } } const str = render(template)({year,month,day}); console.log(str) // 2021-10-01 5. 解构 1. 解构默认值和重命名 let { f1 = 'test1', f2: rename = 'test2' } = { f1: 'current1', f2: 'current2'} console.log(f1, rename) // current1, current2 2. 解构的原理 针对可迭代对象的Iterator接口，通过遍历器按顺序获取对应的值进行赋值. 3. 那么 Iterator 是什么? Iterator是一种接口，为各种不一样的数据解构提供统一的访问机制。任何数据解构只要有Iterator接口，就能通过遍历操作，依次按顺序处理数据结构内所有成员。ES6中的for of的语法相当于遍历器，会在遍历数据结构时，自动寻找Iterator接口。 4. Iterator有什么用? 为各种数据解构提供统一的访问接口 使得数据解构能按次序排列处理 可以使用ES6最新命令 for of进行遍历 function generateIterator(array) { let nextIndex = 0 return { next: () => nextIndex 5. 可迭代对象是什么? 可迭代对象是Iterator接口的实现。这是ECMAScript 2015的补充，它不是内置或语法，而仅仅是协议。任何遵循该协议点对象都能成为可迭代对象。可迭代对象得有两个协议：可迭代协议和迭代器协议。 可迭代协议：对象必须实现iterator方法。即对象或其原型链上必须有一个名叫Symbol.iterator的属性。该属性的值为无参函数，函数返回迭代器协议。 迭代器协议：定义了标准的方式来产生一个有限或无限序列值。其要求必须实现一个next()方法，该方法返回对象有done(boolean)和value属性。 6. 我们自己来实现一个可以for of遍历的对象? 通过以上可知，自定义数据结构，只要拥有Iterator接口，并将其部署到自己的Symbol.iterator属性上，就可以成为可迭代对象，能被for of循环遍历。 const obj = { count: 0, [Symbol.iterator]: () => { return { next: () => { obj.count++; if (obj.count 或者 const iterable = { 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator], }; for (const item of iterable) { console.log(item); } 6. 遍历 for in 遍历 键名, for of 遍历 键值。 for of 仅遍历当前对象, 不遍历原型链上的可枚举属性。 for of 获取键名的方法：for (let [key, value] of obj.entries()) { }。 1. for in 遍历数组时，key为数组下标字符串；遍历对象，key为对象字段名。 let obj = {a: 'test1', b: 'test2'} for (let key in obj) { console.log(key, obj[key]) } 缺点： for in 不仅会遍历当前对象，还包括原型链上的可枚举属性 for in 不适合遍历数组，主要应用为对象 2. for of 可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments对象，NodeList对象）上创建一个迭代循环,调用自定义迭代钩子，并为每个不同属性的值执行语句。 let arr = [{age: 1}, {age: 5}, {age: 100}, {age: 34}] for(let {age} of arr) { if (age > 10) { break // for of 允许中断 } console.log(age) } 优点： for of 仅遍历当前对象 7. Object 1. Object.keys 2. Object.values 3. Object.entries 4. Object.getOwnPropertyNames 5. Object.getOwnPropertyDescriptor 6. Object.create() // 创建空对象 const obj1 = {}; const obj2 = Object.create(null); const obj3 = new Object(); 7. Object.assign 8. Object.defineProperty 8. Array 1. Array.flat const arr = [1, 2, [3, 4, [5, 6]], 7] arr.flat() arr.flat(2) arr.flat(Infinity) // 数组扁平化 const newArr = [[1, 2], [3, 4], [5, 6]].reduce((prev, next, index, arr) => { console.log({prev, next}) return prev.concat(next) }, []) console.log(newArr) // reduce const flatter = (arr) => { const res = [] return arr.reduce((prev, next) => { if (Object.prototype.toString.call(next) === '[object Array]') { return prev.concat(flatter(next)) } else { return prev.concat(next) } }, []) } console.log(flatter([[1, 2], [3, 4], [5, 6]])) // forEach const flatten = (arr) => { let res = [] arr.forEach(item => { if (Object.prototype.toString.call(item) === '[object Array]') { res = [...res, ...flatter(item)] } else { res.push(item) } }) return res } console.log(flatten([1, 2, [3, 4], [5, 6]])) 2. Array.includes 3. Array.find && Array.findIndex 4. Array.from Array.from([1, 2, 3, 4], x => x * x) // 类数组转成真数组 [...arguments] Array.from(arguments) Array.prototype.slice.call(arguments) // 数组去重 Array.from(new Set(arr)) arr.filter((item, index, array) => array.indexOf(item) === index) 5. Array.of 9. Promise then()异步请求成功后 catch()异步请求错误的回调方法 finally()请求之后无论是什么状态都会执行 resolve()将现有对象转换为Promise对象 all()此方法用于将多个Promise实例包装成一个新的promise实例 race()也是将多个Promise实例包装成一个新的promise实例 reject()返回一个状态为Rejected的新Promise实例 /** * 1. Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入。 —— 说明所传参数都具有Iterable,也就是可遍历。 * 2. 并且只返回一个Promise实例。—— 说明最终返回是一个Promise对象。 * 3. 那个输入的所有promise的resolve回调的结果是一个数组。—— 说明最终返回的结果是个数组，且数组内数据要与传参数据对应。 * 4. 这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。—— 说明最终返回时，要包含所有的结果的返回。 * 5. 它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。—— 说明只要一个报错，立马调用reject返回错误信息。 */ const PromiseAll = (iterator) => { const promises = Array.from(iterator) const len = promises.length let index = 0, data = [] return new Promise((resolve, reject) => { for (let [i, item] of promises.entries()) { item.then(res => { data[i] = res index ++ console.log({ i }) if (index === len) resolve(data) }).catch(err => { reject(err) }) } }) } const PromiseRace = (iterator) => { const promises = Array.from(iterator) return new Promise((resolve, reject) => { for (let item of promises) { item.then(res => { resolve(res) }).catch(err => { reject(err) }) } }) } const promise1 = Promise.resolve('promise1'); const promise2 = new Promise(function (resolve, reject) { setTimeout(resolve, 2000, 'promise2'); }); const promise3 = new Promise(function (resolve, reject) { setTimeout(resolve, 3000, 'promise3'); }); PromiseAll([promise1, promise2, promise3]).then(function(values) { console.log(values); }); PromiseRace([promise2, promise3]).then(function(values) { console.log(values); }); 10. async await yeild function longTimeFn(time) { return new Promise((resolve) => { setTimeout(() => { resolve(time); }, time) }) } function * generator() { const list = [1000, 2000, 3000]; for (let i of list) { yield longTimeFn(i); } } const kick = () => { let g = generator(); const next = () => { const { value, done } = g.next() if (done) return value.then(res => { console.log(res) next() }) } next() } kick() async 就相当于 generator 函数中的 *，await 相当于 yield。 async await 就是结合 promise 和 generator 的高级语法糖。 function longTimeFn(time) { return new Promise(resolve => { setTimeout(() => { resolve(time); }, time); }) }; function asyncFunc(generator) { const iterator = generator(); // 接下来要执行next // data为第一次执行之后的返回结果，用于传给第二次执行 const next = (data) => { const { value, done } = iterator.next(data); // 第二次执行，并接收第一次的请求结果 value 和 done if (done) return; // 执行完毕, 直接返回 // 第一次执行next时，yield返回的 promise实例 赋值给了 value value.then(data => { next(data); // 当第一次value 执行完毕且成功时，执行下一步(并把第一次的结果传递下一步) }); } next(); }; asyncFunc(function* () { let data = yield longTimeFn(1000); console.log(data); data = yield longTimeFn(2000); console.log(data); return data; }) 11. proxy 对象的代理 get(target, propKey, receiver) => person.age set(obj, prop, value, receiver) => person.age = 100 has(target, key) => '_age' in person 拦截 HasProperty 操作 let handler = { get: (target, propKey, receiver) => { if (propKey in target) { console.log({target, propKey, receiver}) return target[propKey]; } else { throw new ReferenceError(\"Prop name \\\"\" + propKey + \"\\\" does not exist.\"); } }, set: (obj, prop, value, receiver) => { console.log({obj, prop, value, receiver}) if (prop === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value > 200) { throw new RangeError('The age seems invalid'); } } obj[prop] = value; return true; }, has: (target, key) => { if (key.startsWith('_')) { return false; } return key in target } }; let person = new Proxy({}, handler); person.age = 100; console.log(person.age) person._age = 100; console.log('_age' in person) // false 函数的代理 apply(target, ctx, args) 参数说明：目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 const handler = { apply (target, ctx, args) { // return Reflect.apply(...arguments) * 2; return target(...args) * 2 } }; const sum = (left, right) => { return left + right }; const proxy = new Proxy(sum, handler) console.log(proxy(1, 2)) // 6 proxy.call(null, 5, 6) // 22 proxy.apply(null, [7, 8]) // 30 proxy.bind(null, 50, 60)() // 220 其他(用得少，用的时候再学，知道有就行) construct (target, args, newTarget) => 拦截 new 命令 deleteProperty (target, key) => 拦截 delete 操作 defineProperty (target, key, descriptor) => 拦截 Object.defineProperty() 操作 getOwnPropertyDescriptor (target, key) => 拦截 Object.getOwnPropertyDescriptor() 操作 getPrototypeOf(target) => 拦截获取对象原型，有点多：😁 Object.prototype.proto Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof isExtensible(target) => 拦截 Object.isExtensible() 操作 ownKeys(target) => 拦截对象自身属性的读取操作, 也有点多：😁 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for...in循环 preventExtensions(target) => 拦截 Object.preventExtensions() 操作 setPrototypeOf (target, proto) => 拦截 Object.setPrototypeOf() 方法 12. Reflect Reflect是个什么东西? 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 name in obj => Reflect.has(obj, name) delete obj[name] => Reflect.deleteProperty(obj, name) 13 Set && WeakSet A、Set类似于数组，但是成员的值都是唯一的，没有重复的值。[...new Set(array)] const set = new Set([1, 2, 3, 4]) /** Set 基础属性和方法 */ set.add(5) // 添加某个值，返回 Set 结构本身 set.delete(5) // 删除某个值，返回一个布尔值，表示删除是否成功 set.has(5) // 返回一个布尔值，表示该值是否为Set的成员 set.size // 返回Set实例的成员总数 set.clear() // 清除所有成员，没有返回值 /** Set 遍历操作 */ set.keys()：返回键名的遍历器 set.values()：返回键值的遍历器 set.entries()：返回键值对的遍历器 set.forEach()：使用回调函数遍历每个成员 for (item of set) { console.log(item) } // 类似于...set B、WeakSet 与 Set 区别 WeakSet 的成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 WeakSet 不可遍历 WeakSet 没有size属性 WeakSet 没有clear、forEach方法 14 Map && WeakMap A、Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。 const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); const key = {'sex': 'male'} /** Map 基础属性和方法 */ map.set(key, 'female').set(key, 'male') // 设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法 map.delete(key) // 删除某个键，返回true。如果删除失败，返回false map.get(key) // 读取key对应的键值，如果找不到key，返回undefined map.has(key) // 返回一个布尔值，表示某个键是否在当前 Map 对象之中 map.size // 返回 Map 结构的成员总数 map.clear() // 清除所有成员，没有返回值 /** Map 遍历操作 */ map.keys()：返回键名的遍历器 map.values()：返回键值的遍历器 map.entries()：返回键值对的遍历器 map.forEach()：使用回调函数遍历每个成员 for (item of map) { console.log(item) } // 类似于...set B、Map 与 数组、对象、json 的相互转换 Map 与 数组 Map 与 对象 Map 与 json C、WeakMap 与 Map 区别 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 WeakMap的键名所指向的对象，不计入垃圾回收机制。注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用 WeakMap 不可遍历 WeakMap 没有size属性 WeakMap 没有clear、forEach方法 15 Symbol Symbol('foo') 与 Symbol.for('foo') let s3 = Symbol.for('foo') 对应 Symbol.keyFor(s3）=== 'foo' s.description 比 s.toString() 好用直接返回描述信息 'foo' Symbol 在对象中的表示 key 需要加上 [] Object.getOwnPropertySymbols 只便宜以 Symbol 作为 key 的属性 Reflect.ownKeys 返回所有的键名，包括 Symbol 属性 let s1 = Symbol('foo'); let s2 = Symbol('foo'); let s3 = Symbol.for('foo'); let s4 = Symbol.for('foo'); console.log(s3 === s4); console.log(Symbol.keyFor(s3), Symbol.keyFor(s1)) console.log(s1.toString() === s2.toString()); console.log(s1.description, s2.description); let a = { [s1]: 'Hello!', [s2]: 'World!' }; console.log(a[s1], a[s2]); Object.getOwnPropertySymbols(a).forEach(s => { console.log(s, a[s]); }) Reflect.ownKeys(a).forEach(s => { console.log(s, a[s]) }) es7 新语法 1.Array.prototype.includes()方法 2.求幂运算符** //在ES7中引入了指数运算符，具有与Math.pow()等效的计算结果 console.log(2**10); // 输出 1024 console.log(Math.pow(2, 10)) // 输出1 024 es8 新语法 1.Async/Await 2.Object.values()，Object.entries() 3.String padding 字符串填充 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' '12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 4.Object.getOwnPropertyDescriptors() ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象（descriptor）。ES8 引入了 Object.getOwnPropertyDescriptors() 方法，返回指定对象所有自身属性（非继承属性）的描述对象。 该方法的引入目的，主要是为了解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题。我们来看个例子： const source = { set foo (value) { console.log(value) }, get bar () { return '浪里行舟' } } const target1 = {} Object.assign(target1, source) console.log(Object.getOwnPropertyDescriptor(target1, 'foo')) es9 新特性 1.for await of function Gen (time) { return new Promise(function (resolve, reject) { setTimeout(function () { resolve(time) }, time) }) } async function test () { let arr = [Gen(2000), Gen(100), Gen(3000)] for await (let item of arr) { console.log(Date.now(), item) } } test() // 1575536194608 2000 // 1575536194608 100 // 1575536195608 3000 2.Object Rest Spread const input = { a: 1, b: 2, c: 3 } let { a, ...rest } = input console.log(a, rest) // 1 {b: 2, c: 3} 3.Promise.prototype.finally() fetch('https://www.google.com') .then((response) => { console.log(response.status); }) .catch((error) => { console.log(error); }) .finally(() => { document.querySelector('#spinner').style.display = 'none'; }); 4.新的正则表达式特性 s (dotAll) 标志 点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符, 如换行符(\\n)或回车符(\\r): console.log(/foo.bar/.test('foo\\nbar')) // false console.log(/foo.bar/s.test('foo\\nbar')) // true 命名捕获组 const re = /(?\\d{4})-(?\\d{2})-(?\\d{2})/; const match = re.exec('2019-01-01'); console.log(match.groups); // → {year: \"2019\", month: \"01\", day: \"01\"} console.log(match.groups.year); // → 2019 console.log(match.groups.month); // → 01 console.log(match.groups.day); // → 01 Lookbehind 后行断言 let test = 'world hello' console.log(test.match(/(? Unicode属性转义 const str = '㉛'; console.log(/\\d/u.test(str)); // → false console.log(/\\p{Number}/u.test(str)); // → true console.log(/\\P{Number}/u.test('㉛')); // → false console.log(/\\P{Number}/u.test('ض')); // → true console.log(/\\P{Alphabetic}/u.test('㉛')); // → true console.log(/\\P{Alphabetic}/u.test('ض')); // → false es10新特性 1.Array.prototype.flat() 2.Array.prototype.flatMap() 3.Object.fromEntries() 4.String.trimStart 和 String.trimEnd 5.String.prototype.matchAll 6.try…catch try-catch 语句中的参数变为了一个可选项 7.BigInt 8.Symbol.prototype.description 9.Function.prototype.toString() 10.空值合并运算符（??） 空值合并运算符（??）是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。 const foo = null ?? 'default string'; console.log(foo); // expected output: \"default string\" const baz = 0 ?? 42; console.log(baz); // expected output: 0 11.可选链式操作符（?.） let person = {}; // 如果person对象不包含profile会报错 console.log(person.profile.name ?? \"Anonymous\"); // person.profile is undefined // 下面的路径是可选的，如果person对象不包含profile属性直接返回\"Anonymous\" console.log(person?.profile?.name ?? \"Anonymous\"); console.log(person?.profile?.age ?? 18); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/RegExp/":{"url":"pages/js/RegExp/","title":"正则","keywords":"","body":"RegExp 正则基础知识： \\d: 数字 \\w: 数字字母下划线 \\s: 空格 [a-zA-Z]: 字母 [-]: 正则元素，例如：/[0-9]/g {,}: 正则量词，例如：/\\d{0,3}/g *: 0个或者多个，{0,} +: 1个或者多个，{1,} ?: 0个或者1个，{0,1} [^0]\\d*[@]$: ^ 表示以什么开头，$ 表示以什么结尾 reg 的方法 reg.test(str)：匹配到：返回true;匹配不到：返回false; reg.exec(str)：匹配到：返回数组【reg,index,str】；匹配不到：返回null;无全局标识符，无子集：匹配到：返回数组；匹配不到：返回null;【[\"123\", index: 0, input: \"123abc123def123\"]】无全局标识符，有子集：匹配到：返回数组（第二项是子集）；匹配不到：返回null;【[\"123\", \"12\", index: 0, input: \"123abc123def123\"]】 string 的方法 match str.match(reg)：无全局标识符，无子集：匹配到：返回数组；匹配不到：返回null;【[\"123\", index: 0, input: \"123abc123def123\"]】与exec类似无全局标识符，有子集：匹配到：返回数组（第二项是子集）；匹配不到：返回null;【[\"123\", \"12\", index: 0, input: \"123abc123def123\"]】与exec类似有全局标识符：匹配到：返回数组（全为匹配到的项）；匹配不到：返回null;【[\"123\", \"123\", \"123\"]】忽略全局标识符 replace str.replace(reg,newStr) search str.search(reg)：匹配到：总是返回第一个匹配项的下标；匹配不到：返回-1； RegExp 的方法 test exec match 从 string 中匹配符合正则的结果，以数组的形式返回 如果正则指定了参数 g，那么 match 一次返回所有的结果 [\"1a\", \"1b\", \"1c\"] 如果正则没有指定了参数 g，那么 match 返回符合条件的第一个匹配项结果 [\"1a\", index: 0, input: \"1a1b1c\", groups: undefined] const htmlText = res.text const reg = new RegExp('\"objURL\":\"(.*?)\",', 'g') const imgUrl = htmlText.match(reg) const imgList = imgUrl.map(item => { item.match(/\":(.*)\"/g) return RegExp.$1 }) replace 直接替换 const str = `Welcome to Microsoft! We are proud to announce that Microsoft has. one of the largest Web Developers sites in the world.` const option = {'Microsoft': 'W3School', 'world': 'universe'} Object.keys(option).forEach(key => { str = str.replace(new RegExp(key, 'g'), option[key]) }) console.log({str}) 函数替换 const year = '2021'; const month = '10'; const day = '01'; let template = '${year}-${month}-${day}'; let context = { year, month, day }; const render = tem => { return (obj) => { // ?的意思是非贪婪模式（https://regex101.com/） return tem.replace(/\\$\\{(.+?)\\}/g, (args, key) => { return context[key] }) } } const str = render(template)({year,month,day}); console.log(str) search string.test(RegExp): 返回符合条件的第一个匹配项下标，如果匹配不到，则返回 -1。 test RegExp.test(string): 查找对应的字符串中是否存在，存在返回 true，不存在返回 false。 exec RegExp.exec(string): 查找并返回当前的匹配结果，并以数组的形式返回，匹配不到返回 null。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 18:49:18 "},"pages/js/callApplyBind/":{"url":"pages/js/callApplyBind/","title":"call/apply/bind","keywords":"","body":"call bind 和 bind 方法的区别和深入理解 用法的区别 const me = { name: 'xiuyan', age: 18 } function showName(a, b) { console.log(`${this[a]}:${this[b]}岁`) } // call showName.call(me, 'name', 'age') // apply showName.apply(me, ['name', 'age']) // bind showName.bind(me, 'name', 'age')() call的模拟 Function.prototype.myCall = function(context, ...args) { // step1: 把函数挂到目标对象上（这里的 this 就是我们要改造的的那个函数） context.func = this // step2: 执行函数 context.func(...args) // step3: 删除 step1 中挂到目标对象上的函数，把目标对象”完璧归赵” delete context.func } apply的模拟 Function.prototype.myApply = function(context, args) { // step1: 把函数挂到目标对象上（这里的 this 就是我们要改造的的那个函数） context.func = this // step2: 执行函数 context.func(...args) // step3: 删除 step1 中挂到目标对象上的函数，把目标对象”完璧归赵” delete context.func } bind的模拟 Function.prototype.myBind = function(context, ...args) { // step1: 把函数挂到目标对象上（这里的 this 就是我们要改造的的那个函数） context.func = this // step2: 返回函数 return () => { context.func(...args) // step3: 执行函数的时候，删除 step1 中挂到目标对象上的函数，把目标对象”完璧归赵” delete context.func } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/babel/":{"url":"pages/js/babel/","title":"babel","keywords":"","body":"babel基本配置和自定义插件编写 babel基本配置 const myPlugin = require(\"./plugin\") module.exports = { presets: [ [ \"@babel/preset-env\", // es 语法编译 { useBuiltIns: \"usage\", // 按需添加 polyfills corejs: \"3\", targets: { browsers: [\"ie >= 12\"] // 浏览器版本 } } ] ], plugins: [ myPlugin, [ \"@babel/plugin-transform-runtime\", { \"corejs\": 2 } ] ] } 目前babel官网维护的只有四个 presets： @babel/preset-env 自动管理浏览器版本 和 es 语法转换。 @babel/preset-flow：编译js代码静态类型检查器flow @babel/preset-react：编译react语法 @babel/preset-typescript：编译ts语法 core-js 版本： core-js 2：这是较早期的 core-js 版本，用于填充 ECMAScript 6 和 ECMAScript 7 中引入的特性，以及一些附加的功能。它广泛用于许多项目，但随着时间的推移，更现代的版本逐渐取代了它。 core-js 3：这是 core-js 的较新版本，旨在提供更好的性能和模块化。它支持 ECMAScript 6+ 的特性，并且按需引入 polyfills，以减小生成的代码大小。core-js 3 是目前在许多项目中常用的版本。 core-js 4：core-js 4 是 core-js 的下一个重大版本，它将进一步改进性能和模块化，以适应 JavaScript 生态系统的变化。截止到我知道的时间，core-js 4 还处于开发中，尚未正式发布。 @babel/plugin-transform-runtime 的作用 代码中的辅助函数不再以全局变量的形式存在。相反，它们被导入自@babel/runtime模块，并且以模块范围内的方式使用，避免了全局污染问题。 举例说明 源码 // example.js class MyClass { constructor(name) { this.name = name; } async greet() { return `Hello, ${this.name}!`; } } const obj = new MyClass('Alice'); obj.greet().then((message) => { console.log(message); }); before \"use strict\"; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } var MyClass = /*#__PURE__*/function () { function MyClass(name) { _classCallCheck(this, MyClass); this.name = name; } var _proto = MyClass.prototype; _proto.greet = /*#__PURE__*/function () { var _greet = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() { return regeneratorRuntime.wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: return _context.abrupt(\"return\", \"Hello, \" + this.name + \"!\"); case 1: case \"end\": return _context.stop(); } } }, _callee, this); })); function greet() { return _greet.apply(this, arguments); } return greet; }(); return MyClass; }(); var obj = new MyClass('Alice'); obj.greet().then(function (message) { console.log(message); }); after \"use strict\"; var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\"); var _asyncToGenerator2 = require(\"@babel/runtime/helpers/asyncToGenerator\"); var _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\"); var _createClass2 = require(\"@babel/runtime/helpers/createClass\"); function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) return; if (typeof it === \"function\" && it.prototype) it = it.prototype; if (typeof it === \"object\" && it !== Array.prototype) return { __iterator: it }; if (allowArrayLike && it === Array.prototype.entries) return { __iterator: it }; return it; } var MyClass = /*#__PURE__*/function () { function MyClass(name) { (0, _classCallCheck2.default)(this, MyClass); this.name = name; } (0, _createClass2.default)(MyClass, [{ key: \"greet\", value: function () { var _greet = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee() { return regeneratorRuntime.wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: return _context.abrupt(\"return\", \"Hello, \" + this.name + \"!\"); case 1: case \"end\": return _context.stop(); } } }, _callee, this); })); function greet() { return _greet.apply(this, arguments); } return greet; }() }]); return MyClass; }(); var obj = new MyClass('Alice'); obj.greet().then(function (message) { console.log(message); }); babel自定义插件编写 文档地址 https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/README.md babel 编译原理 经典流程图 babel 主要模块及作用 const babel = require(\"@babel/core\") // babel.parseSync 将文件读取的代码转成 AST const template = require(\"@babel/template\").default // 将手写的模板代码转成 AST const traverse = require(\"@babel/traverse\").default // traverse 遍历AST树并进行替换、添加、删除操作 const generate = require(\"@babel/generator\").default // 将 AST 还原成代码 demo 代码：在某句代码前插入一段新的代码 const path = require('path') const fs = require('fs') const babel = require(\"@babel/core\") const template = require(\"@babel/template\").default const generate = require(\"@babel/generator\").default const traverse = require(\"@babel/traverse\").default const Path = entryPath.join(__dirname, 'dist/app.js') const content = fs.readFileSync(entryPath, 'utf-8') const appJsAst = babel.parseSync(content, {sourceType: 'script'}) const buildRequire = template(` const taroApp = require(\"./taro/app.js\"); `) const ast = buildRequire() traverse(appJsAst, { ExpressionStatement(path) { const calleePath = path.get('expression.callee') if (calleePath.isIdentifier({ name: 'App' })) { const prevPath = path.getPrevSibling() const isVariableDeclaration = prevPath.isVariableDeclaration() const firstDeclarationPath = isVariableDeclaration && prevPath.get('declarations.0') const isTaroApp = firstDeclarationPath && firstDeclarationPath.node.id.name === 'taroApp' console.log(firstDeclarationPath.node.id.name) if (!isTaroApp) { path.insertBefore(ast) } } } }) const { code: appJsCode } = generate(appJsAst, { sourceMaps: false }) const destPath = path.join(__dirname, 'dist/new.js') fs.writeFileSync(destPath, appJsCode) @babel/traverse 方法详解 ast-explorer 网址：https://lihautan.com/babel-ast-explorer const traverse = require(\"@babel/traverse\").default traverse(appJsAst, { ExpressionStatement(path) { const calleePath = path.get('expression.callee') if (calleePath.isIdentifier({ name: 'App' })) { const prevPath = path.getPrevSibling() const isVariableDeclaration = prevPath.isVariableDeclaration() const firstDeclarationPath = isVariableDeclaration && prevPath.get('declarations.0') const isTaroApp = firstDeclarationPath && firstDeclarationPath.node.id.name === 'taroApp' console.log(firstDeclarationPath.node.id.name) if (!isTaroApp) { path.insertBefore(ast) } } } }) // ExpressionStatement // prevPath.get('declarations.0') 虽然是数组，但还是只能使用点操作，prevPath.get('declarations[0]') 无效 // path.getPrevSibling() 获取兄弟节点 // prevPath.isVariableDeclaration() 节点判断 // firstDeclarationPath.node.id.name === 'taroApp' node 不能少 // path.insertBefore(ast) 节点插入 babel 和 polyfill 的区别 babel 默认只转换新的 JavaScript 语法（syntax），而不转换新的 API。比如：箭头函数转化成普通函数。 polyfill 将新的 API 用 es5 的方法实现。比如：Promise、Array.of module.exports = { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', // 使用的才引入 corejs: 3, }, ], ], }; SWC 相对于 Babel 之所以更快，有以下几个主要原因： Rust 编写：SWC 是用 Rust 编写的，Rust 是一种系统级编程语言，以其性能和内存管理的安全性而闻名。Rust 具有出色的性能特性，因此 SWC 在编译速度上具有优势。 并行编译：SWC 具有并行编译的能力，可以充分利用多核处理器。这意味着它可以同时处理多个文件，从而加速整个编译过程，特别是在大型项目中表现出色。 更少的内存开销：SWC 针对内存开销进行了优化，相对于 Babel 使用更少的内存。这有助于避免在大型项目中出现内存问题，并提高了稳定性。 高度优化的代码生成：SWC 生成的 JavaScript 代码非常紧凑和高效，它对代码进行了深度优化，包括减小变量名、减少不必要的操作等。这可以减小生成的代码的体积，提高代码执行性能。 针对现代特性的优化：SWC 针对现代 JavaScript 特性进行了优化，特别是针对 ECMAScript 6+ 和 TypeScript。它可以更有效地识别和转换这些特性，而不需要像 Babel 那样复杂的插件和配置。 Babel 是一个非常灵活的工具，它可以通过各种插件和配置来满足各种需求，但这种灵活性可能会导致一些性能开销。相比之下，SWC 更专注于性能和速度，因此在某些场景下可能会更快。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 23:52:13 "},"pages/js/typescript/":{"url":"pages/js/typescript/","title":"TypeScript","keywords":"","body":"TypeScript 基础知识点 基础类型: number string boolean array object 1. enum: 枚举 ✅ enum Color { Red = 1, Green = 2, Blue = 3 } let c: Color = Color.Blue 2. type 和 interface ✅ // interface 拓展 interface Name { name: string } interface User extends Name { age: number } // type 交叉 type TName = { name: string } type TUser = TName & { age: number } // type 可以而 interface 不行 interface Dog { wong(); } interface Cat { miao(); } type Pet = Dog | Cat // type 语句中还可以使用 typeof 获取实例的 类型进行赋值 let div = document.createElement('div'); type B = typeof div // interface 可以而 type 不行(合并声明) interface User { name: string } interface User { age: number } 3. 联合类型 | ✅ function test (age: string | number) { return age } 4. 交叉类型 & ✅ interface A { name: string age?: number } interface B { name: string height?: number } function sum (age: A & B) { return age } sum({name: 'tommy'}) 5. typeof ✅ function toArray(x: number): Array { return [x]; } type Func = typeof toArray; // -> (x: number) => number[] 6. keyof ✅ interface Person { name: string; age: number; } type K1 = keyof Person; // \"name\" | \"age\" 7. in ✅ // 遍历联合类型 type Keys = \"a\" | \"b\" | \"c\" type Obj = { [p in Keys]: string } let obj: Obj = { a: '123', b: '234', c: '345' } // 遍历枚举类型 enum Color { Red = 'red', Green = 'green', Blue = 'blue' } let c: Color = Color.Blue type Col = { [key in Color]: string } const col: Col = { 'red': '1', 'green': '2', 'blue': '3' } 8. extends ❎ interface ILengthwise { length: number; } function loggingIdentity(arg: T): T { console.log(arg.length); return arg; } loggingIdentity(3); loggingIdentity({length: 10, value: 3}); 9. Partial ✅ Partial 的作用就是将某个类型里的属性全部变为可选项 ?。 10. Required ✅ Required 的作用就是将某个类型里的属性全部变为必选项。 11. Readonly ✅ Readonly 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。 12. Record ✅ Record 的作用是将 K 中所有的属性的值转化为 T 类型。 // 联合类型 interface PageInfo { title: string; } type Page = \"home\" | \"about\" | \"contact\"; const x: Record = { about: { title: \"about\" }, contact: { title: \"contact\" }, home: { title: \"home\" } }; // 枚举 enum Page { HOME, CONTACT } type PageInfo = { title: string } const x: Record = { 0: { title: '123' }, 1: { title: '123' } } enum DeviceComponents { DRIVER = 'DRIVER', JACK = 'JACK', MOTOR = 'MOTOR', BATTERY = 'BATTERY', SENSOR = 'SENSOR', COMMUNICATION = 'COMMUNICATION', NAVIGATION = 'NAVIGATION', } const DeviceComponentsMap: Record = { DRIVER: '驱动模块', JACK: '顶升模块', MOTOR: '运动状态', BATTERY: '电源管理', SENSOR: '传感器数据', COMMUNICATION: '通讯模块', NAVIGATION: '导航模块', }; // 普通函数 function transform> ( iteratee: (node: T) => any, treeData: T[], childrenKey: keyof T = 'children', ) { return treeData.map((node) => { const result = iteratee(node); const children = result[childrenKey]; if (Array.isArray(children)) { result[childrenKey] = transform(iteratee, children, childrenKey); } return result; }); } // 箭头函数 const transform2 = >( iteratee: (node: T) => any, treeData: T[], childrenKey: keyof T = 'children', ) => { return treeData.map((node) => { const result = iteratee(node); const children = result[childrenKey]; if (Array.isArray(children)) { result[childrenKey] = transform2(iteratee, children, childrenKey); } return result; }); } 13. Exclude ✅ Exclude 的作用是将某个类型中属于另一个的类型移除掉。 // 联合类型 type T0 = Exclude; // \"b\" | \"c\" type T1 = Exclude; // \"c\" // 枚举 enum Color { Red = 'red', Green = 'green', Blue = 'blue' } type T1 = Exclude const col: Record = { 'green': '2', 'blue': '3' } 14. Extract ✅ Extract 的作用是从 T 中提取出 U。 // 联合类型 type T0 = Extract; // \"a\" type T1 = Extract void), Function>; // () => void // 枚举 export enum DeviceType { HIVE = 'HIVE', ROBOT = 'ROBOT', ELEVATOR = 'ELEVATOR', GATE = 'GATE', SIGNAL = 'SIGNAL', DOCK = 'DOCK', GADGET = 'GADGET', } type CandlelightDeviceType = Extract export const CandlelightDeviceTypeMap: Record = { ROBOT: '机器人', HIVE: '箱柜', }; type RobotDeviceType = Extract export const SunlightDeviceTypeMap: Record = { ROBOT: '机器人', }; export const AuroraDeviceTypeMap: Record = { ROBOT: '机器人', }; type CommonDeviceType = Extract export const CommonDeviceTypeMap: Record = { ELEVATOR: '电梯', GATE: '闸机', }; 15. Pick ✅ Pick 从T中挑出U类型。 interface Test { name: string; sex: number; height: string; } type Sex = Pick; const a: Sex = { sex: 1 }; // U 可以是一个数组 enum DeviceComponents { DRIVER = 'DRIVER', JACK = 'JACK', MOTOR = 'MOTOR', BATTERY = 'BATTERY', SENSOR = 'SENSOR', COMMUNICATION = 'COMMUNICATION', NAVIGATION = 'NAVIGATION', } const DeviceComponentsMap: Record = { DRIVER: '驱动模块', JACK: '顶升模块', MOTOR: '运动状态', BATTERY: '电源管理', SENSOR: '传感器数据', COMMUNICATION: '通讯模块', NAVIGATION: '导航模块', }; pick( DeviceComponentsMap, [ DeviceComponents.COMMUNICATION, DeviceComponents.BATTERY, ] ) 16. 泛型 // 接口泛型 interface Generic { name: T } type GA = Generic type GB = Generic const ga: GA = {name: '123'} const gb: GB = {name: 123} // 函数泛型 function generic(arg: T[]): T[] { console.log(arg.length) return arg } generic([123]) generic(['tommy']) 16. 装饰器 1. 类装饰器和类方法装饰器 类方法装饰器： target：VirtualList.prototype 原型 name：key 类方法名 descriptor：Object.getOwnPropertyDescriptor(target, key) 类方法对应的描述符 类装饰器: target：VirtualList 类本身 // 类装饰器 export const test = (target: any) => { target.isAnimal = true; console.log({target}) return target; } // 类方法装饰器 export const readonly = (target: any, name: string, descriptor: PropertyDescriptor) => { descriptor.writable = false; console.log('readonly') return descriptor; } // 使用 @test export default class VirtualList extends Vue { @readonly created() { console.log(123) } } 模拟实现 es6 的装饰器: target、name、descriptor class Model { getData() { return new Promise((resolve, reject) => { setTimeout(() => { console.log('wait for 2 seconds') resolve([{ id: 1, name: 'Niko' }, { id: 2, name: 'Bellic' }]) }, 2000) }) } } const wrap = (Model, key) => { // 获取Class对应的原型 let target = Model.prototype // 获取函数对应的描述符 let descriptor = Object.getOwnPropertyDescriptor(target, key) let log = function (...arg) { let start = new Date().valueOf() return descriptor.value.apply(this, arg).then((res) => { let end = new Date().valueOf() console.log(`start: ${start} end: ${end} consume: ${end - start}`) return res }) } Object.defineProperty(target, key, { ...descriptor, value: log }) } wrap(Model, 'getData') const init = async() => { const model = new Model() const res = await model.getData() console.log(res) } init() 2. 缓存装饰器（未考虑时效性） const cacheMap = new Map(); export function EnableCache(target: any, name: string, descriptor: PropertyDescriptor) { const val = descriptor.value; descriptor.value = async function(...args: any) { const cacheKey = name + JSON.stringify(args); console.log('cache:', cacheMap.get(cacheKey)) if (!cacheMap.get(cacheKey)) { const cacheValue = Promise.resolve(val.apply(this, args)).catch((_) => cacheMap.set(cacheKey, null)); cacheMap.set(cacheKey, cacheValue); console.log({ cacheValue }) } return cacheMap.get(cacheKey); }; return descriptor; } 3. 执行时间计算装饰器 export const measure = (before?: any, after?: any) => { return (target: any, name: string, descriptor: PropertyDescriptor) => { console.log({ target, name, descriptor }, target[name]) const oldValue = descriptor.value before && before() descriptor.value = async function() { const current = Date.now() const res = await oldValue.apply(this, arguments) // const res = await target[name].apply(this, arguments) console.log(`total time: ${Date.now() - current}`) return res } after && after() return descriptor } } 17. router 的 ts 改造 enum RoutePath { /** 首页 */ Index = '/', /** 关于页面 */ About = '/about', /** 用户页面 */ User = '/user', } interface IndexPageParam { name: string; } interface AboutPageParam { testName: string; } interface UserPageParam { userId: number; } type ParamsMap = { [RoutePath.Index]: IndexPageParam; [RoutePath.About]: AboutPageParam; [RoutePath.User]: UserPageParam; } function replace(routePath: T, params: ParamsMap[T]) { console.log({ path: routePath, query: params, }); } replace(RoutePath.User, { userId: 1 }) Vue CLI 3 TypeScript 项目实践总结 （一）创建项目 推荐创建 vue-router, vuex, less, babel, typescript,tslint, unit-mocha 组合的项目，相关配置选项如下： 常见问题： 比如不需要pwa，但是创建了包含pwa的项目： 解决办法： 删除掉 public 文件夹中，pwa 相关文件。 在 src/main.ts 把注册 pwa 入口删掉，把 src/registerServiceWorker.ts 删掉 在终端执行 yarn remove @vue/cli-plugin-pwa，把 package.json 中 devDependencies 里面 pwa 的 webpack 插件删掉 ， 因为 vue-cli3，的webpack插件是自动安装的，只要 devDependencies 有相关 webpack 插件 包就会自动安装。上述操作之后生成的 静态代码就不会包含 pwa 相关文件和代码了。 （二）代码检查与修复 typescript 语法标准 : tslint-config-standard 添加 tslint-config-standard 校验规则 ，在项目的根目录：yarn add tslint-config-standard -D 修改 tslint.json 配置文件，改成如下： { \"defaultSeverity\": \"warning\", \"extends\": [ \"tslint-config-standard\" ], \"linterOptions\": { \"exclude\": [ \"node_modules/**\", \"src/**/*.d.ts\" ], \"include\": [ \"node_modules/@types\" ] }, \"rules\": { \"no-debugger\": true, \"no-console\": true, \"no-floating-promises\": false } } 特别提醒： \"linterOptions\": { \"exclude\": [ \"src/**/*.d.ts\" ], linter一定要排除 typescript 的描述文件。否则 yarn run lint 进行语法修复时会出错，造成无法修复代码。 配置好之后，就可以在终端运行：yarn run lint 整个项目按照 tslint-config-standard 标准 进行代码修复。注意：只会修复 typescript文件 和 Vue组件中的 script 中的 typescript 代码 （三）配置 pre-commit 在 git 提交前进行代码修复 添加 pre-commit 包到项目，在项目根目录：yarn add pre-commit -D 配置 package.json 执行静态文件代码修复 // package.json \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"test:unit\": \"vue-cli-service test:unit\" }, \"pre-commit\": [ \"lint\" ] 配置后之后，我们每次 git 提交都会对项目代码进行 tslint-config-standard 修复，把不符合标准的写法修复正确。修复后需要重新 填写 git message。 （四）构建环境和运行环境处理 温馨提示，由于 vue-cli3 构建代码中 process.env.NODE_ENV 代码相关逻辑是写死的，为了保证 线上环境和测试构建规则一致，这2个环境需要主动设置 process.env.NODE_ENV 的值为 production。 添加 构建环境变量 process.env.BUILD_ENV，作用是在构建中 启用或关闭一些 线上环境和测试环境不同的代码。比如 sentry 、CDN 等，这些都是线上环境需要的。而 DEBUG、Mock 这些测试环境才需要。所以需要 构建环境变量来启用或关闭 添加 运行环境判断方法，作用是：因为构建的线上代码也同样可以部署到测试环境。当有 运行环境变量。就可以通过判断当前访问域名是线上域名还是测试域名。从而动态改变代码相关逻辑。比如：把构建线上代码部署到测试环境 ，测试 Ajax 请求地址应该也为测试环境的域名才对。 相关步骤： （1）. 在项目根目录创建 .env.production 和 .env.qatest 这两个构建环境变量设置文件 .env.production的值为： NODE_ENV=production BUILD_ENV=production .env.qatest的值为： NODE_ENV=production BUILD_ENV=testing （2）. 修改 package.json 文件，指定 .env.production 和 .env.qatest 为 yarn build 和 yarn build:test 的 mode 参数 只需要传入名称 production 和 qatest 即可 \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build:test\": \"vue-cli-service build --mode qatest\", \"build\": \"vue-cli-service build --mode production\", ... }, （3）. 在 vue.config.js 里面 根据 BUILD_ENV 进行相关构建设置。举例： const webpack = require('webpack') const pkg = require('./package.json') const registrySentryPlugin = function(baseUrl) { const SentryPlugin = require('webpack-sentry-plugin') return new SentryPlugin({ include: /\\.js(\\.map)?$/, ignore: ['node_modules'], project: pkg.name, organization: 'lixin', apiKey: '2629b3fdf8754468a6caf19840b3a575eb9aa43339d44460855a2356c9d0d4e4', release: pkg.version, baseSentryURL: 'https://sentry.lixinio.com/api/0', deleteAfterCompile: true, // 编译后是否删除本地的sourcemap suppressConflictError: true, // 压制重复上传的冲突，以防抛出错误 filenameTransform: function (filename) { // 自定义需要输出的文件名 var urlObj = require('url').parse(baseUrl) return '~' + urlObj.pathname.replace(/\\/+$/, '') + '/' + filename } }) } /** * 因为 vue-cli 使用 webpack 打包代码是通过 process.env.NODE_ENV 来区分打包的 * 为了保证 生产环境和测试环境打包规则一致。所以测试环境下 process.env.NODE_ENV 跟 生产环境一致 为 production：线上环境 * 增加新的环境变量 process.env.BUILD_ENV 做\b为当前构建环境的标志 * process.env.BUILD_ENV的值： * production：线上 * testing：测试 */ const isProduction = process.env.BUILD_ENV === 'production'; // 是否为测试环境 const isTesting = process.env.BUILD_ENV === 'testing' const baseUrl = 'https://g.lxstatic.com/dos/approval/'; module.exports = { // 线上环境需要使用 CDN项目地址 作为 baseUrl baseUrl: isProduction ? baseUrl: '/', outputDir: 'www', configureWebpack: config => { const customConfig = {} customConfig.plugins = [ // 环境变量 new webpack.DefinePlugin({ 'process.env.SENTRY_TEST': JSON.stringify(false), // 控制sentry测试 'process.env.PROJECT_VERSION': JSON.stringify(pkg.version), 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV), 'process.env.BUILD_ENV': JSON.stringify(process.env.BUILD_ENV) }) ] // 保证测试环境和生产环境打包规则一致 if (isProduction || isTesting) { customConfig.optimization = { splitChunks: { cacheGroups: { vue: { test: /[\\\\/]node_modules[\\\\/](vue|vuex|vue-router)[\\\\/]/, priority: -8, name: 'vue', chunks: 'all' }, cvux: { test: /[\\\\/]node_modules[\\\\/](cvux)[\\\\/]/, priority: -9, name: 'cvux', chunks: 'all' }, vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: 'vendors', chunks: 'all' }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } // sentry插件 customConfig.plugins.push(registrySentryPlugin(baseUrl)) // 保证未修改的文件的hash值一致 customConfig.plugins.push(new webpack.HashedModuleIdsPlugin()) } return customConfig } } （4）. 在src/main.ts 里面 使用 BUILD_ENV 控制 mock 和 debug 的启用 import './common/flexible' ... // 构建环境为非正式环境开始debug模式 if (process.env.BUILD_ENV !== 'production') { import('@/debug') import('@/mock/index') } ... （5）. 在 sentry 插件入口控制 sentry 的启用 /** * 数据上报 */ import Vue from 'vue' import * as Sentry from '@sentry/browser' import config from './config' // 构建环境为开发环境和测试环境时，sentry关闭上报 if (config.environment === 'production') { Sentry.init({ ...config, integrations: [new Sentry.Integrations.Vue({ Vue })] }) Vue.prototype.$report = Sentry } （6）. 添加运行环境判断方法，通过访问的域名来判断是否为线上域名。在需要使用的地方调用判断即可。 export default { /** * isProductionEnv() 函数用于判断当前访问的域名是正式环境还是测试环境 * return { boolean } true 正式环境/测试环境 */ isProductionEnv () { // 线上环境运行域名 return 'fa.prod.dos.cheanjia.net' === window.location.host } } （五）快速生成后端接口描述对象。 vs code 扩展：Paste JSON as Code ，能够读取剪贴板内的内容，如果符合json格式，就会在你的鼠标所在的 ts 文件 追加生成 相应的 interface 描述代码。 https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype 安装好扩展后： 右键全选复制后端接口JSON数据 打开需要粘贴的 typescript 文件 按下 Ctrl/command + shift + p ，找到 Paste JSON as Code 或者 Paste JSON as Types ，然后再按回车。就会在你鼠标光标处追加生成的 interface 描述文件。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/debounceThrottle/":{"url":"pages/js/debounceThrottle/","title":"Debounce & Throttle","keywords":"","body":"Debounce(防抖) 定义：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 应用场景：输入框，不输了再执行函数 代码： const debounce = (fn, wait) => { return function () { clearTimeout(fun.id) fun.id = setTimeout(() => { fun.call(this, arguments) }, delay) } } Throttle(节流) 定义：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 应用场景：监听滚动事件，滑到底部自动加载更多 代码： // 时间戳写法（第一次一定执行） const throttle1 = (fn, wait) => { let last = 0 return function () { let now = Date.now() if (now - last >= wait) { last = now fn.apply(this, arguments) } } } // 定时器写法（第一次也要延迟执行） const throttle2 = (fn, wait) => { let timer = null return function () { if (!timer) { timer = setTimeout(() => { fn.apply(this, arguments) timer = null }, wait) } } } // 结合写法（第一次要延迟执行，最后一次不延迟要立即执行） const throttle = (func, wait, options) => { var context, args, result var timeout = null var previous = 0 if (!options) options = {} var later = function() { previous = options.leading === false ? 0 : Date.now() timeout = null result = func.apply(context, args) if (!timeout) context = args = null } return function() { var now = Date.now() if (!previous && options.leading === false) previous = now // 计算剩余时间 var remaining = wait - (now - previous) context = this args = arguments // 当到达wait指定的时间间隔，则调用func函数 // 精彩之处：按理来说remaining wait) { // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作 if (timeout) { clearTimeout(timeout) timeout = null } previous = now result = func.apply(context, args) if (!timeout) context = args = null } else if (!timeout && options.trailing !== false) { // options.trailing=true时，延时执行func函数 timeout = setTimeout(later, remaining) } return result } } const test = () => { console.log(Math.random()) } setInterval(throttle(test, 3000), 100) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/bitOperation/":{"url":"pages/js/bitOperation/","title":"Bit Operation","keywords":"","body":"bit operation 位运算基础 console.log((10).toString(2)) // 1010 console.log((8).toString(2)) // 1000 // 与 &， 两个位都是 1 时，结果才为 1，否则为 0 console.log((10 & 8).toString(2)) // 1000 // 或 |，两个位都是 0 时，结果才为 0，否则为 1 console.log((10 | 8).toString(2)) // 1010 // 异或 ^， 两个位相同则为 0，不同则为 1 console.log((10 ^ 8).toString(2)) // 0010 // 非 ~，取反运算，0 则变为 1，1 则变为 0 console.log((~10 + 1).toString(2)) // -1010 console.log((~8 + 1).toString(2)) // -1000 // 左移 > 10 >> 1 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/ajax/":{"url":"pages/js/ajax/","title":"Ajax","keywords":"","body":"Ajax 基础 网页http请求： XMLHttpRequest const post = (url, form) => { const ajax = new XMLHttpRequest(); const sendContent = []; for (let key in form) { sendContent.push(key + '=' + form[key]) } // 使用post请求 ajax.open('post', url); ajax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ajax.setRequestHeader(\"x-csrf-token\", '1571731401##a761cfba9d85274e5c7016b677009d95e25a1408'); ajax.send(sendContent.join('&')); // 注册事件 ajax.onreadystatechange = () => { if (ajax.readyState === 4 && ajax.status === 200) { console.log(ajax.responseText) } if (ajax.readyState===4 && ajax.status!==200) { console.log(ajax.responseText) } } } post('https://boss.test.dos.cheanjia.net/api/v1/auction_mock/create_auction',{ store_id: 199, number: 2, started_at: '2019-10-22 15:10:20', tmpl_id: 32, }) wx请求： wx.request() node请求 native var http = require(\"http\"); var options = { \"method\": \"POST\", \"hostname\": [ \"127\", \"0\", \"0\", \"1\" ], \"port\": \"8360\", \"path\": [ \"api\", \"v1\", \"permission\", \"update\" ], \"headers\": { \"Content-Type\": \"application/json\", \"cache-control\": \"no-cache\", \"Postman-Token\": \"db3d26a1-b1fa-4956-9a82-09652ce8d048\" } }; var req = http.request(options, function (res) { var chunks = []; res.on(\"data\", function (chunk) { chunks.push(chunk); }); res.on(\"end\", function () { var body = Buffer.concat(chunks); console.log(body.toString()); }); }); req.write(JSON.stringify({ roleid: 3, perid: [ 2, 3 ] })); req.end(); request var request = require(\"request\"); var options = { method: 'POST', url: 'http://127.0.0.1:8360/api/v1/permission/update', headers: { 'Postman-Token': 'bb2ad141-a8ba-4b35-a8f2-084651f877a4', 'cache-control': 'no-cache', 'Content-Type': 'application/json' }, body: { roleid: 3, perid: [ 2, 3 ] }, json: true }; request(options, function (error, response, body) { if (error) throw new Error(error); console.log(body); }); unirest var unirest = require(\"unirest\"); var req = unirest(\"POST\", \"http://127.0.0.1:8360/api/v1/permission/update\"); req.headers({ \"Postman-Token\": \"6dc4bab2-ca60-435f-8c71-f2eb6092ed7c\", \"cache-control\": \"no-cache\", \"Content-Type\": \"application/json\" }); req.type(\"json\"); req.send({ \"roleid\": 3, \"perid\": [ 2, 3 ] }); req.end(function (res) { if (res.error) throw new Error(res.error); console.log(res.body); }); axios const axios = require('axios') axios.post('https://boss.test.dos.cheanjia.net/api/v1/auction_mock/create_auction', { store_id: 199, number: 2, started_at: '2019-10-22 15:50:20', tmpl_id: 32 }, { 'x-csrf-token': '1571731401##a761cfba9d85274e5c7016b677009d95e25a1408' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // Add a request interceptor axios.interceptors.request.use(function (config) { return config; }, function (error) { return Promise.reject(error); }); // Add a response interceptor axios.interceptors.response.use(function (response) { return response; }, function (error) { return Promise.reject(error); }); flyio const fly = require(\"flyio\") fly.post('/user', { name: 'Doris', age: 24 phone:\"18513222525\" }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //添加请求拦截器 fly.interceptors.request.use((request)=>{ //给所有请求添加自定义header request.headers[\"X-Tag\"]=\"flyio\"; //打印出请求体 console.log(request.body) //终止请求 //var err=new Error(\"xxx\") //err.request=request //return Promise.reject(new Error(\"\")) //可以显式返回request, 也可以不返回，没有返回值时拦截器中默认返回request return request; }) //添加响应拦截器，响应拦截器会在then/catch处理之前执行 fly.interceptors.response.use( (response) => { //只将请求结果的data字段返回 return response.data }, (err) => { //发生网络错误后会走到这里 return Promise.resolve(\"ssss\") } ) 网页 http 请求：ajax 与 fetch 的区别 ajax 的本质就是使用 XMLHttpRequest 对象来请求数据 fetch 是基于 Promise 来实现的 es6 新语法 API，是 XMLHttpRequest 的一种替代方案，它的主要特点有： 1、第一个参数是URL. 2、第二个参数是可选参数，可以控制不同的配置的init对象。 3、使用了JavaScript Promises来处理结果/回调。 fetch('http://123.207.32.32:8000/home/multidata').then(function(response) { console.log(response) return response.json() }).then(function(returnedValue) { console.log(returnedValue) }).catch(function(err) { console.log(err) }) fetch 与 ajax 的两个明显的区别 从 fetch() 返回的 Promise 将不会拒绝 http 错误状态，即使相应是一个相应是400或者500，需要自行封装。 function checkStatus(response) { if (response.status >= 200 && response.status 默认情况下，fetch 不会接受和发送 cookie，如果需要发送 cookie 的话，此时需要对其单独进行配置。 fetch(url, { credentials: 'same-origin' }) 对于 cors 请求，使用 include 值允许将凭证发送到其他域。 fetch(url, { credentials: 'include' }) flyio 与 axios 的两个明显的区别 Angular、React、Vue 这些框架通常都只专注于View层，而对于http请求，开发者一般都会单独引入一个http 请求库，如axios。随着项目的使用，觉得 axios 不尽完美，在一些场景用起来并不舒服，所以才有了Fly。 相同点 都支持Promise API, 都同时支持Node和Browser环境 都支持请求／响应拦截器 都支持自动转换 JSON 不同点 浏览器环境下两者功能不分伯仲，最大的不同是大小，fly.min.js只有4K左右，而axios.min.js 12K左右。Fly更轻量，集成成本更低 请求转发: Fly最大的特点就是在混合APP中支持请求转发，而axios不支持，关于请求转发的详细内容请参照请求重定向。值得注意的是，在web app中，webview无法拦截ajax请求，而当时现有的js http请求库没有一个提供请求转发的功能。 Http Engine: Fly中提出了Http Engine的概念，Fly可以通过更换Http Engine的方式实现很多有趣的功能，比如全局Ajax拦截，详情请参考全局ajax拦截。 在浏览器端，fly和axios实现的功能差不多，fly以轻巧取胜；在node端，fly占有明显的优势；而在于web app中，fly 的请求转发功能是独有的。而在设计思想上，fly更是技高一筹，这使得fly能够轻松的在不同的环境下运行并可以方便的对其进行定制化。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/designPattern/":{"url":"pages/js/designPattern/","title":"设计模式","keywords":"","body":"Design Pattern js 是一门动态的语言，设计模式的目的是为了编写出更加优雅，更具有维护性的代码。 新项目各方面设计的好，后期傻子也能维护好。 设计原则（SOLID） 不用死脑筋全部满足，尽可能多的满足这些原则即可。 单一职责原则 S（Single Responsibility Principle) 一个程序或一个类或一个方法只做好一件事，如果功能过于复杂，我们就拆分开，每个方法保持独立，减少耦合度。 开闭原则 O（Open Closed Principle) 对扩展开放，对修改封闭；增加新需求的时候，我们需要做的是增加新代码，而非去修改源码。 里斯替换原则 L（Liskov Substitution Principle） 子类必须实现父类的抽象方法，但不得重写父类的非抽象方法。 当子类覆盖或实现父类的方法时，方法的输入参数可以比父类方法的输入参数更宽松。 当子类覆盖或实现父类的方法时，方法的返回结果可以比父类方法的返回结果范围更严格。 接口隔离原则 I (Interface Segregation Principle) 保持接口的单一独立，类似于单一原则，不过接口独立原则更注重接口。 依赖倒置原则 D（Dependence Inversion Principle） 面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不需要关注具体的实现。 设计模式 按类型分为：创建型、结构型和行为型 A. 创建型 工厂模式: 批量生产同类型应用来满足频繁使用同一种类型需求时 建造者模式: 当我们需要模块化拆分一个大模块，同时使模块间独立解耦分工 单例模式: 全局只需要一个实例，注重统一一体化 工厂模式 Button Producer：生产不同类型的按钮 => 生产多个本质相同，利用传参区分不同属性的元素 建造者模式 页头组件Header: 包含了title、button、breadcum => 生产多重不同类型的元素 => 建造者 单例模式 全局只有一个实例，比如：全局应用 router store B. 结构型 适配器模式: 中间转换参数、保持模块间独立的时候 装饰器模式: 附着于多个组件上，批量动态赋予功能的时候 代理模式: 将代理对象与调用对象分离，不直接调用目标对象 适配器模式 适配模式可用来在现有接口和不兼容的类之间进行适配。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 配合策略模式使用更香。 class HKDevice { getPlug() { return '港行插头'; } } class mainlandDevice { getPlug() { return '大陆插头'; } } class Target { constructor(name) { this.name = name this.device = { 'HKDevice': new HKDevice(), 'mainlandDevice': new mainlandDevice() } this.plug = this.getDevice(); } getDevice() { return this.device[this.name] } getPlug() { return this.plug.getPlug() + '+转换器'; } } const target1 = new Target('mainlandDevice'); const res1 = target1.getPlug(); const target2 = new Target('HKDevice'); const res2 = target2.getPlug(); console.log({res1, res2}) 装饰器模式 装饰器(decorator)模式能够在不改变对象自身的基础上，动态的给某个对象添加额外的职责，不会影响原有接口的功能。比如：埋点。 其实就是在函数体外面包裹了一层。 const _onload = () => {console.log('onload')} onload = () => { _onload(); console.log('自己的处理函数'); }; onload() es6 的装饰器就是写在 Model 类下面的 getData 方法上面：@wrap es6 装饰器的三个参数：target, name, descriptor target：Model.prototype 原型 name：key 类方法名 descriptor：Object.getOwnPropertyDescriptor(target, key) 类方法对应的描述符 class Model { getData() { return new Promise((resolve, reject) => { setTimeout(() => { console.log('wait for 2 seconds') resolve([{ id: 1, name: 'Niko' }, { id: 2, name: 'Bellic' }]) }, 2000) }) } } const wrap = (Model, key) => { // 获取Class对应的原型 let target = Model.prototype // 获取函数对应的描述符 let descriptor = Object.getOwnPropertyDescriptor(target, key) let log = function (...arg) { let start = new Date().valueOf() return descriptor.value.apply(this, arg).then((res) => { let end = new Date().valueOf() console.log(`start: ${start} end: ${end} consume: ${end - start}`) return res }) } Object.defineProperty(target, key, { ...descriptor, value: log }) } wrap(Model, 'getData') const init = async() => { const model = new Model() const res = await model.getData() console.log(res) } init() // 类装饰器 export const test = (target: any) => { target.isAnimal = true; console.log({target}) return target; } // 类方法装饰器 export const readonly = (target: any, name: string, descriptor: PropertyDescriptor) => { descriptor.writable = false; console.log('readonly') return descriptor; } // 使用 @test export default class VirtualList extends Vue { @readonly created() { console.log(123) } } 代理模式 代理模式分为很多类，其中经常用到的有保护代理、虚拟代理、缓存代理。 保护代理是为了阻止外部对内部对象的访问或者是操作。比如：下面的示例。 虚拟代理是为了提升性能，延迟本体执行，在合适的时机进行触发，目的是减少本体的执行次数。比如：节流函数。 缓存代理同样是为了提升性能，但是为了减缓内存的压力，同样的属性，在内存中只保留一份。 class Game { play() { return \"playing\"; } } class Player { constructor(age) { this.age = age; } } class GameProxy { constructor(player) { this.player = player; } play() { return (this.player.age C. 行为型 命令模式: 发出指令，中间层传递命令本身，命中包含执行对象 模板模式: 通过模板定义执行顺序，做独立操作 观察者模式: 通过观察者，可以让被观察值统一发生变化，触发相应依赖值的统一更新 职责链模式: 独立职责的单元通过链式执行，逐步操作流程 策略模式: 策略模式的目的是定义一组算法，将每个算法封装在独立的策略类中，并使它们可以互相替换，以便在运行时选择合适的策略来解决特定的问题 迭代器模式: 迭代器模式的目的是提供一种顺序访问聚合对象（例如列表、数组或集合）元素的方法，而不暴露聚合对象的内部结构。它将迭代的责任封装在一个独立的迭代器对象中。 命令模式 将请求封装成对象，分离命令接受者和发起者之间的耦合，主要分三个对象：发起者、命令对象、接受者。 Kicker 发起命令，触发 Commander 执行命令，让 Receiver 干活。 class Receiver { exec () { console.log('你给我滚！') } } class Commander { constructor (receiver) { this.receiver = receiver } exec () { this.receiver.exec() } } class Kicker { constructor (command) { this.command = command } go () { this.command.exec() } } const receiver = new Receiver() const commander = new Commander(receiver) const kicker = new Kicker(commander) kicker.go() 模板模式 模板模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。 抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。 子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 class Template { boilWater () { console.log('把水煮开') } brew () {} pourInCup () {} addCondiments () {} init () { this.boilWater() this.brew() this.pourInCup() this.addCondiments() } } class Coffee extends Template { brew () { console.log('用沸水冲泡咖啡') } pourInCup () { console.log('把咖啡倒进杯子') } addCondiments () { console.log('加糖和牛奶') } } class Tea extends Template { brew () { console.log('用沸水冲泡茶叶') } pourInCup () { console.log('把茶叶倒进杯子') } addCondiments () { console.log('加加柠檬') } } const coffee = new Coffee() coffee.init() const tea = new Tea() tea.init() 发布订阅模式 发布订阅应用的场景很多，比如 vue 的双向绑定、node 的 EventEmitter MyEventEmitter 中的 on 是订阅，emit 是发布。 class MyEventEmitter { constructor() { this.events = {} } on (event, cbFn) { if (!this.events[event]) { this.events[event] = [] } this.events[event].push(cbFn) return this } off (event, cbFn) { if (!cbFn) { this.events[event] = [] return this } if (this.events[event]) { this.events[event] = this.events[event].filter(item => item !== cbFn) } return this } once (event, cbFn) { const onceFn = () => { cbFn.apply(this, arguments) this.off(event, onceFn) } this.on(event, onceFn) return this } emit (event, ...args) { if (this.events[event]) { this.events[event].forEach(item => item.call(this, ...args)) } } } // test const myEvent = new MyEventEmitter() myEvent.on('test1', () => { console.log('test-11') }).on('test1', () => { console.log('test-22') }).on('test1', () => { console.log('test-33') }) myEvent.emit('test1') 职责链模式 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 数据链如下： const action = { name: 'HR', nextAction: { name: '领导', nextAction: { name: '老板', nextAction: null } } } class Action { constructor(name) { this.name = name; this.nextAction = null; } setNextAction(action) { this.nextAction = action; } approve() { console.log(`${this.name}请审批，是否可以请假？`); if (this.nextAction !== null) { this.nextAction.approve(); } } } const hr = new Action('HR'); const leader = new Action('领导'); const boss = new Action('老板'); hr.setNextAction(leader); leader.setNextAction(boss); console.log(hr) hr.approve(); 策略模式 优化 if else 的一种常用手段，比较简单。 const performanceS = salary => salary * 4 const performanceA = salary => salary * 3 const performanceB = salary => salary * 2 const calculateBonus = function( performanceLevel, salary ){ if ( performanceLevel === 'S' ) { return performanceS( salary ) } if ( performanceLevel === 'A' ) { return performanceA( salary ) } if ( performanceLevel === 'B' ) { return performanceB( salary ) } } const res = calculateBonus( 'A' , 10000 ) console.log(res) 改成策略模式： const strategies = { \"S\": salary => salary * 4, \"A\": salary => salary * 3, \"B\": salary => salary * 2 } const calculateBonus = (level, salary) => strategies[level](salary) const res = calculateBonus( 'A' , 10000 ) console.log(res) 迭代器模式 从一个数据集合中按照一定顺序，不断地取数据的过程 工作中的实际应用案例：循环动画，从第一个 next() 开始，循环调用，从而将动画抽离成一个配置文件，实现用户自定义动画的功能 import { ref } from 'vue' import gsap from 'gsap' import { controls } from './controls' import { camera } from './three' import { task } from '../config/task' import { selectedValue } from './webWorker/index' const task = [ { type: 'screen', target: true, duration: 0.5 }, { type: 'switch', target: 'floor_0' }, { type: 'gsap', target: controls.target, obj: { x: 0, y: 0, z: 0 }, duration: 1 }, { type: 'rotate', duration: 30 }, { type: 'switch', target: 'floor_1' }, { type: 'gsap', target: controls.target, obj: { x: -600, y: 0, z: 500 }, duration: 4 } ] const isShowModel = ref(true) const isShowDash = ref(true) const gsapPromise = (property: any, obj: any, duration: number) => { return new Promise((resolve, reject) => { gsap.to(property, { ...obj, duration, repeat: 0, yoyo: true, onComplete: () => { resolve(1) } }) }) } const rotatePromise = (duration: number) => { return new Promise((resolve, reject) => { controls.autoRotate = true gsap.delayedCall(duration, () => { controls.autoRotate = false resolve(1) }) }) } const switchFloorPromise = (target: string) => { return new Promise((resolve, reject) => { selectedValue.value = target gsap.delayedCall(1, () => { resolve(1) }) }) } const switchScreenPromise = (target: boolean, duration: number) => { return new Promise((resolve, reject) => { isShowModel.value = target isShowDash.value = !target gsap.delayedCall(duration, () => { resolve(1) }) }) } let taskGenerator: any = null function* generatorEach(arr: any[]) { for (const [index, value] of arr.entries()) { yield (async () => { const { type, target, obj, duration } = value // 楼层模型切换 if (type === 'switch') { await switchFloorPromise(target) // 大屏切换 } else if (type === 'screen') { await switchScreenPromise(target, duration) // 位置切换 } else if (type === 'gsap') { await gsapPromise(target, obj, duration) // 场景旋转 } else if (type === 'rotate') { await rotatePromise(duration) } const { done } = taskGenerator.next() if (done) { taskGenerator = generatorEach(task) taskGenerator.next() } })() } } const animation = async () => { if (gsap.globalTimeline.paused()) { location.reload() controls.autoRotate = true } else { controls.reset() controls.autoRotate = false taskGenerator = generatorEach(task) taskGenerator.next() } } const rest = () => { controls.autoRotate = false gsap.globalTimeline.pause() } export { animation, rest, isShowModel, isShowDash } 后面继续。。。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-06 21:59:02 "},"pages/js/eslint/":{"url":"pages/js/eslint/","title":"ESlint","keywords":"","body":"ESlint 官网：https://eslint.bootcss.com/ 优秀文章：http://t.csdn.cn/hMWyT ESlint 的作用 统一团队编码规范 减少 git 不必要的提交: 结合 husky，在 commit 的时候运行校验程序 避免低级错误 在编译时检查语法，而不是等JS引擎运行时才检查 基础使用 step-1: 安装 eslint 包 node_moduels 中下载了很多包 .bin/eslint 脚本文件，内部通过 nodejs 执行 eslint运行包 的代码【#!/usr/bin/env node: Shebang 指明执行这个脚本文件的解释器是 node, /usr/bin/env 是告诉系统可以在PATH目录中查找, 解决不同的用户 node 路径不同的问题】 @eslint包 用来规范 eslint配置文件 eslint开头的包 是 eslint运行包，包含eslint代码 step-2: 生成 eslint 配置文件 包含完整脚本路径的命令：./node_modules/.bin/eslint --init 也可以用 npx 来执行 (推荐)：npx eslint --init 【npx 的作用：1. 调用项目安装的模块（node_modules/.bin路径和环境变量$PATH）；2. 避免全局安装模块，npx 将模块下载到一个临时目录，使用以后再删除。】 具体配置： 配置文件格式，加载的优先级： js > yaml > json，所以我们最好选择 js格式 JS格式使用模式：我们开发时，一般使用的是 vue脚手架，内部webpack打包默认用的是CommonJS step-3: 修改 eslint 配置文件 配置说明 env 节点：未在页面内声明，但是运行环境自带的变量，需要告诉 eslint 浏览器中的 window/document 等 nodejs中的 __dirname 等 es2021中的 WeakRef 等 globals 节点：访问当前源文件内未定义的变量, 需要在 ESLint 中定义全局变量 \"globals\": { \"_\": true, // 可以读取，可以修改 \"$\": false, // 可以读取，不能修改 \"Component\": \"readonly\" // 可以读取，不能修改 } extends 节点： 配置 extends 时，可以省略 eslint-config-，直接写成 standard 严格程度：all > airbnb-base > standard > recommended \"extends\": [ \"standard\", // \"eslint-config-standard\" \"plugin:vue/essential\", \"airbnb-base\", ] parserOptions 节点：eslint 解析器 解析代码时，可以指定 用哪个 js 的版本 rules 节点：如果不使用 extend 节点配置整套的规范，也可以在 rules节点中直接配置 原理探究 源码地址：node_modules/eslint/lib/rules meta: 配置文件: 分类，校验规则，报错信息等 create 函数: 对源码进行分析。 module.exports = { meta: { type: \"layout\", docs: { description: \"enforce linebreaks after opening and before closing array brackets\", category: \"Stylistic Issues\", recommended: false, url: \"https://eslint.org/docs/rules/array-bracket-newline\" }, fixable: \"whitespace\", schema: [ { oneOf: [ { enum: [\"always\", \"never\", \"consistent\"] }, { type: \"object\", properties: { multiline: { type: \"boolean\" }, minItems: { type: [\"integer\", \"null\"], minimum: 0 } }, additionalProperties: false } ] } ], messages: { unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\", unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\", missingOpeningLinebreak: \"A linebreak is required after '['.\", missingClosingLinebreak: \"A linebreak is required before ']'.\" } }, create(context) { const sourceCode = context.getSourceCode(); //---------------------------------------------------------------------- // Helpers //---------------------------------------------------------------------- /** * Normalizes a given option value. * @param {string|Object|undefined} option An option value to parse. * @returns {{multiline: boolean, minItems: number}} Normalized option object. */ function normalizeOptionValue(option) { let consistent = false; let multiline = false; let minItems = 0; if (option) { if (option === \"consistent\") { consistent = true; minItems = Number.POSITIVE_INFINITY; } else if (option === \"always\" || option.minItems === 0) { minItems = 0; } else if (option === \"never\") { minItems = Number.POSITIVE_INFINITY; } else { multiline = Boolean(option.multiline); minItems = option.minItems || Number.POSITIVE_INFINITY; } } else { consistent = false; multiline = true; minItems = Number.POSITIVE_INFINITY; } return { consistent, multiline, minItems }; } /** * Normalizes a given option value. * @param {string|Object|undefined} options An option value to parse. * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object. */ function normalizeOptions(options) { const value = normalizeOptionValue(options); return { ArrayExpression: value, ArrayPattern: value }; } /** * Reports that there shouldn't be a linebreak after the first token * @param {ASTNode} node The node to report in the event of an error. * @param {Token} token The token to use for the report. * @returns {void} */ function reportNoBeginningLinebreak(node, token) { context.report({ node, loc: token.loc, messageId: \"unexpectedOpeningLinebreak\", fix(fixer) { const nextToken = sourceCode.getTokenAfter(token, { includeComments: true }); if (astUtils.isCommentToken(nextToken)) { return null; } return fixer.removeRange([token.range[1], nextToken.range[0]]); } }); } /** * Reports that there shouldn't be a linebreak before the last token * @param {ASTNode} node The node to report in the event of an error. * @param {Token} token The token to use for the report. * @returns {void} */ function reportNoEndingLinebreak(node, token) { context.report({ node, loc: token.loc, messageId: \"unexpectedClosingLinebreak\", fix(fixer) { const previousToken = sourceCode.getTokenBefore(token, { includeComments: true }); if (astUtils.isCommentToken(previousToken)) { return null; } return fixer.removeRange([previousToken.range[1], token.range[0]]); } }); } /** * Reports that there should be a linebreak after the first token * @param {ASTNode} node The node to report in the event of an error. * @param {Token} token The token to use for the report. * @returns {void} */ function reportRequiredBeginningLinebreak(node, token) { context.report({ node, loc: token.loc, messageId: \"missingOpeningLinebreak\", fix(fixer) { return fixer.insertTextAfter(token, \"\\n\"); } }); } /** * Reports that there should be a linebreak before the last token * @param {ASTNode} node The node to report in the event of an error. * @param {Token} token The token to use for the report. * @returns {void} */ function reportRequiredEndingLinebreak(node, token) { context.report({ node, loc: token.loc, messageId: \"missingClosingLinebreak\", fix(fixer) { return fixer.insertTextBefore(token, \"\\n\"); } }); } /** * Reports a given node if it violated this rule. * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node. * @returns {void} */ function check(node) { const elements = node.elements; const normalizedOptions = normalizeOptions(context.options[0]); const options = normalizedOptions[node.type]; const openBracket = sourceCode.getFirstToken(node); const closeBracket = sourceCode.getLastToken(node); const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true }); const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true }); const first = sourceCode.getTokenAfter(openBracket); const last = sourceCode.getTokenBefore(closeBracket); const needsLinebreaks = ( elements.length >= options.minItems || ( options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line ) || ( elements.length === 0 && firstIncComment.type === \"Block\" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment ) || ( options.consistent && openBracket.loc.end.line !== first.loc.start.line ) ); /* * Use tokens or comments to check multiline or not. * But use only tokens to check whether linebreaks are needed. * This allows: * var arr = [ // eslint-disable-line foo * 'a' * ] */ if (needsLinebreaks) { if (astUtils.isTokenOnSameLine(openBracket, first)) { reportRequiredBeginningLinebreak(node, openBracket); } if (astUtils.isTokenOnSameLine(last, closeBracket)) { reportRequiredEndingLinebreak(node, closeBracket); } } else { if (!astUtils.isTokenOnSameLine(openBracket, first)) { reportNoBeginningLinebreak(node, openBracket); } if (!astUtils.isTokenOnSameLine(last, closeBracket)) { reportNoEndingLinebreak(node, closeBracket); } } } //---------------------------------------------------------------------- // Public //---------------------------------------------------------------------- return { ArrayPattern: check, ArrayExpression: check }; } }; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/test/":{"url":"pages/js/test/","title":"测试","keywords":"","body":"单元测试和端到端测试 E2E 测试 小程序的自动化测试 const automator = require('miniprogram-automator') const { prepareAuctionData, prepareInquiryData } = require('./data.prepare.js') const chalk = require('chalk') jest.setTimeout(200000) describe('拍卖小程序自动化测试', () => { let miniProgram let auctionStatusText = '' let auctionSessionText = '' // 运行测试前调用 beforeAll(async () => { const res = await Promise.all([prepareInquiryData(), prepareAuctionData()]) if (res[1].code === 0 && res[1].message === 'ok' && res[0].code === 0) { console.log(chalk.bold.green('模拟拍卖和询价数据创建成功')) miniProgram = await automator.launch({ // 开发者工具地址 cliPath: 'C:/Program Files (x86)/Tencent/微信web开发者工具/cli.bat', // 项目地址 projectPath: process.cwd(), }) } else { console.log(chalk.bold.red('模拟拍卖数据创建失败')) throw res } }) // 运行测试后调用 afterAll(() => { miniProgram.disconnect() }) // 拍卖大厅场景检测 describe('拍卖大厅场景检测', () => { let auctionPage beforeAll(async () => { const landingPage = await miniProgram.navigateTo('/pages/login/landing') await landingPage.waitFor(3000) auctionPage = await miniProgram.currentPage() }) test('状态检测', async () => { try { const auctionList = await auctionPage.{% math %}('.auction-session-list') const auctions = await auctionList[0].{% endmath %}('navigator') const auctionStatus = await auctionPage.$('.auction-session-item__status-text') const data = await auctionPage.data() auctionStatusText = await auctionStatus.text() if (!data.todaySessions.length && !data.futureSessions.length) miniProgram.disconnect() if (data.todaySessions.length) expect(data.todaySessions).toBeStatus(auctionStatusText) if (!data.todaySessions.length && data.futureSessions.length) expect(data.futureSessions).toBeStatus(auctionStatusText) auctionSessionText = await (await auctionPage.$('.auction-session-item__info-title')).text() await auctions[0].tap() await auctionPage.waitFor(async () => (await miniProgram.currentPage()).path === 'pages/auction/sessiondetail') } catch (e) { throw e.message } }) }) // 场次详情场景检测 describe('场次详情场景检测', () => { test('场次检测 + 状态检测', async () => { try { const carPage = await miniProgram.currentPage() expect((await miniProgram.currentPage()).path).toBe('pages/auction/sessiondetail') await carPage.waitFor('.car-info') const carsSession = await carPage.$('.data-wrapper__title') const carsStatus = await carPage.$('.session-info__status') expect(await carsSession.text()).toBe(auctionSessionText) expect(await carsStatus.text()).toBe(auctionStatusText) const cars = await carPage.{% math %}('.car-info') await cars[0].tap() await carPage.waitFor(async () => (await miniProgram.currentPage()).path === 'pages/auction/cardetail') } catch (e) { throw e.message } }) }) // 车辆详情场景检测 describe('车辆详情场景检测', () => { let carDetailPage let data beforeAll(async () => { carDetailPage = await miniProgram.currentPage() data = await carDetailPage.data() }) test('轮播图片检测', async () => { try { expect(carDetailPage.path).toBe('pages/auction/cardetail') await carDetailPage.waitFor('swiper') const swiperImg = await carDetailPage.{% endmath %}('swiper .swiper-group__image') const pageData = await carDetailPage.data() // 如果有视频，滑动图片总数等于 图片数 + 视频数 const swiperImgCount = pageData.videoUrl ? pageData.swiperImages.length + 1 : pageData.swiperImages.length expect(swiperImg.length).toBe(swiperImgCount) } catch (e) { throw e.message } }) test('关注检测', async () => { try { await carDetailPage.waitFor('.follow-or-like__submit-btn') const like = await carDetailPage.$('.follow-or-like__submit-btn') await like.tap() } catch (e) { throw e.message } }) test('正常出价检测', async () => { try { await carDetailPage.waitFor('.quote-entry__action') const quote = await carDetailPage.$('.quote-entry__action') await quote.tap() await carDetailPage.waitFor('.quote-model__auction-input') await carDetailPage.waitFor('.plus-icon') const plus = await carDetailPage.$('.plus-icon') await plus.tap() const input = await carDetailPage.$('.quote-model__auction-input') const price = +(await input.value()) await carDetailPage.waitFor('.quote-model__confirm-btn') const confirm = await carDetailPage.$('.quote-model__confirm-btn') await confirm.tap() // 微信小程序针对 嵌套了子自定义组件 会往 嵌套子组件的 class 加入 前缀，比如 index-- // 所以应该先 获取 子组件xml 然后提取 前缀 const iModal = await carDetailPage.$('i-modal') const iModalXml = await iModal.wxml() const matchSelector = iModalXml.match(//) const prefix = matchSelector[1] || 'index' // 得到前缀，重新转换成完整的 class 选择器 const modalOkBtnSelector = `.${prefix}--i-modal-btn-ok` await carDetailPage.waitFor(modalOkBtnSelector) const modalOkBtn = await carDetailPage.$(modalOkBtnSelector) await modalOkBtn.tap() await carDetailPage.waitFor(500) const currentPriceText = await (await carDetailPage.$('.auction-info-price')).text() const currentPrice = +currentPriceText.substring(0, currentPriceText.length - 1) expect(await currentPrice).toBe(price) } catch (e) { throw e.message } }) test('未过保留价检测', async () => { try { await carDetailPage.waitFor('.auction-info-over-reserver') const auctionPrice = await carDetailPage.$('.auction-info-over-reserver') expect(await auctionPrice.text()).toBe('未过保留价') } catch (e) { throw e.message } }) test('自定义出价检测', async () => { try { const price = 15.01 await carDetailPage.callMethod('handleSubmitPrice', data.auctionId, 'formid', price) // 微信小程序针对 嵌套了子自定义组件 会往 嵌套子组件的 class 加入 前缀，比如 index-- // 所以应该先 获取 子组件xml 然后提取 前缀 const iModal = await carDetailPage.$('i-modal') const iModalXml = await iModal.wxml() const matchSelector = iModalXml.match(//) const prefix = matchSelector[1] || 'index' // 得到前缀，重新转换成完整的 class 选择器 const modalOkBtnSelector = `.${prefix}--i-modal-btn-ok` await carDetailPage.waitFor(modalOkBtnSelector) const modalOkBtn = await carDetailPage.$(modalOkBtnSelector) await modalOkBtn.tap() await carDetailPage.waitFor(500) const currentPriceText = await (await carDetailPage.$('.auction-info-price')).text() const currentPrice = +currentPriceText.substring(0, currentPriceText.length - 1) expect(await currentPrice).toBe(price) } catch (e) { throw e.message } }) test('已过保留价检测', async () => { try { await carDetailPage.waitFor('.auction-info-over-reserver--over') const auctionPrice = await carDetailPage.$('.auction-info-over-reserver--over') expect(await auctionPrice.text()).toBe('已过保留价') } catch (e) { throw e.message } }) test('拍卖结果检测', async () => { try { await carDetailPage.waitFor('.finish-info__content') const auctionResult = await carDetailPage.$('.status-bar__label') expect(await auctionResult.text()).toBe('已中标') const home = await carDetailPage.{% math %}('.icon-outter') await home[1].tap() await carDetailPage.waitFor(2000) await miniProgram.switchTab('quote/index') await carDetailPage.waitFor(async () => (await miniProgram.currentPage()).path === 'pages/quote/index') } catch (e) { throw e.message } }) }) // 报价场景检测 describe('报价场景检测', () => { test('报价结果检测', async () => { try { expect((await miniProgram.currentPage()).path).toBe('pages/quote/index') const quotePage = await miniProgram.currentPage() await quotePage.waitFor('.car-info') const quoteList = await quotePage.{% endmath %}('.car-info') await quoteList[0].tap() await quotePage.waitFor(async () => (await miniProgram.currentPage()).path === 'pages/quote/quotedetail') const quoteDetailPage = await miniProgram.currentPage() const quoteButton = await quoteDetailPage.$('.quote-entry__action') await quoteButton.tap() await miniProgram.mockWxMethod('showModal', { confirm: true, cancel: false }) const price = 15.00 await quoteDetailPage.callMethod('submitQuote', price, 'formid', price) await miniProgram.restoreWxMethod('showModal') await quoteDetailPage.waitFor('.font-w') const quotePriceText = (await quoteDetailPage.data()).confirmQuotePrice const quotePrice = +quotePriceText.substring(0, quotePriceText.length - 1) expect(quotePrice).toBe(price) } catch (e) { throw e.message } }) }) }) expect.extend({ toBeStatus(received, argument) { const status = { 1: '待开拍', 2: '竞拍中' } const pass = received.length ? argument === status[received[0].status] : argument === undefined if (pass) { return { message: () => `expected ${received} not to be divisible by ${argument}`, pass: true } } else { return { message: () => `expected ${received} to be divisible by ${argument}`, pass: false } } } }) data.prepare.js const axios = require('axios') const qs = require('qs') // 测试环境 // const mockAccount = process.env.mockAccount.split('-') const auctionCreateurl = 'https://boss.test.dos.cheanjia.net/api/v1/auction_mock/create_auction_directly' const loginUrl = 'https://q.test.dos.cheanjia.net/auth/wxlogin' const auctionUrl = 'https://q.test.dos.cheanjia.net/api/v1/auctions/auction_cars' const formatDate = () => { const startedAt = new Date(Date.now() + 10000) const year = startedAt.getFullYear() const month = startedAt.getMonth() + 1 const day = startedAt.getDate() const hour = startedAt.getHours() const minute = startedAt.getMinutes() const second = startedAt.getSeconds() return `${year}-${month}-${day} ${hour}:${minute}:${second}` } const prepareAuctionData = async () => { // 设置request headers axios.interceptors.request.use( config => { // config.headers.common['Auction-Mock-Non-Scan-Key'] = process.env.noScanValue config.headers.common['Auction-Mock-Non-Scan-Key'] = 'd4310fa09cbadfc2a913cf4f9b44e731' return config }, err => { return Promise.reject(err) } ) // 模拟创建拍卖请求 const formData = { 'store_id': 199, 'number': 2, 'started_at': formatDate(), 'tmpl_id': 32 } const res = await axios.post(auctionCreateurl, qs.stringify(formData)) return res.data } // 模拟创建询价请求 const prepareInquiryData = async () => { const loginData = { username: '13800000000', password: '123456' } // const loginData = { // username: mockAccount[0], // password: mockAccount[1] // } const loginRes = await axios.post(loginUrl, loginData) const csrfToken = loginRes.headers['set-cookie'][0].split(';')[0] const session = loginRes.headers['set-cookie'][1].split(';')[0] axios.interceptors.request.use( config => { config.headers.Cookie = `${csrfToken};${session}` return config }, err => { return Promise.reject(err) } ) const auctionRes = await axios.get(auctionUrl) const auctionData = auctionRes.data.data['auction_cars'] const quoteData = auctionData.find(item => item.enquirying === false) const quoteUrl = `https://q.test.dos.cheanjia.net/api/v1/auctions/submit_auction_car_enquiry/${quoteData.auction_car_id}` const formData = { period_type: 7, config_id: 89, deal_date: '2019-10-31' } const xCsrfToken = loginRes.headers['set-cookie'][0].split(';')[0].split('=')[1] axios.interceptors.request.use( config => { config.headers.common['X-CSRF-Token'] = xCsrfToken return config }, err => { return Promise.reject(err) } ) const auoteRes = await axios.put(quoteUrl, qs.stringify(formData)) return auoteRes.data } module.exports = { prepareAuctionData, prepareInquiryData } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/":{"url":"pages/vue/","title":"Vue","keywords":"","body":"Vue基础知识 混入mixin 插槽: 匿名+具名+作用域插槽 v-slot/slot-scope plugin用方法及原理 过滤器用方法及原理 animation css will-change v-for中key的作用与diff算法 nextTick原理 v-if与v-show的区别 路由守卫，如何动态绑定路由信息？ 拦截器怎么使用？ watch与computed的区别 数据双向绑定 ✅ 虚拟dom vite原理 vue响应式原理：this.$set vue-cli源码解析 ✅ vue-router源码解析 ✅ 组件属性透传： v-bind= $attrs/inheritAttrs: false BFC: float/overflow: auto 吸顶：position: sticky vuex ssr Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/vueCli/":{"url":"pages/vue/vueCli/","title":"vue-cli","keywords":"","body":"cli 相关概念及知识 cli 是⼀种通过命令⾏来交互的⼯具应⽤，全称时 Command Line Interface。⽐较常⻅的就是 create\u0002react-app，vue-cli 等，他们都能够将⼀段 js 脚本，通过封装为可执⾏代码的形式，进⾏⼀些操作。 使⽤ cli 之后呢，能快速的创建⼀些我们业务中的样板⽂件，⽐如快速创建⼀个项⽬内容，配置公共的eslint、webpack 等等配置⼯具。 在封装这些内容之前，我们需要使⽤如下的⼏个库： commander：命令⾏中的参数获取 inquirer：命令⾏的表单 chalk：命令⾏中的可变颜⾊效果 clui：命令⾏中的 loading 效果 figlet：打印大字体框架名 child_process：node 原⽣模块，提供⼀些⽅法让我们能够执⾏新的命令 child_process 中有⼀些⽅法，⽐如 exec 等， exec ⽅法⽤于新建⼀个⼦进程，然后缓存它的运⾏结果，运⾏结束后调⽤回调函数。 我们这⾥可以使⽤ execSync，它能够执⾏⼀些我们 linux 中的命令。 commander 对命令⾏进⾏了解析，可以让我们⽐较⽅便的进⾏命令⾏参数的获取，读取和解析 chalk 对应的是命令⾏⽂字颜⾊的更改 clui 是⼀个命令⾏中展示 loading 效果的库 #!/usr/bin/env node const { program } = require('commander') const inquirer = require('inquirer') const path = require(\"path\") const childProcess = require(\"child_process\") const fuzzy = require('fuzzy'); inquirer.registerPrompt('checkbox-plus', require('inquirer-checkbox-plus-prompt')); const configs = ['babel', 'typescript', 'eslint', 'router']; program .arguments('') .description('this is a directory') .action(dir => { // console.log('--dir', dir) return inquirer.prompt([ { type: 'list', name: 'framework', message: 'which framework do u like?', choices: [ 'vue', 'react', 'uni-app' ] }, { type: 'checkbox-plus', name: 'configs', message: 'Enter configs', pageSize: 10, highlight: true, searchable: true, default: ['babel', 'router'], source: function(answersSoFar, input) { input = input || ''; return new Promise(function(resolve) { var fuzzyResult = fuzzy.filter(input, configs); var data = fuzzyResult.map(function(element) { return element.original; }); resolve(data); }); } } ]).then(answer => { const fullDir = path.resolve(process.cwd(), dir) console.log({ fullDir }) const command = `git clone https://github.com/TOMGOU/${answer.framework}-template.git ${fullDir}` console.log({ command }) childProcess.execSync(command) }) }) // console.log(process.argv) program.parse(process.argv) 注意点： \"bin\": { \"lxs-cli\": \"./index.js\" }, #!/usr/bin/env node + package.json[bin] -> npm link 本地开发软连接 lxs-cli 命令 commander.program.arguments( ).description( ).action( ) + commander.program.parse(process.argv) inquirer.prompt([{ }, { }]) 收集用户自选参数 inquirer-checkbox-plus-prompt 是 inquirer 的多选插件 child_process.execSync(command) 子线程执行 git 命令 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/vueRouter/":{"url":"pages/vue/vueRouter/","title":"vue-router","keywords":"","body":"vue-router 1.Hash 和 History 的区别 hash 有 #, history 没有 hash 的#部分内容不会给服务端， history 的所有内容都会给服务端 hash 通过 hashchange 监听变化，history 通过 popstate 监听变化 2. Hash a. 特性 url 中带有一个#符号，但是#只是浏览器端/客户端的状态，不会传递给服务端。 hash 值的更改，不会导致页面的刷新 hash 值的更改，会在浏览器的访问历史中添加一条记录。所以我们才可以通过浏览器的返回、前进按钮来控制 hash 的切换 hash 值的更改，会触发 hashchange 事件 window.addEventLisenter('hashchange', () => {}) b. 如何更改 hash location.hash location.hash = '#user'; html 标签的方式 点击跳转到 user 3.History hash 有个#符号，不美观，服务端无法接受到 hash 路径和参数 html5 history window.history.back(); // 后退 window.history.forward(); // 前进 window.history.go(-3); // 接收number参数，后退三个页面 window.history.pushState(null, null, path); window.history.replaceState(null, null, path); pushState/replaceState 的参数 state, 是一个对象，是一个与指定网址相关的对象，当 popstate 事件触发的时候，该对象会传入回调函数 title, 新页面的标题，浏览器支持不一，null url, 页面的新地址 pushState, 页面的浏览记录里添加一个历史记录 replaceState, 替换当前历史记录 History 的特性 pushState/replaceState 并不会触发 popstate 事件，这时我们需要手动触发页面的重新渲染。 我们可以使用 popstate 来监听 url 的变化 popstate 到底什么时候才能触发。 点击浏览器后退按钮 点击浏览器前进按钮 js 调用 back 方法 js 调用 forward 方法 js 调用 go 方法 pushState 和 replaceState 只是改变url地址，页面的重新渲染需要手动触发: window.location.reload() vue history模式配置 vue history模式主要有3个注意点： 在vue-router中将mode 设为historyconst router = new VueRouter({ mode: 'history', // 开启history模式 routes: [...] }) web服务器端配置// nginx location / { try_files $uri $uri/ /index.html; } history引起的副作用的处理 在history模式下web 服务器在出现未知地址时不再重定向到404页面;需要在vueRouter中添加配置处理 const router = new VueRouter({ mode: 'history', routes: [ // 未能匹配的路径使用一个统一的组件来处理 { path: '*', component: NotFoundComponent } ] }) 项目中具体改造 其中1和3没有什么特别的地方，按部就班。第二项通过dockerfile 来配置部署后的nginx服务器。具体可参考星睿数据上报项目，此项目已实现history模式 在项目跟目录中新建nginx/default.conf文件，内容一般如下 server { listen 80; server_name localhost; root /usr/share/nginx/html/; index index.html index.htm; location / { try_files $uri $uri/ /index.html; } location = /health { default_type text/plain; access_log off; error_log off; return 200 'ok\\n'; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } nginx 配置解释：try_files $uri $uri/ /index.html; root 根目录 location / 配置请求的路由，以及各种页面的处理情况。 try_files 尝试找文件，固定写法 $uri 根目录文件 $uri/ 根目录文件夹 /index.html 入口 HTML 文件：ip/index.html 整体意思：访问 $uri 或者 $uri/ 都尝试寻找 root/index.html 这个文件 接着在Dockerfile中添加指令将项目中的配置在部署时拷贝到镜像的nginx配置里COPY nginx/default.conf /etc/nginx/conf.d 4.Vue-Router简版hash(不完善) import { VueConstructor } from 'vue/types' interface RouteConfig { path: string, name: string, component: VueConstructor } type Routes = Array class Hash { listen(cb: Function) { window.addEventListener('hashchange', path => { cb && cb(window.location.hash) }) } } export default class VueRouter { static install: (Vue: any) => void routes: Routes hash: any vm: any path: string constructor({ routes }: any) { this.routes = routes this.hash = new Hash() this.path = '/' this.hash.listen((path: string) => { this.path = path.slice(1) this.vm.$forceUpdate() }) } init(vm: any) { this.vm = vm } } VueRouter.install = function(Vue: any) { Vue.mixin({ beforeCreate() { if (this.$options.router) { this.$options.router.init(this) Vue.util.defineReactive(this, '_route', this.$options.router) } } }) Vue.component('router-view', { functional: true, render(createElement: any, { props, children, parent, data }: any) { const router = parent.$parent._route const routes = router.routes const path = router.path let comp routes.forEach((item: any)=> { Object.keys(item).forEach((key: any) => { if (item[key] === path) { comp = item.component } }) }) return createElement(comp) } }) } hash模式实现关键点： hashchange 监听需要 this.vm.$forceUpdate() 强制更新 Vue.util.defineReactive(this, '_route', this.$options.router) 将 router 进行双向绑定 路由导航守卫 全局守卫 beforeEach router.beforeEach((to, from, next) => { if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' }) else next() }) beforeResolve 每次导航时都会触发，但是确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。 router.beforeResolve(async to => { if (to.meta.requiresCamera) { try { await askForCameraPermission() } catch (error) { if (error instanceof NotAllowedError) { // ... 处理错误，然后取消导航 return false } else { // 意料之外的错误，取消导航并把错误传给全局处理器 throw error } } } }) afterEach 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身。 router.afterEach((to, from, failure) => { if (!failure) sendToAnalytics(to.fullPath) }) 路由独享守卫 beforeEnter beforeEnter 守卫 只在进入路由时触发，不会在 params、query 或 hash 改变时触发。例如，从 /users/2 进入到 /users/3 或者从 /users/2#info 进入到 /users/2#projects。它们只有在从一个不同的路由导航时，才会被触发。 const routes = [ { path: '/users/:id', component: UserDetails, beforeEnter: (to, from) => { // reject the navigation return false }, }, ] 组件内部守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave const UserDetails = { template: `...`, beforeRouteEnter(to, from) { // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ }, beforeRouteUpdate(to, from) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` }, beforeRouteLeave(to, from) { // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` }, } 完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫(2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/vuex/":{"url":"pages/vue/vuex/","title":"vuex","keywords":"","body":"vue3.x + vuex4.x 基本概念 State Vuex 使用单一状态树，整个应用仅仅包含一个 store 实例。 辅助函数：mapState + createNamespacedHelpers import { mapState, mapGetters } from 'vuex'; computed: { ...mapGetters('socket', [ 'getOrderMsg', ]), ...mapState('socket', [ 'enterNotification', ]), } /** * or */ import { createNamespacedHelpers } from 'vuex'; const { mapState, mapGetters } = createNamespacedHelpers('socket'); computed: { ...mapGetters([ 'getOrderMsg', ]), ...mapState([ 'enterNotification', ]), } Getter Getter 不仅可以访问 state 数据，还能在访问的时候，对 state 进行处理。 const store = createStore({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos (state) { return state.todos.filter(todo => todo.done) } } }) 在组件中可以直接通过 store.getters 访问state，也可以通过辅助函数：mapGetters。 import { mapGetters } from 'vuex' export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } } Mutation Mutation 必须是一个纯函数，不纯的放到 Action 中。Mutation 的参数：1. { commit }, 2. payload const actions = { fetchCleaningDataTaskItem({ commit }, payload) { const { taskId, status, ...queryForm } = payload; return rest.insurance.fetchCleaningDataTaskItem(taskId, status)(queryForm).then((res) => { commit(MutationsType.UPDATE_CLEANING_DATA_TASK_ITEM, res.data.bulk_renewal_items); commit(MutationsType.UPDATE_CLEANING_DATA_TASK_ITEM_TOTAL_COUNT, res.data.total_count); return res; }); }, }; Mutation 通过 store.commit 方法触发。 在组件中可以使用 this.$store.commit('xxx') 提交 mutation，也可以使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。 import { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } } Action Action 的参数：1. state; 2. data const mutations = { [MutationsType.UPDATE_CLEANING_DATA_TASK_LIST] (state, data) { state.cleaningDataTaskList = data; }, }; Action 通过 store.dispatch 方法触发。 在组件中可以使用 this.$store.dispatch('xxx') 分发 action，也可以使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用。 import { mapActions } from 'vuex' export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } } Module const moduleA = { namespaced: true, state: () => ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { namespaced: true, state: () => ({ ... }), mutations: { ... }, actions: { ... } } const store = createStore({ // 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误 strict: process.env.NODE_ENV !== 'production', modules: { a: moduleA, b: moduleB } }) store.state.a // -> moduleA 的状态 store.state.b // -> moduleB 的状态 模块动态注册: https://vuex.vuejs.org/zh/guide/modules.html#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C import { createStore } from 'vuex' const store = createStore({ /* 选项 */ }) // 注册模块 `myModule` store.registerModule('myModule', { // ... }) // 注册嵌套模块 `nested/myModule` store.registerModule(['nested', 'myModule'], { // ... }) 基本用法 step-1: 利用 createStore 创建 store 数据 import { createStore } from 'vuex' const store = createStore({ state () { return { count: 0 } }, mutations: { increment (state, num) { state.count += num }, decrement (state, num) { state.count -= num } } }) export default store step-2: 全局安装 store import {createApp} from 'vue' import App from './App.vue' import store from './vuex/store' createApp(App).use(store).mount('#app') step-3: useStore 操作数据 {{ msg }} {{count}} add minus asyAdd import { computed } from 'vue'; import { useStore } from 'vuex'; export default { name: 'HelloWorld', props: { msg: String }, setup() { const store = useStore(); let count = computed(() => store.state.count); // 这里注意指定user模块 return { count, handleAdd: () => store.commit('increment', 2), handleMinus: () => store.commit('decrement', 3), handleAsyncAdd: () => { setTimeout(() => { store.commit('increment', 4) }) }, } } } vuex 的好处 能够在 Vuex 中集中管理共享的数据，易于开发和后期维护 能够高效的实现组件之间的数据共享，提高开发效率 存储在 Vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 什么样的数据适合存储到 Vuex 中 多个视图依赖于同一个状态：例如多组件之间数据共享，在不同页面都可以拿到用户信息 来自不同视图的行为需要改变同一个状态：比如用户会员信息，在不同页面可以更改 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/ssr/":{"url":"pages/vue/ssr/","title":"ssr","keywords":"","body":"SSR https://github.com/TOMGOU/vue-ssr-demo Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/diff/":{"url":"pages/vue/diff/","title":"diff","keywords":"","body":"vue-diff 算法 vue2.0 【如图，上面的节点为旧节点，下面的为新节点，diff 算法的本质就是比较两个数组的不同，从而只更新不同的地方：旧节点没有而新节点有就新增，旧节点有而新节点没有就删除】 step-1: 首先从新旧两个数组的起始位置开始比较，如果有相同节点（a = a），则移动指针。 step-2: 两个数组的起始位置找不到相同的节点（b != f），则从数组的尾部位置开始比较（g = g）。 step-3: 头头比较，尾尾比较都找不到相同的节点，则头尾比较（b = b）。 step-4: 头尾比较找不到相同的节点（c != i），则尾头比较（f = f）。 step-5: 头头比较，尾尾比较，头尾比较，头尾比较都找不到相同的节点，则给旧数组剩余的节点创建 key 值到下标的映射表（oldKeyIndex = {c: 2, d: 3, e: 4}），然后遍历新数组剩余的节点，如果对应节点的映射存在（oldKeyIndex[d]），则将旧数组对应节点设置为 undefined。 step-6: 继续遍历，oldKeyIndex[h]不存在，则新增这个节点。 step-7: 循环结束的条件：新节点数组的newStartIndex > newEndIndex，此时旧节点数组还存在的直接删除。 vue3.0 第一步和第二步与 vue2.0 完全相同，不进行头头比较和头尾比较，直接寻找最长递增子序列，最大程度保留相对顺序没有改变的元素位置，只对剩余元素进行移位。 最长递增子序列 leetcode 题目：https://leetcode.cn/problems/longest-increasing-subsequence/ 动态规划解法如下： /** * @param {number[]} nums * @return {number} */ var lengthOfLIS = function(nums) { if (nums.length === 0) { return 0 } const dp = new Array(nums.length).fill(1) for (let i = 1; i nums[j]) { dp[i] = Math.max(dp[j] + 1, dp[i]) } } } return Math.max(...dp) }; vue3.0 diff 算法求最长递增子序列源码 输入参数[11，3，5，9，7]，执行函数返回的结果为[1，2，4] getSequence([11，3，5，9，7]) => [1，2，4] function getSequence(arr) { const p = arr.slice() // 拷贝原始数据并保存 const result = [0] // 存储最长增长子序列的索引数组 let i, j, u, v, c const len = arr.length for (i = 0; i arr[j], 当前值比最后一项还大，可以直接push到索引数组(result)中去 p[i] = j // p记录第i个位置的索引变为j result.push(i) continue } u = 0 // 数组的第一项 v = result.length - 1 // 数组的最后一项 while (u 0) { p[i] = result[u - 1] // 记录修改的索引 } result[u] = i // 更新索引数组(result) } } } u = result.length v = result[u - 1] //把u值赋给result while (u-- > 0) { // 最后通过p数组对result数组进行进行修订，取得正确的索引 result[u] = v v = p[v]; } return result } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/reactive/":{"url":"pages/vue/reactive/","title":"reactive","keywords":"","body":"vue-reactive Observer 劫持 data 中的数据，get 的时候，向 Dep 中订阅 Watcher，set 的时候，让 Dep 调用notify 事件发布消息触发 Watcher 中的 update 方法 ，更新绑定了对应 data 数据的 dom。Compiler 主要负责解析 vue 特有的一些指令，比如： v-model、@click，Watcher 就是在 Compiler 的构造函数中实例化的。 Observer 主要目的是劫持 data 中的数据。 Dep 负责依赖的搜集。 Compile 是编译模板中的信息，比如指令。 Watcher 是 data 数据与 dom 元素连接的桥梁。 vue2.0 Object.defineProperty export class Vue { constructor(options = {}) { this.$options = options this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el this.$data = options.data this.$methods = options.methods this.proxy(this.$data) // observer 拦截 this.$data new Observer(this.$data) new Compiler(this) } // 代理一下，this.$data.xxx -> this.xxx proxy(data) { Object.keys(data).forEach(key => { // this Object.defineProperty(this, key, { enumerable: true, configurable: true, get() { return data[key] }, set(newValue) { // NaN !== NaN if (data[key] === newValue || __isNaN(data[key], newValue)) return data[key] = newValue } }) }) } } function __isNaN(a, b) { return Number.isNaN(a) && Number.isNaN(b) } class Dep { constructor() { this.deps = new Set() } add(dep) { if (dep && dep.update) this.deps.add(dep) } notify() { this.deps.forEach(dep => dep.update()) } } // html -> {{ count }} -> compiler 发现有 {{ count }} // -> new Watcher(vm, 'count', () => renderToView(count)) -> count getter 被触发 // -> dep.add(watcher实例) -> this.count++ -> count setter -> dep.notify // -> () => renderToView(count) -> 页面就变了 class Watcher { // vm - Vue 实例 constructor(vm, key, cb) { this.vm = vm this.key = key this.cb = cb // 在我们今天的列子里面，就是绘制数据到页面 // window.watcher = this Dep.target = this this.__old = vm[key] // 存下了初始值，触发 getter Dep.target = null } update() { let newValue = this.vm[this.key] if (this.__old === newValue || __isNaN(newValue, this.__old)) return this.cb(newValue) } } class Observer { constructor(data) { this.walk(data) } walk(data) { if (!data || typeof data !== 'object') return Object.keys(data).forEach(key => this.defineReactive(data, key, data[key])) } defineReactive(obj, key, value) { let that = this this.walk(value) let dep = new Dep() Object.defineProperty(obj, key, { configurable: true, enumerable: true, get() { // Watcher 实例 Dep.target && dep.add(Dep.target) return value }, set(newValue) { if (value === newValue || __isNaN(value, newValue)) return value = newValue that.walk(newValue) dep.notify() } }) } } class Compiler { constructor(vm) { this.el = vm.$el this.vm = vm this.methods = vm.$methods this.compile(vm.$el) } compile(el) { let childNodes = el.childNodes // 类数组 Array.from(childNodes).forEach(node => { if (this.isTextNode(node)) { this.compileText(node) } else if (this.isElementNode(node)) { this.compileElement(node) } if (node.childNodes && node.childNodes.length) this.compile(node) // ... }) } // compileElement(node) { if (node.attributes.length) { Array.from(node.attributes).forEach(attr => { let attrName = attr.name if (this.isDirective(attrName)) { // v-on:click v-model attrName = attrName.indexOf(':') > -1 ? attrName.substr(5) : attrName.substr(2) let key = attr.value this.update(node, key, attrName, this.vm[key]) } // ... }) } } update(node, key, attrName, value) { if (attrName === 'text') { node.textContent = value new Watcher(this.vm, key, val => node.textContent = val) } else if (attrName === 'model') { node.value = value new Watcher(this.vm, key, val => node.value = val) node.addEventListener('input', () => { this.vm[key] = node.value }) } else if (attrName === 'click') { node.addEventListener(attrName, this.methods[key].bind(this.vm)) } // .... } // 'this is {{ count }}' compileText(node) { let reg = /\\{\\{(.+?)\\}\\}/ let value = node.textContent if (reg.test(value)) { let key = RegExp.$1.trim() node.textContent = value.replace(reg, this.vm[key]) new Watcher(this.vm, key, val => { node.textContent = val }) } } isDirective(str) { return str.startsWith('v-') } isElementNode(node) { return node.nodeType === 1 } isTextNode(node) { return node.nodeType === 3 } } Document import { Vue } from './index.js' let vm = new Vue({ el: '#app', data: { msg: 'Hello Vue2.x', count: 666 }, methods: { increase() { this.count++ } } }) {{ msg }} {{ count }} v-text v-model 按钮 Object.defineProperty(obj, key, handler) 对象遍历方法：Reflect.ownKeys(obj) / Object.keys() 递归模板：首先是终止条件 const render = (key, val) => { console.log(`SET key=${key} val=${val}`) } const reactive = (obj) => { // 递归终止条件 if (Object.prototype.toString.call(obj) !== '[object Object]') { return } Reflect.ownKeys(obj).forEach(key => { let val = obj[key] // 下探到下一层 reactive(val) // 当前层逻辑处理 Object.defineProperty(obj, key, { get() { return val }, set(newVal) { if (val !== newVal) { val = newVal render(key, val) } } }) }) } const data = { a: 1, b: 2, c: { c1: { d: 99 }, c2: 3 } } reactive(data1) data.a = 5 data.c.c2 = 6 data.c.c1.d = 7 数组的处理 改写数组原型方法：arr.proto === Array.prototype 数组原型方法不能使用箭头函数 数组的判断方法：Object.prototype.toString.call(arr) === '[object Array]' const render = (method, ...val) => { console.log(`method:${method}-val:${val}`) } const reactive = (arr) => { // 原来的数组原型方法 const arrPrototype = Array.prototype // 创建新的数组原型方法 const newArrPrototype = Object.create(arrPrototype) const methods = ['push', 'pop', 'unshift', 'shift', 'splice', 'sort', 'reverse'] // 改写新的数组原型方法 methods.forEach(method => { newArrPrototype[method] = function() { arrPrototype[method].call(this, ...arguments) render(method, ...arguments) } }) if (Object.prototype.toString.call(arr) !== '[object Array]') return // 用新的数组原型方法替换实例旧的原型方法 arr.__proto__ === Array.prototype arr.__proto__ = newArrPrototype } data = [1, 2, 3, 4] reactive(data) data.push(5) data.splice(0, 2) data.reverse() data.sort((a, b) => a - b) vue3.0 proxy + composition-api vue3.0 的数据双向绑定，从 reactive 说起，触发 get 的时候，订阅依赖，触发 set 和 delete 的时候，发布依赖，依赖的收集本质还是发布订阅模式。 const reactive = (data) => { return new Proxy(data, { get(target, key, receiver) { const ret = Reflect.get(target, key, receiver) console.log('get', key) // 此处订阅依赖，调用 track(target, key) return ret }, set(target, key, val, receiver) { Reflect.set(target, key, val, receiver) console.log('set', key, val) // 此处发布依赖，调用 trigger(target, key) return true }, deleteProperty(target, key, receiver) { const ret = Reflect.deleteProperty(target, key, receiver) console.log('delete', key) // 此处也是发布依赖，调用 trigger(target, key)，相当于 dep.notify() return ret } }) } new Proxy(obj, handler) handler 个方法对应的参数：target、key、value、receiver Reflect.get(target, key, receiver) Reflect.set(target, key, val, receiver) Reflect.deleteProperty(target, key) const observableStore = new Map() const makeObservable = (target) => { let handleName = Symbol('handle') observableStore.set(handleName, []) target.observe = function(handler) { observableStore.get(handleName).push(handler) } const proxyHandler = { get(target, key, receiver) { observableStore.get(handleName).forEach(handler => handler('GET', key, target[key])) // 懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听 if (typeof target[key] === 'object' && target[key] !== null) { return new Proxy(target[key], proxyHandler) } return Reflect.get(target, key, receiver) }, set(target, key, val, receiver) { observableStore.get(handleName).forEach(handler => handler('SET', key, val)) Reflect.set(target, key, val, receiver) }, deleteProperty(target, key) { observableStore.get(handleName).forEach(handler => handler('DELETE', key, target[key])) Reflect.deleteProperty(target, key) } } return new Proxy(target, proxyHandler) } let user = { a: { b: 1 } } user = makeObservable(user) user.observe((action, key, value) => { console.log(`${action} key=${key} value=${value}`) }) user.name = 'Tommy' console.log(user.name) delete user.name console.log(user.a.b) console.log(user.a) user.a.b = 2 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/eventEmitter/":{"url":"pages/vue/eventEmitter/","title":"eventBus","keywords":"","body":"EventEmitter 发布订阅模式 Vue里面用过eventBus作为通信，方式，实现方式是用Vue函数的$on/$emit方法。 类似 node 中的 events 模块下面的 EventEmitter 类 这种方式可以叫做发布订阅模式 class MyEventEmitter { constructor() { this.events = {} } on (event, cbFn) { if (!this.events[event]) { this.events[event] = [] } this.events[event].push(cbFn) return this } off (event, cbFn) { if (!cbFn) { this.events[event] = [] return this } if (this.events[event]) { this.events[event] = this.events[event].filter(item => item !== cbFn) } return this } once (event, cbFn) { const onceFn = () => { cbFn.apply(this, arguments) this.off(event, onceFn) } this.on(event, onceFn) return this } emit (event, ...args) { if (this.events[event]) { this.events[event].forEach(item => item.call(this, ...args)) } } } // test const myEvent = new MyEventEmitter() myEvent.on('test1', () => { console.log('test-11') }).once('test2', () => { console.log('test-22') }) myEvent.emit('test1') myEvent.emit('test2') myEvent.emit('test2') class EventBus { constructor () { this.events = new Map() } on(event, cbFn) { if (!this.events.has(event)) this.events.set(event, new Set()) this.events.get(event).add(cbFn) return this } off(event, cbFn) { if (!cbFn) { this.events.delete(event) return this } if (this.events.has(event)) { this.events.get(event).delete(cbFn) } return this } once(event, cbFn) { const onceFn = () => { cbFn.call(this) this.off(event, onceFn) } this.on(event, onceFn) return this } emit(event, ...args) { if (this.events.has(event)) { this.events.get(event).forEach(item => { item.apply(this, args) }); } } } const bus = new EventBus() const fn = (...args) => console.log('t1', ...args) const fn2 = (...args) => console.log('t2', ...args) bus.on('t1', fn).once('t2', fn2) bus.off('t1', fn) bus.emit('t1', 1, 2) bus.emit('t2') bus.emit('t2') 细节注意点 返回 this 是为了链式调用 on 方法需要考虑首次添加事件 this.events[event] 不存在，直接复制空数组 off 方法中的 filter 方法不会改变原数组的值，所以需要重新赋值：this.events[event] = this.events[event].filter(item => item !== cbFn) off 方法分两种情况：1. this.off(event), 直接清空数组; 2. this.off(event, cbFn), 只删除对应的事件 once 方法的实现思路：对 cbFn 事件进行包裹，内部执行 cbFn 函数后，立即接触事件绑定（off 方法），然后对包裹后函数进行事件绑定，即调用 on 方法 emit 方法要考虑两种特殊情况： event 不存在，从未绑定过，所以需要先判断 this.events[event] 是否存在，否者报错。 调用 emit 的时候，也可能要传递参数，比如：我们调用 on 方法的时候，cbFn 是带参数的。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-01 15:27:44 "},"pages/vue/nextTick/":{"url":"pages/vue/nextTick/","title":"nextTick","keywords":"","body":"nextTick 应用场景 需要在视图更新之后，基于新的视图进行操作 点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点 handleShow(){ this.showit = true //修改 v-show document.getElementById(\"keywords\").focus() //在第一个 tick 里，获取不到输入框，自然也获取不到焦点 } 修改为： handleShow(){ this.showit = true this.$nextTick(function () { // DOM 更新了 document.getElementById(\"keywords\").focus() }) } 点击获取元素宽度 {{ message }} 获取p元素宽度 getMyWidth() { this.showMe = true; //this.message = this.$refs.myWidth.offsetWidth; //报错 TypeError: this.$refs.myWidth is undefined this.$nextTick(()=>{ //dom元素更新后执行，此时能拿到p元素的属性 this.message = this.$refs.myWidth.offsetWidth; }) } 原理 源码 【vue / src / core / util / next-tick.js 42行】 if (typeof Promise !== 'undefined' && isNative(Promise)) { const p = Promise.resolve() timerFunc = () => { p.then(flushCallbacks) if (isIOS) setTimeout(noop) } isUsingMicroTask = true } else if (!isIE && typeof MutationObserver !== 'undefined' && ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]' )) { let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } isUsingMicroTask = true } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) { timerFunc = () => { setImmediate(flushCallbacks) } } else { timerFunc = () => { setTimeout(flushCallbacks, 0) } } 疑问一：源码中看到了 MutationObserver，vue 是用 MutationObserver 监听 dom 变化的吗？ 显然不是, MutationObserver 只是异步队列控制方式中的一种 疑问二：Promise、MutationObserver、setImmediate、setTimeout 为什么能监听 dom 更新？ 每次 event loop 的最后，会有一个 UI render 步骤，也就是更新 DOM。 其实，UI render 本身是一个宏任务。事件循环的初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。执行完script 脚本代码，再执行微任务，最后 UI render。然后进入下一次事件循环... 疑问三：Promise、MutationObserver、setImmediate、setTimeout 为什么要有这么多降级处理？ Promise：最优的 microtask 策略，是ES6新增的东西，存在兼容问题 MutationObserver: 是 HTML5 新增的特性，在 iOS 上尚有 bug setImmediate: 是 macrotask 最理想的方案了，可惜的是只有 IE 和 nodejs 支持 setTimeout: setTimeout执行的最小时间间隔是约4ms的样子，略微有点延迟。 疑问四：为什么不使用 queueMicrotask ？ 这货兼容性远不如 MutationObserver 结论：vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行 microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕 因为兼容性问题，vue 不得不做了 microtask 向 macrotask 的降级方案 Promise -> MutationObserver -> setImmediate -> setTimeout Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/decoration/":{"url":"pages/vue/decoration/","title":"decoration","keywords":"","body":"修饰符 从事件的捕获与冒泡说起。 addEventListener 第一个参数表示：第一个表示触发条件，比如 'click'、'hashchange' 第二个参数表示：触发事件 第三个参数表示：事件出发的时机，默认为 false，在冒泡阶段触发 true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 .capture 修饰符 元素点击事件的触发分为两个阶段：捕获阶段和冒泡阶段。 不加 .capture 修饰符，相当于 addEventListener 的第三个参数为 false, 在冒泡阶段触发事件。 添加 .capture 修饰符，相当于 addEventListener 的第三个参数为 true, 在捕获阶段触发事件。 事件修饰符 .stop: 阻止冒泡事件，相当于 .preventDefault() .prevent 阻止默认事件 .self 只有在 event.target 是当前元素自身时，才触发处理函数 .once 只执行一次 .passive 提升移动端的性能 在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符 .native 自定义组件上绑定原生事件 自定义组件内部只能使用 vm.$emit 触发的事件。只有加了 .native 修饰符才能使用原生事件，否者报错。 其他修饰符 .sync 子组件内部改变 props 属性值并更新到父组件中 由于保持数据的单向性，从父组件传到子组件的数据，子组件如果修改了项目还可以运行浏览器上会报错，加上.sync后子组件内部改变props属性值并更新到父组件中 .lazy 提升输入框输入性能 v-model 双向数据绑定，输入框输入内容时视图就更新了，如果想要输入完所有东西，光标离开才更新视图 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/vue3/":{"url":"pages/vue/vue3/","title":"vue3新特性","keywords":"","body":"vue3 的新特性 组合式 API: ref & reactive & onMounted & watch & computed & toRefs // src/components/UserRepositories.vue `setup` function import { fetchUserRepositories } from '@/api/repositories' import { ref, onMounted, watch, toRefs, computed } from 'vue' // 在我们的组件中 setup (props) { // 使用 `toRefs` 创建对 props 中的 `user` property 的响应式引用 const { user } = toRefs(props) const repositories = ref([]) const getUserRepositories = async () => { // 更新 `props.user ` 到 `user.value` 访问引用值 repositories.value = await fetchUserRepositories(user.value) } onMounted(getUserRepositories) // 在 user prop 的响应式引用上设置一个侦听器 watch(user, getUserRepositories) const searchQuery = ref('') const repositoriesMatchingSearchQuery = computed(() => { return repositories.value.filter( repository => repository.name.includes(searchQuery.value) ) }) return { repositories, getUserRepositories, searchQuery, repositoriesMatchingSearchQuery } } script setup defineProps & defineEmits directive 指令 defineExpose useSlots & useAttrs v-model: 现在可以在同一个自定义组件上使用多个 v-model 绑定； 创建自定义渲染器: import { createRenderer } from '@vue/runtime-core' v-bind hello export default { data() { return { color: 'red' } } } .text { color: v-bind(color); } SFC /* deep selectors */ ::v-deep(.foo) {} /* shorthand */ :deep(.foo) {} /* targeting slot content */ ::v-slotted(.foo) {} /* shorthand */ :slotted(.foo) {} /* one-off global rule */ ::v-global(.foo) {} /* shorthand */ :global(.foo) {} Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/dom/":{"url":"pages/vue/dom/","title":"虚拟dom","keywords":"","body":"Vue 虚拟dom VS React fiber Vue 虚拟dom 对真实 dom 的抽象，用嵌套对象表示，用属性来描述节点，最终通过一系列的操作映射到真实 dom 上 优点： 保证性能的下限 无需手动操作真实 dom 跨平台 缺点： 首次渲染大量的 dom 的时候，会比 innerHTML 的插入速度慢，因为多家了一层虚拟 dom。 class VNnode { //构造函数 //一个节点会有标签（tag）属性（props）value，标签类型 constructor(tag, props, value, type) { //标签名转小写 this.tag = tag && tag.toLowerCase() this.props= props this.value = value this.type = type this.children = [] } //追加子元素 appendChild(vnode) { this.children.push(vnode) } } 虚拟 dom 简单模拟 文本节点的创建：document.createTextNode() 元素的创建：document.createElement() 元素的插入：element.appendChild() 元素属性的设置：element.setAttribute(key, val) const vnode = { tag: 'div', props: { id: 'app', className: 'container' }, children: [ { tag: 'p', props: { id: 'text1', className: 'text' }, children: ['123'] }, { tag: 'p', props: { id: 'text2', className: 'text' }, children: ['456'] } ] } const render = (vnode) => { if (typeof vnode === 'number') { return String(vnode) } if (typeof vnode === 'string') { return document.createTextNode(vnode) } const element = document.createElement(vnode.tag) if (vnode.props) { Object.keys(vnode.props).forEach(key => { if (key === 'className') { element.setAttribute('class', vnode.props[key]) } else { element.setAttribute(key, vnode.props[key]) } }) } if (vnode.children) { vnode.children.forEach(childNode => { element.appendChild(render(childNode)) }) } return element } console.log(render(vnode)) React fiber function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) { // 作为静态数据结构的属性 this.tag = tag; this.key = key; this.elementType = null; this.type = null; this.stateNode = null; // 用于连接其他Fiber节点形成Fiber树 this.return = null; this.child = null; this.sibling = null; this.index = 0; this.ref = null; // 作为动态的工作单元的属性 this.pendingProps = pendingProps; this.memoizedProps = null; this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; this.effectTag = NoEffect; this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // 调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; } Vue 虚拟dom VS React fiber 差异 Vue 虚拟 dom 只有一个数组类型的 children 属性指向孩子节点，而 React fiber 有 return 指向父节点，child 指向孩子节点，sibling 指向最近的兄弟节点。 从本质上来说，Vue 虚拟 dom 是树，React fiber 不仅是一棵树还是双向链表。 requestIdleCallback React 没有依赖收集，数据更新有瓶颈，需要利用浏览器的空闲时间来 React 放弃使用 requestIdleCallback： 浏览器兼容性 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的 requestIdleCallback 触发的频率会变得很低 基于以上原因，React 实现了功能更完备的 requestIdleCallback polyfill，这就是 Scheduler。 const workLoop = (deadLine) => { let shouldYield = false;// 是否该让出线程 while(!shouldYield){ console.log('working') // 遍历节点等工作 shouldYield = deadLine.timeRemaining() 双缓存技术 ... Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/vue/communication/":{"url":"pages/vue/communication/","title":"组件传值","keywords":"","body":"组件通讯 父子组件：props + $emit 兄弟组件： eventBus $parent + $children ref + $refs 其他 vuex + redux url query localStorage + sessionStorage Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/":{"url":"pages/react/","title":"React","keywords":"","body":"React 疑问 Context props 传递 Ref 转发 与 HOC 不要在 render 方法中使用 HOC ? 生命周期函数 生成期 组件将要挂载时触发的函数：componentWillMount 组件挂载完成时触发的函数：componentDidMount 存在期 父组件中改变了props传值时触发的函数：componentWillReceiveProps 是否要更新数据时触发的函数：shouldComponentUpdate 将要更新数据时触发的函数：componentWillUpdate 数据更新完成时触发的函数：componentDidUpdate 销毁期 组件将要销毁时触发的函数：componentWillUnmount fiber 不可变数据集：immer 合成事件 渲染器 并发渲染 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/umiProComponents/":{"url":"pages/react/umiProComponents/","title":"umi + proComponents","keywords":"","body":"umi + proComponents https://umijs.org/docs/max/layout-menu https://procomponents.ant.design/components/layout Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/context/":{"url":"pages/react/context/","title":"context","keywords":"","body":"Context Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 react-router 和 react-redux 中都运用了 Context, 阅读源码必备。 context 的基本用法 step-1: 使用React的Context API，在组件外部建立一个Context。 import { createContext } from 'react'; const TestContext = createContext({}); export default TestContext; step-2: 父组件中使用 Context.Provider 注入数据。 import React, { Component } from 'react' import TestContext from '../context' import Sub from '../components/Sub' export default class Home extends Component { render() { return ( ) } } step-3: 子组件中使用 Context.consumer 使用数据。 import React, { Component } from 'react' import TestContext from '../context' export default class Sub extends Component { render() { return ( {info => {info.userName}} ) } } useContext 的基本用法 step-1: 使用React的Context API，在组件外部建立一个Context。 import { createContext } from 'react'; const TestContext = createContext({}); export default TestContext; step-2: 父组件中使用 Context.Provider 注入数据。 import React, { Component } from 'react' import TestContext from '../context' import Sub from '../components/Sub' export default class Home extends Component { render() { return ( ) } } step-3: 子组件中使用 Context.consumer 使用数据。 import React, { useContext } from 'react' import TestContext from '../context' function Sub () { const { userName } = useContext(TestContext) return {userName} } export default Sub Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/reactRouter/":{"url":"pages/react/reactRouter/","title":"react-router","keywords":"","body":"react-router react-router-dom 对 react-router 进行了进一步封装，一般直接使用 react-router-dom context useContext getUserConfirmation => cb(true) ？？ prompt react-router 的基本使用 BrowserRouter/HashRouter/MemoryRouter Link Route Switch Redirect import React, { Suspense, lazy } from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom'; import './index.css'; const routes = [ { path: \"/\", title: \"首页\", props: {exact: true}, component: lazy(() => import('./pages/Home')) }, { path: \"/about\", title: \"关于\", component: lazy(() => import('./pages/About')) }, { path: \"/detail/:id\", title: \"详情\", component: lazy(() => import('./pages/Detail')) }, { path: \"/memo\", title: \"记忆\", component: lazy(() => import('./pages/Memo')) }, { path: \"/dialog\", title: \"弹窗\", component: lazy(() => import('./pages/DialogDemo')) } ]; ReactDOM.render( Home About Detail Memo Dialog Loading...}> {routes.map(item => { return ( ) })} , document.getElementById('root') ); hash 与 history react-router 源码实现 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/reactRedux/":{"url":"pages/react/reactRedux/","title":"react-redux","keywords":"","body":"react-redux 1. redux 的基本用法 step-1: 利用 createStore 创建 store 数据 redux-thunk 的作用：使 dispatch 支持传函数参数。 countReducer 函数最重要的特征是，它是一个纯函数。 import {createStore, applyMiddleware} from 'redux' import thunk from \"redux-thunk\" const countReducer = (state = { number: 100 }, {type, payLoad}) => { switch(type) { case 'ADD': return { ...state, number: state.number + payLoad } case 'MINUS': return { ...state, number: state.number - payLoad } default: return state } } export const store = createStore(countReducer, applyMiddleware(thunk)) export const subscribe = store.subscribe export const dispatch = store.dispatch export const getState = store.getState step-2: 利用 subscribe, dispatch, getState 操作 store 数据 subscribe 的时候，为什么要调用 this.forceUpdate() ？ import React, { Component } from 'react' import { subscribe, dispatch, getState } from \"./store\" export default class App extends Component { componentDidMount() { subscribe(() => { this.forceUpdate() }) } add() { dispatch({ type: 'ADD', payLoad: 2 }) } minus() { dispatch({ type: 'MINUS', payLoad: 1 }) } asyAdd() { dispatch(dispatch => { setTimeout(() => { dispatch({ type: 'ADD', payLoad: 3 }) }, 2000) }) } render() { const {number} = getState() return ( ReduxPage {number} add minus asyAdd ); } } 2. react-redux 的基本用法 step-1: 利用 createStore 创建 store 数据 import {createStore} from \"redux\"; function countReducer(state = 0, action) { switch (action.type) { case \"ADD\": return state + action.num; case \"MINUS\": return state - action.num; default: return state; } } const store = createStore(countReducer); export default store; step-2: 利用 Provider 全局挂载 store 数据 import React from 'react'; import ReactDOM from 'react-dom'; import App from './pages/App'; import { Provider } from 'react-redux'; import store from './store'; ReactDOM.render( , document.getElementById('root') ); step-3: 利用 connect 连接 store 数据 import React, {Component} from \"react\"; import {connect} from \"react-redux\"; import {bindActionCreators} from \"redux\"; export default connect( state => ({count: state}), dispatch => { let res = { add: () => ({type: \"ADD\", num: 2}), minus: () => ({type: \"MINUS\", num: 2}) }; res = bindActionCreators(res, dispatch); return { dispatch, ...res }; } )( class App extends Component { render() { console.log(this.props) const {count, dispatch, msg, add, minus} = this.props; return ( ReactReduxPage {count} {msg} dispatch({type: \"ADD\", num: 2})}> add use dispatch add minus ) } } ); 3. redux 源码 3.1 compose 函数 function compose(...funcs) { if (funcs.length === 0) { return arg => arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reverse().reduce((a, b) => args => a(b(args))); } // 测试 function f1(arg) { console.log(\"f1\", arg); return arg; } function f2(arg) { console.log(\"f2\", arg); return arg; } function f3(arg) { console.log(\"f3\", arg); return arg; } let res = compose(f1, f2, f3)(\"omg\"); 3.2 createStore 源码 export function createStore(reducer, enhancer) { if (enhancer) { return enhancer(createStore)(reducer); } let currentState = undefined; let currentListeners = []; function getState() { return currentState; } function dispatch(action) { currentState = reducer(currentState, action); // 监听函数是一个数组 currentListeners.map(listener => listener()); } //订阅，可以多次订阅 function subscribe(listener) { // 每次订阅，把回调放入回调数组 currentListeners.push(listener); } // 取值的时候，注意一定要保证不和项目中的会重复 dispatch({type: \"@INIT/REDUX-KKB\"}); return { getState, dispatch, subscribe }; } 3.3 applyMiddleware 源码 export function applyMiddleware(...middlewares) { return createStore => (...args) => { const store = createStore(...args); let dispatch = store.dispatch; const middleApi = { getState: store.getState, dispatch }; const middlewaresChain = middlewares.map(middleware => middleware(middleApi) ); dispatch = compose(...middlewaresChain)(dispatch); return { ...store, dispatch }; }; } function compose(...funcs) { if (funcs.length === 0) { return arg => arg; } if (funcs.length === 1) { return funcs[0]; } return funcs.reverse.reduce((a, b) => (...args) => a(b(...args))); } 3.4 redux-thunk 源码 目的：为了让 dispatch 能够把函数作为参数进行传递。 function thunk({getState, dispatch}) { return dispatch => action => { // action 可以是对象也可以是函数 if (typeof action === \"function\") { return action(dispatch, getState); } else { return dispatch(action); } }; } vuex 与 redux 的区别 redux 中有三个基本概念：Actions、Reducer、Store；vuex 中有三个基本概念：Actions、Mutations、Store。 vuex 以 mutations 变化函数取代 reducer，无需 switch，只需在对应的 mutation 函数里改变 state 值即可。 redux 的几个方法： 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器。 vuex 的几个方法： 提供 getters 方法获取 state； 提供 dispatch(actions) 方法更新 state； 由于 vue 自动重新渲染的特性，无需订阅重新渲染函数。 redux 的 action 中发送过来的对象 必须有一个type属性 reducer 他是一个纯函数 他会跟action发送过来的type类型做逻辑上的处理（使用switch方法进行判断） redux 的 Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出，不能调用系统 I/O 的 API 不能调用 Date.now() 或者 Math.random() 等不纯的方法。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/hooks/":{"url":"pages/react/hooks/","title":"hooks","keywords":"","body":"Hooks Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。 Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。 常用的 hook: useState/useEffect/useContext/useMemo/useReducer/useCallback/useRef/... useMemo useMemo 是 React 提供的一个 Hook，用于在函数组件中进行记忆化计算。它接收一个依赖数组和一个回调函数，并返回计算结果。 useMemo 的作用是在依赖数组中的值发生变化时，才重新计算结果并返回；如果依赖数组中的值没有变化，则直接返回上一次的计算结果。 可以模拟 vue 中的 computed 计算属性 import { useState, useMemo } from 'react' function Memo () { const [firstName, setFirstName] = useState('Kobe') const [lastName, setLastName] = useState('Bryant') const fullName = useMemo(() => `${firstName}-${lastName}`, [firstName, lastName]) return ( setFirstName('James')}>{firstName} setLastName('Harden')}>{lastName} {fullName} ) } export default Memo; useRef useRef 是 React 提供的一个 Hook，用于创建一个可持久化的引用。 使用 useRef 可以在函数组件中创建一个引用，并在组件的多次渲染之间保持引用的稳定性。它返回一个可变的 ref 对象，其中的 .current 属性可以被赋值为任意值。 import React, { useRef } from 'react'; function ExampleComponent() { const inputRef = useRef(null); const handleClick = () => { // 使用 ref 引用的 DOM 元素或其他值 console.log(inputRef.current.value); }; return ( Log Input Value ); } useEffect useEffect 是 React 提供的一个 Hook，用于在函数组件中执行副作用操作，例如订阅事件、请求数据、操作 DOM 等。它可以看作是类组件中的生命周期方法 componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合。 useEffect 接收两个参数：一个副作用函数和一个依赖数组。副作用函数用于执行实际的副作用操作，依赖数组用于指定该副作用函数的依赖项。 import React, { useEffect } from 'react'; function ExampleComponent() { useEffect(() => { // 在组件挂载时执行副作用操作 console.log('Component mounted'); // 在组件卸载时执行清理操作 return () => { console.log('Component unmounted'); }; }, []); return Example Component; } useCallback useCallback 是 React 的一个 Hook 函数，用于在组件中缓存回调函数。它的作用是优化性能，避免不必要的函数重新创建。 import React, { useCallback } from 'react'; const MyComponent = () => { const handleClick = useCallback(() => { console.log('Button clicked!'); }, []); return Click me; }; useContext useContext 是 React 的一个 Hook 函数，用于在函数组件中访问上下文（context）中的值。 import React, { useContext } from 'react'; // 创建一个上下文对象 const MyContext = React.createContext(); const ParentComponent = () => { const value = 'Hello, world!'; return ( ); }; const ChildComponent = () => { const value = useContext(MyContext); return {value}; }; useImperativeHandle useImperativeHandle 是 React 中的一个 Hook，它允许您向父组件暴露子组件的某些功能或方法，通常用于封装和控制子组件的外部行为。这可以帮助您在父组件中直接操作子组件，而不需要通过 ref 来访问子组件的 DOM 或实例。 useImperativeHandle 的作用是在子组件中定义一个接口，以便向父组件公开特定的方法或属性。这样父组件就可以通过子组件的 ref 来访问这些方法或属性。 import React, { useRef, forwardRef, useImperativeHandle } from 'react'; // 子组件 const ChildComponent = forwardRef((props, ref) => { const inputRef = useRef(); // 在子组件中定义要暴露给父组件的方法 useImperativeHandle(ref, () => ({ focusInput: () => { inputRef.current.focus(); }, getInputValue: () => { return inputRef.current.value; } })); return ; }); // 父组件 function ParentComponent() { const childRef = useRef(null); const handleButtonClick = () => { childRef.current.focusInput(); const inputValue = childRef.current.getInputValue(); console.log('Input Value:', inputValue); }; return ( Focus Input ); } export default ParentComponent useTransition useTransition 是一个用于处理渲染过程中的状态转换的 Hook。它可以让我们在组件更新时添加一个延迟，以便在完成数据加载之前保持用户界面的稳定性。在数据加载完成后，React 会将组件更新为最新状态。 非常适用于以下场景： 数据加载：在数据加载过程中，我们可以使用 useTransition 在更新 UI 之前显示一个加载指示器，从而优化用户体验。 动画和过渡效果：在组件状态更新时，useTransition 可以让我们更好地控制动画和过渡效果的触发时机。 import { useState, useEffect, useTransition } from 'react'; function SearchComponent() { const [query, setQuery] = useState(''); const [results, setResults] = useState([]); const [startTransition, isPending] = useTransition(); useEffect(() => { if (query !== '') { // 模拟 API 请求 const fetchData = async () => { const response = await fetch(`https://api.example.com/search?q=${query}`); const data = await response.json(); return data; }; startTransition(async () => { const data = await fetchData(); setResults(data); }); } else { setResults([]); } }, [query, startTransition]); return ( setQuery(e.target.value)} placeholder=\"Search...\" /> {isPending ? ( Loading... ) : ( {results.map((result) => ( {result.name} ))} )} ); } useDeferredValue useDeferredValue 是一个用于控制组件更新优先级的 Hook。它可以让我们将某个值的更新推迟到更合适的时机，从而避免在高优先级任务执行期间进行不必要的渲染。 可以应用于以下场景： 用户输入：在处理实时搜索、自动完成等与用户输入相关的功能时，我们可以使用 useDeferredValue 来确保输入框在用户输入过程中保持流畅，同时在合适的时机更新相关组件。 列表和大型数据集：当需要处理大量数据时，useDeferredValue 可以帮助我们控制渲染的优先级，从而避免阻塞用户界面。例如，在分页加载数据的情况下，我们可以使用 useDeferredValue 在高优先级任务完成后再更新数据列表。 import { useState, useEffect, useDeferredValue } from 'react'; function LiveSearchComponent() { const [query, setQuery] = useState(''); const [results, setResults] = useState([]); const deferredQuery = useDeferredValue(query, { timeoutMs: 200 }); useEffect(() => { if (deferredQuery !== '') { // 模拟 API 请求 const fetchData = async () => { const response = await fetch(`https://api.example.com/search?q=${deferredQuery}`); const data = await response.json(); return data; }; fetchData().then((data) => { setResults(data); }); } else { setResults([]); } }, [deferredQuery]); return ( setQuery(e.target.value)} placeholder=\"Search...\" /> {results.map((result) => ( {result.name} ))} ); } useState 源码 function useState(initialState) { let hook; if (isMount) { hook = { queue: { pending: null }, memoizedState: initialState, next: null } if (!fiber.memoizedState) { fiber.memoizedState = hook; } else { workInProgressHook.next = hook; } workInProgressHook = hook; } else { hook = workInProgressHook; workInProgressHook = workInProgressHook.next; } let baseState = hook.memoizedState; if (hook.queue.pending) { let firstUpdate = hook.queue.pending.next; do { const action = firstUpdate.action; baseState = action(baseState); firstUpdate = firstUpdate.next; } while (firstUpdate !== hook.queue.pending) hook.queue.pending = null; } hook.memoizedState = baseState; return [baseState, dispatchAction.bind(null, hook.queue)]; } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 16:56:25 "},"pages/react/portal/":{"url":"pages/react/portal/","title":"portal","keywords":"","body":"portal Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。 ReactDOM.createPortal(child, container) createPortal 的基本使用 弹窗组件蒙层问题：注意关闭弹窗的时候将弹窗节点在生命周期 componentWillUnmount 中删除 // components/Dialog.js import React, { Component } from 'react' import {createPortal} from 'react-dom' export default class Dialog extends Component { constructor(props) { super(props) this.node = document.createElement(\"div\"); document.body.appendChild(this.node); } componentWillUnmount() { document.body.removeChild(this.node); } render() { return createPortal( Dialog {this.props.children} , this.node ) } } // 弹窗组件的使用 import React, { Component } from 'react' import Dialog from '../components/Dialog' export default class DialogDemo extends Component { constructor(props) { super(props) this.state = { showDialog: false } } handleDialogToggle = () => { this.setState({ showDialog: !this.state.showDialog }) } render() { const {showDialog} = this.state return ( Dialog-Toggle {showDialog && this is dialog content } ) } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/suspense/":{"url":"pages/react/suspense/","title":"suspense","keywords":"","body":"Suspense React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。 基本用法 import React, { Suspense, lazy } from 'react'; import ReactDOM from 'react-dom'; import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom'; import './index.css'; const routes = [ { path: \"/\", title: \"首页\", props: {exact: true}, component: lazy(() => import('./pages/Home')) }, { path: \"/about\", title: \"关于\", component: lazy(() => import('./pages/About')) }, { path: \"/detail/:id\", title: \"详情\", component: lazy(() => import('./pages/Detail')) }, { path: \"/memo\", title: \"记忆\", component: lazy(() => import('./pages/Memo')) }, { path: \"/dialog\", title: \"弹窗\", component: lazy(() => import('./pages/DialogDemo')) } ]; ReactDOM.render( Home About Detail Memo Dialog Loading...}> {routes.map(item => { return ( ) })} , document.getElementById('root') ); import React, { Suspense } from 'react'; const LazyComponent = React.lazy(() => import('./LazyComponent')); const App = () => { return ( My App Loading...}> ); }; 实现原理 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/react/sourceCode/":{"url":"pages/react/sourceCode/","title":"source-code","keywords":"","body":"React Source Code jsx React.createElement /** * schedule —> 把我的任务放进一个队列里，然后以某一种节奏进行执行； * */ // task 的任务队列 const queue = []; const threshold = 1000 / 60; const transtions = []; let deadline = 0; // 获取当前时间， bi date-now 精确 const now = () => performance.now(); // 时间 ，精确 // 从任务queue中，选择第一个 任务 const peek = arr => arr.length === 0 ? null : arr[0]; // schedule —> 把我的任务放进一个队列里，然后以某一种节奏进行执行； export function schedule (cb) { queue.push(cb); startTranstion(flush); } // 此时，是否应该交出执行权 function shouldYield() { return navigator.scheduling.isInputPending() || now() >= deadline; } // 执行权的切换 function startTranstion(cb) { transtions.push(cb) && postMessage(); } // 执行权的切换 const postMessage = (() => { const cb = () => transtions.splice(0, 1).forEach(c => c()); const { port1, port2 } = new MessageChannel(); port1.onmessage = cb; return () => port2.postMessage(null); })() // 模拟实现 requestIdleCallback 方法 function flush() { // 生成时间，用于判断 deadline = now() + threshold; let task = peek(queue); // 我还没有超出 16.666ms 同时，也没有更高的优先级打断我 while(task && !shouldYield()) { const { cb } = task; const next = cb(); // 相当于有一个约定，如果，你这个task 返回的是一个函数，那下一次，就从你这里接着跑 // 那如果 task 返回的不是函数，说明已经跑完了。不需要再从你这里跑了 if(next && typeof next === \"function\") { task.cb = next; } else { queue.shift() } task = peek(queue); } // 如果我的这一个时间片，执行完了，到了这里。 task && startTranstion(flush) } requestIdleCallback requestIdleCallback(RIC) 50毫秒问题 postMessage: messageChannel event-loop setTimeout: 有4到5秒的延迟 scheduler generator：无法从中间位置开始 web-worker： 无法处理 dom useTransition startTransition Future 流式渲染 server component Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-01 15:31:21 "},"pages/react/reactNative/":{"url":"pages/react/reactNative/","title":"react-native","keywords":"","body":"React Native 跨端解决方案(react-reconciler) ios / adr pc --> react-native-web wx --> remax rn 知识点 svg vs iconfont png jpg jpeg webp dpr/ppi/inch 数据状态管理：vuex/redux/mobx/dva iPhonex 适配 依赖包的版本锁定问题: 固定版本最好 { \"react\": \"15.2.1\", // 固定版本 \"react\": \"~15.2.1\", // 15.2.* \"react\": \"^15.2.1\", // 15.* } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/":{"url":"pages/threeJS/","title":"threeJS","keywords":"","body":"threeJS 基础知识 https://tomgou.github.io/3d-study-notes/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 17:38:42 "},"pages/threeJS/Math/":{"url":"pages/threeJS/Math/","title":"Math","keywords":"","body":"Math 数学相关 1.向量相关 基础知识 向量在图形学中的表示 向量可以用其次坐标来表示 A = \\begin{bmatrix} X\\\\ Y\\\\ \\end{bmatrix} 向量的转置 A^T = \\begin{bmatrix} X&Y\\\\ \\end{bmatrix} 向量长度的计算 ||\\vec A|| = \\sqrt{X^2+Y^2} 向量相加（add）: 平行四边形法则或者三角形法则 向量的运算 a.向量点乘（dot） \\vec a · \\vec b = ||\\vec a||||\\vec b||cos\\theta 向量点乘后得到的结果是一个数值 for 2D \\vec a · \\vec b = \\begin{bmatrix} x_a\\\\ y_a\\\\ \\end{bmatrix} · \\begin{bmatrix} x_b\\\\ y_b\\\\ \\end{bmatrix} = x_ax_b + y_ay_b for 3D \\vec a · \\vec b = \\begin{bmatrix} x_a\\\\ y_a\\\\ z_a\\\\ \\end{bmatrix} · \\begin{bmatrix} x_b\\\\ y_b\\\\ z_b\\\\ \\end{bmatrix} = x_ax_b + y_ay_by + z_az_b 几何意义: 表征或计算两个向量之间的夹角：如果向量 a 和 b 是单位向量，cos\\theta = \\vec a · \\vec b b 向量在 a 向量方向上的投影 向量点乘在图形学中的实际应用 计算两个向量的夹角：比如计算光照方向和物体表面之间的夹角 投影阴隐的计算 把一个向量分解为两个垂直方向上的向量 向量点乘的正负可以表示两个向量的方向是否接近：比如金属的高光反射，不接近就看不到反射的光。 向量点乘满足交化率结合律和分配率 b.向量叉乘（cross） \\vec a x \\vec b = ||\\vec a||||\\vec b||sin\\theta 向量点乘后得到的结果是一个向量 数字大小 \\vec a x \\vec b = \\begin{bmatrix} y_az_b - y_bz_a\\\\ z_ax_b - x_az_b\\\\ x_ay_b - y_ax_b\\\\ \\end{bmatrix} = \\begin{bmatrix} 0&-z_a&y_a\\\\ z_a&0&-x_a\\\\ -y_a&x_a&0\\\\ \\end{bmatrix}\\begin{bmatrix} x_b\\\\ y_b\\\\ z_b\\\\ \\end{bmatrix} 行列式推导过程：https://blog.csdn.net/qq_36286039/article/details/124141634 方向：右手螺旋定则 \\vec X x \\vec Y = +\\vec Z \\vec Y x \\vec X = -\\vec Z 几何意义 方向的意义：可以通过两个向量的叉乘，生成第三个垂直于a，b的法向量，从而构建X、Y、Z坐标系 数值的意义：在二维空间中，叉乘还有另外一个几何意义就是：aXb等于由向量a和向量b构成的平行四边形的面积。 向量点乘在图形学中的实际应用 判定左和右：比如判断向量 a 在向量 b 的左侧还是右侧 判定里和外：比如判断一个点是否在一个三角形的内部 面积计算：比如计算复杂几何体的表面积 向量点乘不满足交化率，但是满足结合律和分配率 2.矩阵相关 矩阵乘法口诀：左取行，右取列，相乘再相加，行列定位置。 向量点乘不满足交化率，但是满足结合律和分配率 a.矩阵乘法合法性 A = \\begin{bmatrix} 2&4\\\\ 6&8\\\\ -2&-3\\\\ \\end{bmatrix} B = \\begin{bmatrix} 2&4&6&1\\\\ 6&4&1&3\\\\ \\end{bmatrix} 我们能不能把它们相乘得到 AB 必须满足一个条件：A 矩阵的列数必须等于 B 矩阵的行数。 b.矩阵的转置 \\begin{bmatrix} 2&4&1\\\\ 6&5&3\\\\ \\end{bmatrix}^T = \\begin{bmatrix} 2&6\\\\ 4&5\\\\ 1&3\\\\ \\end{bmatrix} c.矩阵在图形学中的实际应用 矩阵乘以向量：向量必须是一个列向量，实际就是我们的变换。 矩阵乘法结合律：比如视图矩阵乘以投影矩阵。 d.矩阵变换 平移 \\begin{bmatrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\ 1\\\\ \\end{bmatrix} 缩放 \\begin{bmatrix} s_x&0&0&0\\\\ 0&s_y&0&0\\\\ 0&0&s_z&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} s_x·x\\\\ s_y·y\\\\ s_z·z\\\\ 1\\\\ \\end{bmatrix} 旋转 绕x轴旋转α度对应的旋转矩阵Rx \\begin{bmatrix} 1&0&0&0\\\\ 0&cosα&-sinα&0\\\\ 0&sinα&cosα&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} x\\\\ cosα*y-sinα*z\\\\ sinα*y+cosα*z\\\\ 1\\\\ \\end{bmatrix} 绕y轴旋转α度对应的旋转矩阵Ry \\begin{bmatrix} cosα&0&-sinα&0\\\\ 0&1&0&0\\\\ sinα&0&cosα&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} cosα*x+sinα*z\\\\ y\\\\ -sinα*x+cosα*z\\\\ 1\\\\ \\end{bmatrix} 绕z轴旋转α度对应的旋转矩阵Rz \\begin{bmatrix} cosα&-sinα&0&0\\\\ sinα&cosα&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} cosα*x-sinα*y\\\\ sinα*x+cosα*y\\\\ z\\\\ 1\\\\ \\end{bmatrix} 3.欧拉对象 Euler、四元数 Quaternion 和旋转矩阵 欧拉对象、四元数和旋转矩阵都是用来表达对象的旋转信息。欧拉对象和四元数存在的意义：为了给旋转变换做插值。 https://threejs.org/docs/#api/zh/math/Euler https://threejs.org/docs/#api/zh/math/Quaternion // Euler( x : Float, y : Float, z : Float, order : String ) // x - (optional) 用弧度表示x轴旋转量。 默认值是 0。 // y - (optional) 用弧度表示y轴旋转量。 默认值是 0。 // z - (optional) 用弧度表示z轴旋转量。 默认值是 0。 // order - (optional) 表示旋转顺序的字符串，默认为'XYZ'（必须是大写）。 const Euler = new THREE.Euler( Math.PI/4, 0, Math.PI/2, 'XYZ'); Euler.x = Math.PI/4; Euler.y = Math.PI/2; Euler.z = Math.PI/4; Euler.order = 'YZX' // 绕单位向量Vector3(x, y, z) 表示的轴旋转 θ 度 // k = sinθ/2 // q = ( xk , yk , z*k, cosθ/2) // 【下面的例子是：将点(0, 0, 1)绕 Y 轴旋转 90 度，得到新的坐标(1, 0, 0)】 const quaternion = new THREE.Quaternion(); // 旋转轴 new THREE.Vector3(0, 1, 0) // 旋转角度 Math.PI / 2 const angle = Math.PI / 2 quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle) console.log('查看四元数结构', quaternion); const k = Math.sin(angle / 2) console.log('查看数组', [0 * k , 1 * k , 0 * k, Math.cos(angle / 2)]); const vector = new THREE.Vector3( 0, 0, 1 ); const newVector = vector.clone().applyQuaternion( quaternion ); console.log('旋转后的新坐标', newVector) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Webgl/":{"url":"pages/threeJS/Webgl/","title":"Webgl","keywords":"","body":"WebGL WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API。这些 API 能够让 Web 开发者使用 JavaScript 语言直接和显卡（GPU）进行通信。 WebGL 应用由 JavaScript 程序和着色器程序构成。 WebGL 的编程开发者需要针对 CPU 和 GPU 进行编程，CPU 部分是 JavaScript 程序，GPU 部分是着色器程序。 GLSL——OpenGL Shading Language（OpenGL 着色语言），用来在 OpenGL 编写着色器程序的语言。 渲染管线 准备顶点数据 - 顶点着色 - 图元组装 - 光栅化 - 片元着色 1.顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。 2.图元装配阶段，将顶点按照图元类型组装成图形。 3.光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。 4.片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。 主流程 // 顶点着色器源码 let vertexstring = ` attribute vec4 position; uniform mat4 proj; void main(void){ gl_Position = position; gl_PointSize=60.0; } `; // 片元着色器源码 let fragmentstring = ` void main(void){ gl_FragColor = vec4(0,0,1.0,1.0); } `; // step-1: 创建空着色器对象 const vertexShader = gl.createShader(gl.VERTEX_SHADER); const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); // step-2: 将源码分配给着色器对象 gl.shaderSource(vertexShader, vertexShaderSource); gl.shaderSource(fragmentShader, fragmentShaderSource); // step-3: 编译着色器对象 gl.compileShader(vertexShader); gl.compileShader(fragmentShader); // step-5: 创建着色器程序 const program = gl.createProgram(); // step-6: 将着色器对象挂载到着色器程序 gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); // step-7: 链接着色器程序 gl.linkProgram(program); // step-8: 使用着色器程序 gl.useProgram(program); // step-9: 为顶点着色器传值 // step-10: 设置清空画布颜色为黑色。 gl.clearColor(0.0, 0.0, 0.0, 1.0); // step-11: 用上一步设置的清空画布颜色清空画布。 gl.clear(gl.COLOR_BUFFER_BIT); // step-12: 绘制。 gl.drawArrays(gl.POINTS, 0, 1); gl.drawArrays(gl.TRIANGLE, 0, 3); step-9: 使用缓冲区对象为顶点着色器传值 // 获取顶点着色器的位置变量apos，即aposLocation指向apos变量。 const aposLocation = gl.getAttribLocation(program, 'position'); // 类型数组构造函数Float32Array创建顶点数组 const data = new Float32Array([ 0.6, 0.2, 0, //顶点1坐标 0.7, 0.6, 0, //顶点2坐标 0.8, 0.2, 0, //顶点3坐标 -0.6, -0.2, 0, //顶点4坐标 -0.7, -0.6, 0, //顶点5坐标 -0.8, -0.2, 0, //顶点6坐标 0.1, 0.2, 0, // 顶点7坐标 0.2, 0.6, 0, // 顶点8坐标 0.3, 0.2, 0, // 顶点9坐标 ]); // 创建缓冲区对象 const buffer = gl.createBuffer(); // 绑定缓冲区对象,激活buffer gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // 顶点数组data数据传入缓冲区 gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // 缓冲区中的数据按照一定的规律传递给位置变量apos gl.vertexAttribPointer(aposLocation, 3, gl.FLOAT, false, 0, 0); // 允许数据传递 gl.enableVertexAttribArray(aposLocation); step-9: 不使用缓冲区对象为顶点着色器传值 // 类型数组构造函数Float32Array创建顶点数组 const pointPosition = new Float32Array([100.0, 100.0, 0.0, 1.0]); // 获取顶点着色器的位置变量 const aPsotion = webgl.getAttribLocation(webgl.program, 'position'); // 直接将数据传递给位置变量 aPsotion webgl.vertexAttrib4fv(aPsotion, pointPosition); 向着色器中传递数据 getAttribLocation: 找到着色器中的 attribute 变量地址 getUniformLocation: 找到着色器中的 uniform 变量地址 vertexAttrib4f: 给 attribute 变量传递四个浮点数 uniform4f: 给 uniform 变量传递四个浮点数 是否使用缓冲区的区别(Geometry vs BufferGeometry) Geometry 模型生成流程 【代码】-> 【CPU 进行数据处理，转化成虚拟3D数据】 -> 【GPU 进行数据组装，转化成像素点，准备渲染】 -> 显示器 第二次修改时，与第一次操作完全相同。 BufferGeometry 模型生成流程 【代码】 -> 【CPU 进行数据处理，转化成虚拟3D数据】 -> 【GPU 进行数据组装，转化成像素点，准备渲染】 -> 【丢入缓存区】 -> 显示器 第二次修改时，可通过API直接修改缓存区数据:【代码】 -> 【CPU 进行数据处理，转化成虚拟3D数据】 -> 【修改缓存区数据】 -> 显示器 Geometry 转化为 BufferGeometry bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Shader/":{"url":"pages/threeJS/Shader/","title":"Shader","keywords":"","body":"shader glsl 语法 三种限定符（uniform，attribute 和 varying） uniform(一致变量)：外部程序传递给（vertex 和 fragment）shader 的变量，不能被 shader 程序修改。 attribute(属性变量)：只能在vertex shader中使用的变量，一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。 varying(易变变量)：vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。 预处理命令 #define：宏定义，在编译处理阶段起作用。 #ifdef：判断一个宏定义是否存在，如果存在，在编译预处理的时候，保留 #ifdef 和 #endif 两个关键字之间的代码。 #if：判断条件是否成立，如果成立，在编译预处理后会保留通过 #if 和 #endif 两个关键字之间的代码，否在不保留。 #include：引入另一个着色器文件，在编译预处理后替换。 变量类型 标量 float: 浮点数 int: 整数 unit: 无符号整数 bool: 布尔值 矢量 vec3: 包含3个浮点数的矢量 ivec3: 包含3个整数的矢量 uvec3: 包含3个无符号整数的矢量 bvec3: 包含3个布尔值的矢量 矩阵 mat2: 2*2 的浮点数矩阵 mat3: 3*3 的浮点数矩阵 mat4: 4*4 的浮点数矩阵 取样器 纹理查找需要指定一个纹理或者纹理单元，GLSL不关心纹理单元的底层实现，因此它提供了 一个简单而不透明的句柄来封装需要查找的对象。这些句柄被称为\"取样器(SAMPLERS)\"。 sampler3D：访问三维纹理 samplerCube：访问立方贴图纹理 sampler2DRect：访问二维矩形纹理 sampler2DRectShadow：访问带对比的二维矩形深度纹理 sampler2DArrayShadow：访问二维深度纹理数组 samplerBuffer：访问纹理缓存 isampler3D：访问整型三维纹理 usampler3D：访问无符号整型三维纹理 结构 GLSL提供了类似于C 的用户定义结构。 struct light { vec3 position; vec3 color; } 数组 GLSL可以创建任何类型的数组。 创建的是一个包含 10 个 vec4 类型的数组：vec4 points[10]; 创建的是一个位置大小的 int 类型的数组：int num[]; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Draco/":{"url":"pages/threeJS/Draco/","title":"Draco","keywords":"","body":"Draco 压缩 由于 3D 模型文件一般比较大，所以需要通过 Draco 压缩，以减少网络传输的大小。 方案一：gltf-pipeline npm 地址：https://www.npmjs.com/package/gltf-pipeline // 压缩 gltf 文件 npm i -g gltf-pipeline gltf-pipeline -i car.gltf -o copy.gltf -d // 解压 gltf 文件 import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'; const loader = new GLTFLoader(); const dracoLoader = new DRACOLoader(); // 此处需要 'three/js/libs/draco/gltf/' 下的两个文件：draco_decoder.wasm + draco_wasm_wrapper.js dracoLoader.setDecoderPath('./draco/'); loader.setDRACOLoader(dracoLoader); loader.load('./gltf/copy.gltf', () => {...}); 方案二：google/draco github 地址：https://github.com/google/draco // 克隆仓库 git clone git@github.com:google/draco.git // 创建新文件夹 build mkdir build && cd build // 执行编译 cmake ../ // 执行 make make // 压缩文件 ./draco_encoder -i car.gltf -o copy.gltf Draco 的作用 Draco 在当前的VR、AR生态下，基本上没有直接使用的价值，想用它必须理解原理并修改源码。 Draco 里面有比较好的mesh压缩方案，有利于游戏引擎公司基于该代码优化自己的模型设计。 Draco 所能压缩的只是3D模型文件中的一部分，而3D相关的资源大头（图片）还是一个老大难的问题。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/glTF/":{"url":"pages/threeJS/glTF/","title":"glTF","keywords":"","body":"glTF glTF is the \"JPEG of 3D\" glTF 文件结构 glTF 内部结构详解 https://blog.csdn.net/qq_31709249/article/details/86477520 scenes： nodes： buffers： bufferViews： accessors： meshes： materials： textures： glTF 生态 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/CSS3DRender/":{"url":"pages/threeJS/CSS3DRender/","title":"CSS3DRender","keywords":"","body":"CSS3DRender 标注 在 3D 标注中，我们可以使用 CSS3DRenderer 来渲染 3D 标注。 刀片电池 单体电池长96mm、宽9mm、高1.35mm 可循环充放电3000次以上，续航600公里 import { CSS3DObject, CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer.js'; // 创建标注：将普通 html 转换为 3D 标注 const mark1 = document.getElementsByClassName('mark')[0]; mark1.style.visibility = 'visible'; const label1 = new CSS3DObject(mark1); mark1.style.pointerEvents = 'none'; label1.position.copy(LFSprite.position); label1.scale.set(0.5, 0.5, 1.0); label1.position.set(0, 0, 0); label1.position.x -= 220; label1.position.y += 50; label1.rotateY(-Math.PI / 2); model.add(label1); // 渲染 3D 标注 const labelRenderer = new CSS3DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.left = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; document.body.appendChild(labelRenderer.domElement); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Raycaster/":{"url":"pages/threeJS/Raycaster/","title":"Raycaster","keywords":"","body":"Raycaster 3D 点击事件 文档地址：https://threejs.org/docs/?q=Raycaster#api/zh/core/Raycaster intersectObject: 检测射线和单个物体的相交 intersectObjects: 检测射线和多个物体的相交 const mouse = new THREE.Vector2(-10000000, -1000000); let flag = false; const raycaster = new THREE.Raycaster(); const onDocumentClick = (event) => { flag = true; event.preventDefault(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }; document.addEventListener('click', onDocumentClick, false); const render = () => { if (scene.children[6]) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(scene.children[6], true); if (intersects[0] && flag) { console.log('intersects', intersects[0]); if (intersects[0].object.parent.name === '左前门' || intersects[0].object.name === 'LFSprite') { if (LFDoor.flag) { LFDoor.rotateY(Math.sin(Math.PI / 2)); LFDoor.flag = false; } else { LFDoor.rotateY(-Math.sin(Math.PI / 2)); LFDoor.flag = true; } } flag = false; } } } requestAnimationFrame(render); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/MaterialReset/":{"url":"pages/threeJS/MaterialReset/","title":"MaterialReset","keywords":"","body":"MaterialReset 由于不同的 3D 制作软件渲染的效果有细微的差异，一般需要对材质属性进行重新设置。 metalness 材质与金属的相似度。 非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。 roughness 材质的粗糙程度。 0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。 envMapIntensity 通过乘以环境贴图的颜色来缩放环境贴图的效果。 transmission 透光率（或者说透光性），范围从0.0到1.0。默认值是0.0。 很薄的透明或者半透明的塑料、玻璃材质即便在几乎完全透明的情况下仍旧会保留反射的光线，透光性属性用于这种类型的材质。 当透光率不为 0 的时候, opacity 透明度应设置为 1. MeshPhysicalMaterial 特有。 例子 import * as THREE from 'three'; const SetCarMaterial = (carModel) => { const textureCube = new THREE.CubeTextureLoader() .setPath('./skybox/') .load(['li.jpg', 'xin.jpg', 'chu.jpg', 'xing.jpg', 'top.jpg', 'bottom.jpg']); textureCube.encoding = THREE.sRGBEncoding; carModel.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 4) === '高光金属') { object.material = new THREE.MeshStandardMaterial({ color: object.material.color, metalness: 1.0, roughness: 0.2, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '外壳') { object.material = new THREE.MeshPhysicalMaterial({ color: object.material.color, clearcoat: 1, clearcoatRoughness: 0.01, metalness: 1.0, roughness: 0.5, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '玻璃') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0, transparent: true, transmission: 0.99, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 3) === '后视镜') { object.material = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.0, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '轮胎') { object.material.color.set(0x000000); object.material.normalScale.set(2, 2); object.material.metalness = 0.0; object.material.roughness = 0.6; } else if (object.name.slice(0, 3) === '前灯罩') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0, transmission: 0.9, transparent: true, }); } else if (object.name.slice(0, 4) === '尾灯灯罩') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xff0000, metalness: 0.0, roughness: 0, transmission: 0.5, transparent: true, }); } else if (object.name.slice(0, 5) === '尾灯第二层') { object.material = new THREE.MeshPhysicalMaterial({ color: 0x440000, metalness: 0.0, roughness: 0, transmission: 0.5, transparent: true, }); } else if (object.name.slice(0, 4) === '尾灯发光') { object.material = new THREE.MeshLambertMaterial({ color: 0x660000, }); } else if (object.name.slice(0, 5) === '尾灯第三层') { object.material = new THREE.MeshLambertMaterial({ color: 0x19190000, }); } else if (object.name.slice(0, 2) === '塑料') { object.material = new THREE.MeshPhysicalMaterial({ color: 0x010101, metalness: 0.0, roughness: 0.8, }); } carModel.getObjectByName('天窗黑玻璃').material = new THREE.MeshPhysicalMaterial({ color: 0x111111, metalness: 0.0, roughness: 0, envMapIntensity: 1.0, transmission: 0.5, transparent: true, }); carModel.getObjectByName('车座').material = new THREE.MeshPhysicalMaterial({ color: 0x020202, metalness: 0.0, roughness: 0.6, }); object.material.envMap = textureCube; } }); }; export default SetCarMaterial; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Animation/":{"url":"pages/threeJS/Animation/","title":"Animation","keywords":"","body":"Animation tween.js is a powerful tool for creating interactive animations. 动画：旋转 + 平移 + 缩放 旋转: rotate // method Mesh.rotateY(-Math.sin(Math.PI / 2)); // attribute Mesh.rotation.y = -Math.sin(Math.PI / 2); 平移: translate // method Mesh.translateY(100); // attribute Mesh.position.y += 100; 缩放: scale // method Mesh.scaleY(1.5); // attribute Mesh.scale.y = 1.5; tween.js 文档地址：https://github.com/tweenjs/es6-tween/blob/HEAD/API.md 这个 npm 包已经停止维护了，但很好用。 import { Tween, Easing } from 'es6-tween'; let tween = null const rotateY = (value) => { // LFDoor 是需要旋转的 3D 对象 tween = new Tween(LFDoor.rotation) .to({ y: value }, 300) .easing(Easing.Exponential.In) .delay(100 * Math.random()) .start(); }; const render = () => { if (scene.children[6]) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(scene.children[6], true); if (intersects[0] && flag) { if (intersects[0].object.parent.name === '左前门' || intersects[0].object.name === 'LFSprite') { if (LFDoor.flag) { // LFDoor.rotateY(Math.sin(Math.PI / 2)); // LFDoor.rotation.y = 0; rotateY(0); LFDoor.flag = false; } else { // LFDoor.rotateY(-Math.sin(Math.PI / 2)); // LFDoor.rotation.y = -Math.sin(Math.PI / 2); rotateY(-Math.sin(Math.PI / 2)); LFDoor.flag = true; } } flag = false; } } if (tween) tween.update(); scene.rotateY(0.0005); renderer.render(scene, camera); requestAnimationFrame(render); } render(); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/GuiControls/":{"url":"pages/threeJS/GuiControls/","title":"GuiControls","keywords":"","body":"GuiControls 开发过程对参数的调试很麻烦，需要借助于 guiControls 调试具体参数。 其本质是一个简单的控制器，可以设置一个参数，然后调用一个函数，这个函数会改变参数的值。 例子 import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js'; import { model } from './Model.js'; /** * 创建一个gui对象 */ const guiControls = { envMapIntensity: 0.5, transmission: 0.5, metalness: 1.0, roughness: 0.5, }; const gui = new GUI(); gui.domElement.style = 'position: absolute; top: 0; right: 0; width: 300px;'; const folder1 = gui.addFolder('外壳'); folder1.open(); folder1.add(guiControls, 'envMapIntensity', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.envMapIntensity = value; } } }); }); folder1.add(guiControls, 'metalness', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.metalness = value; } } }); }); folder1.add(guiControls, 'roughness', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.roughness = value; } } }); }); const folder2 = gui.addFolder('玻璃'); folder2.open(); folder2.add(guiControls, 'transmission', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '玻璃') { // eslint-disable-next-line no-param-reassign object.material.transmission = value; } } }); }); export default guiControls; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Panorama/":{"url":"pages/threeJS/Panorama/","title":"Panorama","keywords":"","body":"Panorama 全景图展示 第三方插件：https://photo-sphere-viewer.js.org/guide/#install-photo-sphere-viewer 第三方插件的使用 import { Viewer } from 'photo-sphere-viewer'; import 'photo-sphere-viewer/dist/photo-sphere-viewer.css'; const viewer = new Viewer({ container: document.querySelector('#photosphere'), panorama: 'https://photo-sphere-viewer-data.netlify.app/assets/sphere.jpg', size: { width: window.innerWidth, height: window.innerHeight, }, defaultZoomLvl: 10, navbar: false, }); viewer.once('ready', () => { viewer.animate({ longitude: Math.PI, latitude: '20deg', zoom: 50, speed: '2rpm', }); }); 原理解析 原理非常简单：将全景图作为贴图贴到球面上，然后翻转球面，就可以实现全景图的展示。 const scene = new THREE.Scene(); const material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://photo-sphere-viewer-data.netlify.app/assets/sphere.jpg'), }); const size = 1000; const skyBox = new THREE.Mesh(new THREE.SphereBufferGeometry(size, size, size), material); skyBox.geometry.scale(-1, 1, 1); // 里外两侧的表面翻转 scene.add(skyBox); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/KeyboardControl/":{"url":"pages/threeJS/KeyboardControl/","title":"KeyboardControl","keywords":"","body":"KeyboardControl 控制物体的移动 three.js example 中的 KeyboardControl 代码 const keyboardControls = (function () { const keys = { SP: 32, W: 87, A: 65, S: 83, D: 68, UP: 38, LT: 37, DN: 40, RT: 39, }; const keysPressed = {}; (function (watchedKeyCodes) { const handler = function (down) { return function (e) { const index = watchedKeyCodes.indexOf(e.keyCode); if (index >= 0) { keysPressed[watchedKeyCodes[index]] = down; e.preventDefault(); } }; }; window.addEventListener('keydown', handler(true), false); window.addEventListener('keyup', handler(false), false); }([ keys.SP, keys.W, keys.A, keys.S, keys.D, keys.UP, keys.LT, keys.DN, keys.RT, ])); const forward = new THREE.Vector3(); const sideways = new THREE.Vector3(); let i = 0; let j = 0; return function () { // 观看 if (keysPressed[keys.UP]) { i += 1; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.DN]) { i -= 1; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.LT]) { j += 10; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.RT]) { j -= 10; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } // 移动 if (keysPressed[keys.D]) { camera.translateX(10); } if (keysPressed[keys.A]) { camera.translateX(-10); } if (keysPressed[keys.W]) { camera.translateZ(-1); } if (keysPressed[keys.S]) { camera.translateZ(1); } }; }()); const render = () => { keyboardControls(); renderer.render(scene, camera); requestAnimationFrame(render); }; render(); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Audio/":{"url":"pages/threeJS/Audio/","title":"Audio","keywords":"","body":"Audio 对于音频播放，可以借助于 html5 来实现，但是要创建 audio 标签，比较麻烦。可以直接使用 three 提供的 audio 模块。 API new THREE.AudioListener() -> 创建一个音频监听器。 new THREE.AudioLoader() -> 创建一个音频加载器，用于加载音频文件。 new THREE.Audio(listener) -> 创建一个音频对象，并且将其绑定到监听器，设置音量。 例子 import * as THREE from 'three'; const listener = new THREE.AudioListener(); const openAudio = new THREE.Audio(listener); const closeAudio = new THREE.Audio(listener); const audioLoader = new THREE.AudioLoader(); audioLoader.load('./audio/open.wav', (buffer) => { openAudio.setBuffer(buffer); openAudio.setVolume(1); }); audioLoader.load('./audio/close2.wav', (buffer) => { closeAudio.setBuffer(buffer); closeAudio.setVolume(1); }); const displayOpenAudio = () => { openAudio.play(); }; const displayCloseAudio = () => { closeAudio.play(); }; export { openAudio, closeAudio, displayOpenAudio, displayCloseAudio, }; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/threeJS/Encoding/":{"url":"pages/threeJS/Encoding/","title":"sRGBEncoding","keywords":"","body":"THREE.sRGBEncoding 纹理中包含的颜色信息（.map, .emissiveMap, 和 .specularMap）在glTF中总是使用sRGB颜色空间，而顶点颜色和材质属性（.color, .emissive, .specular） 则使用线性颜色空间。在典型的渲染工作流程中，纹理会被渲染器转换为线性颜色空间，进行光照计算，然后最终输出会被转换回 sRGB 颜色空间并显示在屏幕上。 在使用 glTF 的时候将 WebGLRenderer 进行配置：renderer.outputEncoding = THREE.sRGBEncoding; /** * 创建渲染器对象 */ const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(width, height); renderer.outputEncoding = THREE.sRGBEncoding; renderer.setClearColor(0x00ffff, 1); 当从外部加载纹理（例如，使用 TextureLoader）并将纹理应用到 glTF 模型，则必须给定对应的颜色空间与朝向： carModel.traverse((object) => { if (object.type === 'Mesh') { if (object.name === '车标') { object.material.map = new THREE.TextureLoader().load('./gltf/Image_0.png'); object.material.map.encoding = THREE.sRGBEncoding; object.material.map.flipY = false; } } }); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/":{"url":"pages/node/","title":"Node","keywords":"","body":"node 常用模块 fs path child_process stream buffer Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/nvm/":{"url":"pages/node/nvm/","title":"nvm","keywords":"","body":"nvm 用于 node 版本的切换和安装升级 nvm 常用命令 nvm ls-remote：列出所有可以安装的node版本号 nvm install v10.4.0：安装指定版本号的node nvm uninstall v10.4.0：卸载指定版本号的node nvm use v10.3.0：切换node的版本，这个是全局的 nvm current：当前node版本 nvm ls：列出所有已经安装的node版本 nvm --help: 查看命令列表 nvm alias default 16.9.0: 指定一个默认的node版本 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/fs/":{"url":"pages/node/fs/","title":"fs","keywords":"","body":"fs 相关模块 fs 与 fs-extra 的区别 文件监听 fs.watch chokidar.watch 文件修改 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/path/":{"url":"pages/node/path/","title":"path","keywords":"","body":"path 相关模块 path.resolve 生成绝对路径：path.resolve(__dirname, '../') path.join 路径拼接 path.dirname 获取目录名称 path.basename 获取文件名称（带扩展名） path.extname 获取文件扩展名 path.parse 解析路径： root: 根目录 dir: 目录名称 base: 文件名称（带扩展名） ext: 扩展名 name: 文件名称（不带扩展名） path.format path.parse 的逆向操作 path.relative path.relative(from, to) 获取相对路径 path.normalize 格式化：// -> / path.isAbsolute 判断绝对路径 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/http/":{"url":"pages/node/http/","title":"http","keywords":"","body":"http 模块 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/https/":{"url":"pages/node/https/","title":"https","keywords":"","body":"https 模块 openssl 生成证书文件 // 1、生成私钥key文件： openssl genrsa -out privatekey.pem 1024 // 2、通过私钥生成CSR证书签名 （需要填一些信息、可直接回车） openssl req -new -key privatekey.pem -out certrequest.csr // 3、通过私钥和证书签名生成证书文件 openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem 看到 Signature ok，说明生成证书成功。 https 代码 const https = require('https'); const fs = require('fs'); const path = require('path'); const HOST = '127.0.0.1'; const PORT = 8000; const options = { key: fs.readFileSync(path.resolve(__dirname, './privatekey.pem'), 'utf8'), cert: fs.readFileSync(path.resolve(__dirname, './certificate.pem'), 'utf8') }; https.createServer(options, function (request, response) { response.writeHead(200); response.end(\"Hello world from HTTPS\"); }).listen(PORT, () => { console.log(`Server listening on https://${HOST}:${PORT}`) }); chrome 您的连接不是私密连接 直接在当前页面用键盘输入 thisisunsafe ，不是在地址栏输入，直接敲键盘就行了，页面即会自动刷新进入网页。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/events/":{"url":"pages/node/events/","title":"events","keywords":"","body":"events 模块 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/childProcess/":{"url":"pages/node/childProcess/","title":"child_process","keywords":"","body":"child_process 模块 const { spawn } = require('child_process') const task1 = () => new Promise((resolve, reject) => { const test = spawn('npm', ['run', 'dev']) test.stdout.on('data', (data) => { console.log(`stdout1: ${data}`); if (/finished/.test(data)) { console.log('new task2。。。') resolve() } }); }) const task2 = () => new Promise((resolve, reject) => { const test = spawn('npm', ['run', 'test']) test.stdout.on('data', (data) => { console.log(`stdout2: ${data}`); if (/圆满完成任务/.test(data)) { console.log('new task3。。。') resolve() } }); }) const task3 = () => { console.log('撒花') } const task = async () => { await task1() await task2() task3() } 特殊应用场景 多个项目之间的任务组合: cwd 与 lerna 的 --scope 有相同的功能。 const path = require('path') const { spawn } = require('child_process') spawn('npm', ['run', `dev:${temp}`], { cwd: path.resolve(__dirname, '../packages/wepy-project') }) lerna run task1 --scope=ucma-frontend--wepy && lerna run task2 --scope=ucma-frontend--taro 实际应用案例: wepy 与 taro 两个框架项目并存。 const path = require('path') const { spawn } = require('child_process') const colors = require('colors') const temp = process.env.TEMP_TYPE const wepyBuildPromise = () => new Promise((resolve, reject) => { const lixinBuild = spawn('npm', ['run', `dev:${temp}`], { cwd: path.resolve(__dirname, '../packages/wepy-project') }) lixinBuild.stdout.on('data', (data) => { console.log(`${colors.green('wepy build')}--${data}`) if (/开始监听文件改动/.test(data)) { resolve() } }) lixinBuild.stderr.on('data', (data) => { console.log(`${colors.red('wepy build err')}--${data}`) }) lixinBuild.on('exit', () => console.log(`${colors.green('wepy热更新监听程序退出')}`)) }) const taroBuildPromise = () => new Promise(resolve => { const taroBuild = spawn('npm', ['run', 'dev'], { cwd: path.resolve(__dirname, '../packages/taro-project') }) taroBuild.stdout.on('data', (data) => { console.log(`${colors.green('taro build')}--${data}`) if (/拷贝结束/.test(data)) { resolve() } }) taroBuild.stderr.on('data', (data) => { console.log(`${colors.red('taro build err')}--${data}`) }) taroBuild.on('exit', () => console.log(`${colors.green('taro热更新监听程序退出')}`)) }) const patchWxApp = () => { const patchProcess = spawn('npm', ['run', 'enchance-wxapp'], { cwd: path.resolve(__dirname, '../packages/wepy-project') }) patchProcess.stdout.on('data', (data) => { console.log(`${colors.green('patch wx app')}--${data}`) }) patchProcess.stderr.on('data', (data) => { console.log(`${colors.red('patch wx app err')}--${data}`) }) patchProcess.on('exit', () => console.log(`${colors.green('打补丁完成！')}`)) } const mainProcess = async () => { await wepyBuildPromise() await taroBuildPromise() // 每次拷贝结束都要执行一次微信小程序的补丁程序，包括taro热更新 patchWxApp() } mainProcess() Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/stream/":{"url":"pages/node/stream/","title":"stream","keywords":"","body":"stream 模块 stream 的优势 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/buffer/":{"url":"pages/node/buffer/","title":"buffer","keywords":"","body":"buffer 模块 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/node/dependency/":{"url":"pages/node/dependency/","title":"依赖管理","keywords":"","body":"依赖相关细节 --save与--save-dev的区别 -S是--save的缩写，依赖会被安装到dependencies，生产环境所需依赖，例：antd, element, react -D是--save-dev的缩写，依赖会被安装到devDependencies，开发所需的依赖，例：xxx-cli, less-loader, babel-loader 举例说明 我们写的ES6代码，需要 babel 转换成 es5 ，转换完成后，我们只需要转换后的代码，上线的时候，直接把转换后的代码部署到生产环境，不需要 bebal 了，生产环境不需要。这就可以安装到 devDependencies ，再比如说代码提示工具，也可以安装到 devDependencies。 我们使用的 Element-UI，由于发布到生产后还是依赖 Element-UI，这就可以安装到 dependencies。 peerDependencies 的作用 peerDependencies 的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。 举个例子，就拿目前基于react的ui组件库ant-design@3.x来说，因该ui组件库只是提供一套react组件库，它要求宿主环境需要安装指定的react版本。具体可以看它package.json中的配置： \"peerDependencies\": { \"react\": \">=16.0.0\", \"react-dom\": \">=16.0.0\" } 它要求宿主环境安装react@>=16.0.0和react-dom@>=16.0.0的版本，而在每个antd组件的定义文件顶部： import * as React from 'react'; import * as ReactDOM from 'react-dom'; 组件中引入的 react 和 react-dom 包其实都是宿主环境提供的依赖包。 项目中的实际应用: 在 element-ui 的中间层 npm 包 @lx-frontend/wrap-element-ui 中申明 \"peerDependencies\": { \"element-ui\": \">=2.11.1\" } package.json 中版本号的控制符号 主版本号.次版本号.修订版本号.日期版本号_希腊字母版本号 ^ 符号: 锁定主版本号，次版本号和修订版本号下载最新版本 { \"vue\": \"^3.2.13\" } ~ 符号: 锁定主版本号和次版本号，修订版本号下载最新版本 { \"vue\": \"~3.2.13\" } * 符号: 直接下载这个包的最新版本 { \"vue\": \"*\" } x 符号：占位版本号的位置, 全部下载最新版本 { \"vue\": \"^3.2.x\" } >、、>=、 符号：占位版本号的位置, 全部下载最新版本 { \"peerDependencies\": { \"packageA\": \">3.0.0\", \"packageB\": \">=2.6.0\", \"packageC\": \"=1.0.2 希腊字母版本号共有五种，分别为：base、alpha、beta、RC、release Base 此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是 页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。 Alpha 软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者 内部交流，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试 人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可 将软件版本标注为alpha版。 Beta 该版本相对于Alpha 版已经有了很大的进步，消除了严重错误，但还需要经过多次 测试来进一步消除，此版本主要的修改对象是软件的UI。修改的的Bug 经测试人 员测试确认后可发布到外网上，此时可将软件版本标注为 beta版。 RC 该版本已经相当成熟，基本上不存在导致错误的Bug，与即将发行的正式版本相差无几。 Release 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。 package-lock.json 的作用 锁定安装时的包的版本号及包的依赖的版本号, 以保证其他所有人人在使用 ​​npm install​​ 时下载的依赖包都是一致的。 举例说明，现在有程序员A、程序员B两个开发者 程序员A：接手项目时Vue的版本是2.6.14，此版本被锁在了package-lock.json 程序员B：一个月后加入这个项目，这时Vue已经升级到2.9.14，npm install的时候，按理说会自动升级，但是由于package-lock.json中锁着2.6.14这个版本，所以阻止了自动升级，保证版本还是2.6.14 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/":{"url":"pages/webpack/","title":"Webpack","keywords":"","body":"webpack基础知识 主要工作流程 plguin与loader的区别 css-loader、style-loader与less-loader(从右往左) 分包机制 性能分析及优化 postCss && babel tree shaking 配置 lodash.js按需引入配置 热更新实现原理 --save与--save-dev的区别 websocket Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/basic/":{"url":"pages/webpack/basic/","title":"基础配置","keywords":"","body":"webpack 基础配置项 常用配置项 module.exports = { // __dirname值为所在文件的目录，context默认为执行webpack命令所在的目录 context: path.resolve(__dirname, 'app'), // 必填项，编译入口，webpack启动会从配置文件开始解析,如下三种(还有一种动态加载entry的方式就是给entry传入一个函数，这个在项目比较大，页面很多的情况下可以优化编译时间) entry: './app/entry', // 只有一个入口，入口只有一个文件 entry: ['./app/entry1', './app/entry2'], // 只有一个入口，入口有两个文件 // 两个入口 entry: { entry1: './app/entry1', entry2: './app/entry2' }, // 输出文件配置 output: { // 输出文件存放的目录，必须是string类型的绝对路径 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: 'bundle.js', filename: '[name].js', // 配置了多个入口entry是[name]的值会被入口的key值替换，此处输出文件会输出的文件名为entry1.js和entry2.js filename: [chunkhash].js, // 根据chunk的内容的Hash值生成文件的名称，其他只还有id，hash，hash和chunkhash后面可以使用:number来取值，默认为20位，比如[name]@[chunkhash:12].js, // 文件发布到线上的资源的URL前缀，一般用于描述js和css位置，举个例子，打包项目时会导出一些html,那么html里边注入的script和link的地址就是通过这里配置的 publicPath: \"https://cdn.example.com/assets/\", // CDN（总是 HTTPS 协议） publicPath: \"//cdn.example.com/assets/\", // CDN (协议相同) publicPath: \"/assets/\", // 相对于服务(server-relative) publicPath: \"assets/\", // 相对于 HTML 页面 publicPath: \"../assets/\", // 相对于 HTML 页面 publicPath: \"\", // 相对于 HTML 页面（目录相同） // 当需要构建的项目可以被其他模块导入使用，会用到libraryTarget和library library: 'xxx', // 配置导出库的名称，但是和libraryTarget有关，如果是commonjs2默认导出这个名字就没啥用 // 从webpack3.1.0开始，可以为每个target起不同的名称 library: { root: \"MyLibrary\", amd: \"my-library\", commonjs: \"my-common-library\" }, libraryTarget: 'umd', // 导出库的类型，枚举值: umd、commonjs2、commonjs，amd、this、var(默认)、assign、window、global、jsonp(区别查看补充2) // 需要单独导出的子模块，这样可以直接在引用的时候使用子模块，默认的时候是_entry_return_ libraryExport: 'default', // __entry_return_.default libraryExport: 'MyModule', // __entry_return_.MyModule libraryExport: ['MyModule', 'MySubModule '], // 使用数组代表到指定模块的取值路径 __entry_return_.MyModule.MySubModule // 配置无入口的chunk在输出时的文件名称，但仅用于在运行过程中生成的Chunk在输出时的文件名称，这个应该一般和插件的导出有关，支持和filename一样的内置变量 chunkFilename: '[id].js', // 是否包含文件依赖相关的注释信息，不懂？请看补充3，在mode为development的是默认为true pathinfo: true, // JSONP异步加载chunk，或者拼接多个初始chunk(CommonsChunkPlugin,AggressiveSplittingPlugin) jsonpFunction: 'myWebpackJsonp', // 此选项会向应盘写入一个输出文件，只在devtool启动了sourceMap选项时采用，默认为`[file].map`,除了和filename一样外还可以使用[file] sourceMapFilename: '[file].map', // 浏览器开发者工具里显示的源码模块名称，此选项仅在 「devtool 使用了需要模块名称的选项」时使用，使用source-map调试，关联模块鼠标移动到上面的时候显示的地址(截不到图啊，醉了)，默认这个值是有的，一般不需要关心 devtoolModuleFilenameTemplate: 'testtest://[resource-path]' }, // 配置模块相关 module: { rules: [ // 配置loaders { test: /\\.jsx?$/, // 匹配规则，匹配文件使用，一般使用正则表达值 include: [path.resolve(__dirname, 'app')], // 只会命中这个目录文件 exclude: [path.resolve(__diranme, 'app/demo-files')], // 命中的时候排除的目录 use: [ // 使用的loader，每一项为一个loader，从该数组的最后一个往前执行 'style-loader', // loader的名称,这样则是使用默认配置，可以在后面加!配置属性，也可以用下面方式 { loader: 'css-loader', // loader的名称 options: {} // loader接受的参数 } ], noParse: [ // 不用解析和处理的模块 RegExp | [RegExp] | function（从 webpack 3.0.0 开始） /jquery|lodash/ ] } ] }, // 配置插件，关于和loader区别见补充4 plugins: [ // 压缩js的plugin new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false, drop_console: false, } }), ], // 解析文件引用的模块的配置 resolve: { // 模块的根目录,默认从node_modules开始找 modules: [ 'node_modules', 'browser_modules' ], // 模块的后缀名，我们引入模块有时候不写扩展名，自动补充扩展名的顺序如下 extensions: ['.js', '.json', '.jsx', '.css'], // 模块解析时候的别名 alias: { // 那么导入模块时则可以写import myComponent from '$component/myComponent'; $component: './src/component', // 末尾加$精确匹配 xyz$: path.resolve(__dirname, 'path/to/file.js') }, // 此选项决定优先使用package.json配置哪份导出文件，详见补充5 mainFields: ['jsnext:main', 'browser', 'main'], // 是否强制导入语句写明后缀 enforceExtension: false, // 是否将符号链接(symlink)解析到它们的符号链接位置(symlink location) symlinks: true, }, // 选择一种 source map 格式来增强调试过程。不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。 devtool: 'source-map', // 配置输出代码的运行环境，可以为async-node，electron-main，electron-renderer，node，node-webkit，web(默认)，webworker target: 'web', externals: { // 使用来自于js运行环境提供的全局变量 jquery: 'jQuery' }, // 控制台输出日志控制 stats: { assets: true, // 添加资源信息 colors: true, // 控制台日志信息是否有颜色 errors: true, // 添加错误信息 errorDetails: true, // 添加错误的详细信息（就像解析日志一样） hash: true, // 添加 compilation 的哈希值 }, devServer: { // 本地开发服务相关配置 proxy: { // 代理到后端服务接口 '/api': 'http://localhost:3000' }, contentBase: path.join(__dirname, 'public'), // 配置devserver http服务器文件的根目录 compress: true, // 是否开启gzip压缩 hot: true, // 是否开启模块热交换功能 https: false, // 是否开启https模式 historyApiFallback: true, // 是否开发HTML5 History API网页，不太理解TODO }, profile: true, // 是否捕捉webpack构建的性能信息，用于分析是什么原因导致的构建性能不佳 cache: false, // 缓存生成的 webpack 模块和 chunk，来改善构建速度。缓存默认在观察模式(watch mode)启用。 cache: { // 如果传递一个对象，webpack 将使用这个对象进行缓存。保持对此对象的引用，将可以在 compiler 调用之间共享同一缓存： cache: SharedCache // let SharedCache = {} }, watch: true, // 是否启用监听模式 watchOptions: { // 监听模式选项 ignored: /node_modules/, // 不监听的文件或文件夹，支持正则匹配，默认为空 aggregateTimeout: 300, 监听到变化后，300ms再执行动作，节流，防止文件更新频率太快导致重新编译频率太快 poll: 1000 // 检测文件是否变化，间隔时间 }, // 输出文件的性能检查配置 perfomance: { hints: 'warning', // 有性能问题时输出警告 hints: 'error', // 有性能问题时输出错误 hints: false, // 关闭性能检查 maxAssetSize: 200000, // 最大文件大小，单位bytes maxEntrypointSize: 400000, // 最大入口文件的大小，单位bytes // 此属性允许 webpack 控制用于计算性能提示的文件。 assetFilter: function(assetFilename) { return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); } } } loader A loader is a node module exporting a function 其中 source 参数是这个 loader 要处理的源文件的字符串 返回经过\"翻译\"后的 webpack 能够处理的有效模块 module.exports = function (source) { // todo return newSource } module: { rules: [ { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] } ] } file-loader 与 url-loader 的区别： file-loader 将文件上的 import / require（）解析为 url，并将该文件发射到输出目录中。 { test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ], }, url-loader 可以识别图片的大小，然后把图片转换成base64，从而减少代码的体积，如果图片超过设定的现在，就还是用 file-loader来处理。如果不在乎体积，不想转换成base64，可以不要配这个loader。这里提一句，不要把字体也用url-loader 来处理，把字体文件转成base64是浏览器无法识别的，这是错误的操作。 { test: /\\.(png|svg|jpg|gif)$/, use: [ 'url-loader?limit=1000&name=image/[hash:8].[name].[ext]' ], }, { test: /\\.(png|jpe?g|gif|bmp)(\\?.*)?$/, use: [ { loader: 'url-loader', options: { limit: 4096000, fallback: { loader: 'file-loader', options: { name: '[name].[hash:8].[ext]' } } } }, ] } 常用 plugin vue.config.js const webpack = require('webpack'); const path = require('path'); const InlineManifestWebpackPlugin = require('inline-manifest-webpack-plugin'); const pkg = require('./package.json'); pkg.version += process.env.VERSION_AUTHOR; const isProduction = process.env.NODE_ENV === 'production'; const isDev = process.env.NODE_ENV === 'development'; const isQatest = process.env.RUN_ENV === 'testing'; const baseUrl = 'https://g.lxstatic.com/dos/merchant/'; const cdnCommon = 'https://g.lxstatic.com/common/'; module.exports = { devServer: { port: 8000, disableHostCheck: true, https: true, }, outputDir: 'www', runtimeCompiler: true, publicPath: (isProduction && !isQatest) ? baseUrl : '/', configureWebpack: { module: { rules: [ { // test是固定写法，不可修改 test: /placeholder_module_config[\\\\/](basic|async)\\.js$/, use: [ { loader: '@lx-frontend/modularize-loader', options: { // 模块文件夹路径，必须是绝对路径。 moduleDir: path.resolve(__dirname, './src/modules'), // 基础模块名称列表，即在模块目录之下，模块文件夹的名称。 basicModules: ['login', 'account', 'store'], only: [], // excludes: [], showWarning: true, }, }, ], }, ], }, }, // 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: (config) => { config.plugin('define') .use(webpack.DefinePlugin, [{ 'process.env.SENTRY_TEST': JSON.stringify(false), // 控制sentry测试 'process.env.PROJECT_VERSION': JSON.stringify(pkg.version), 'process.env.CDN_COMMON': JSON.stringify(cdnCommon), 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV), 'process.env.RUN_ENV': JSON.stringify(process.env.RUN_ENV), // 将要在gitlab上部署的环境 }]); process.env.ANALYZE === 'TRUE' && config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin); // 当处于开发环境时，删除prefetch特性：prefetch会使macbook中的clarles无法正常工作。 if (isDev) { config.plugins.delete('prefetch'); } if (isProduction) { config.optimization .runtimeChunk({ name: 'runtime', }) .splitChunks({ cacheGroups: { // TODO: app.js中包含很多库文件，可将这些文件抽离出来，利于缓存 vue: { test: /[\\\\/]node_modules[\\\\/](vue|vuex|vue-router)[\\\\/]/, priority: -8, name: 'vue', chunks: 'all', }, ele: { test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/, priority: -9, name: 'ele', chunks: 'all', }, echarts: { test: /[\\\\/]node_modules[\\\\/](vue-echarts|zrender|echarts)[\\\\/]/, priority: -10, name: 'echarts', chunks: 'all', }, citydata: { test: /[\\\\/]node_modules[\\\\/]city-data[\\\\/]/, priority: -11, name: 'citydata', chunks: 'all', }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, }, }, }); config.plugin('hashed') .use(webpack.HashedModuleIdsPlugin); config.plugin('inlineManifest') .use(InlineManifestWebpackPlugin); // 如果是正式环境，添加sentry-plugin if (isQatest || !process.env.VERSION_AUTHOR) { return; } } }, }; webpack 构建流程 Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 : 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。 确定入口：根据配置中的 entry 找出所有的入口文件。 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/optimize/":{"url":"pages/webpack/optimize/","title":"optimization","keywords":"","body":"webpack 优化必杀技 动态链接库 var path = require('path'); let webpack = require(\"webpack\"); module.exports = { mode: 'development', entry: { react: ['react', 'react-dom'] }, output:{ filename: '_dll_[name].js', path: path.resolve(__dirname, 'dist'), library: '_dll_[name]', // \"var\" | \"assign\" | \"this\" | \"window\" | \"self\" | \"global\" | \"commonjs\" | \"commonjs2\" | \"commonjs-module\" | \"amd\" | \"amd-require\" | \"umd\" | \"umd2\" | \"jsonp\" | \"system\" // libraryTarget: 'commonjs2'//默认 var }, plugins: [ new webpack.DllPlugin({ name: '_dll_[name]', path: path.resolve(__dirname, 'dist', 'manifest.json') }), new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, 'dist', 'manifest.json') }) ] }; 抽离公共代码块 chainWebpack: (config) => { // 当处于开发环境时，删除prefetch特性：prefetch会使macbook中的clarles无法正常工作。 if (isDev) { config.plugins.delete('prefetch'); } if (isProduction) { config.optimization .runtimeChunk({ name: 'runtime', }) .splitChunks({ cacheGroups: { // TODO: app.js中包含很多库文件，可将这些文件抽离出来，利于缓存 vue: { test: /[\\\\/]node_modules[\\\\/](vue|vuex|vue-router)[\\\\/]/, priority: -8, name: 'vue', chunks: 'all', }, ele: { test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/, priority: -9, name: 'ele', chunks: 'all', }, echarts: { test: /[\\\\/]node_modules[\\\\/](vue-echarts|zrender|echarts)[\\\\/]/, priority: -10, name: 'echarts', chunks: 'all', }, citydata: { test: /[\\\\/]node_modules[\\\\/]city-data[\\\\/]/, priority: -11, name: 'citydata', chunks: 'all', }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, }, }, }); } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/plugin/":{"url":"pages/webpack/plugin/","title":"webpack-plugin","keywords":"","body":"webpack-plugin https://blog.csdn.net/leelxp/article/details/107209190 plugin 模板 Gzip 压缩插件 module.exports = class GzipPlugin { constructor(options){ this.options = options } apply(compiler) { compiler.hooks.emit.tap('zlibPlugin', compilation => { const assets = compilation.getAssets(); for (const file of assets) { if (/\\.js$/.test(file.name)) { const gzipFile = zlib.gzipSync(file.source.children[0]._value, { level: this.option.level || 7 }); compilation.assets[file.name + '.gz'] = { source: function () { return gzipFile; }, size: function () { return gzipFile.length } } } } }) } }; 简体字转繁体字插件 const cnchar = require('cnchar') const trad = require('cnchar-trad') cnchar.use(trad) module.exports = class SimpleToTrad { // 插件配置的参数 constructor(option = {}) { this.option = option } // 固定的 apply(compiler) { compiler.hooks.emit.tap('simpleToTrad', compilation => { const assets = compilation.getAssets(); console.log({assets}) for (const file of assets) { if (/\\.js$/.test(file.name)) { const { source } = compilation.getAsset(file.name) const newFile = cnchar.convert.simpleToTrad(source.source()) compilation.assets[file.name] = { source: function () { return newFile }, size: function () { return newFile.length } } } } }) } } 路劲替换为相对路径 const parser = require(\"@babel/parser\") const traverse = require(\"@babel/traverse\").default const generate = require(\"@babel/generator\").default const { RawSource } = require(\"webpack-sources\") const nodePath = require('path') class RelativeLibPathWebpackPlugin { apply(compiler) { compiler.hooks.emit.tapAsync( 'RelativeLibPathWebpackPlugin', (compilation, callback) => { // 这些文件不用修改了 const excludes = ['runtime.js', 'taro.js', 'custom-wrapper.js', 'comp.js'] // 获取所有的js文件 const jsChunks = compilation.getAssets() .filter(item => /.js$/.test(item.name)) .filter(item => !excludes.includes(item.name)) jsChunks.forEach(chunk => { console.log('updating ', chunk.name) const ast = parser.parse(compilation.assets[chunk.name].source()) // 计算npm文件夹的相对路径 // 在最终的dist目录中，chunk.name是以taro为根目录，npm与taro同级 const relativePath = chunk.name.split('/').map(() => '..').join('/') traverse(ast, { CallExpression(path) { const calleePath = path.get('callee') if (calleePath.node.name === 'require') { const argName = path.get('arguments.0').node.value if (/^__REPLACE__(.+)/.test(argName)) { const newPath = nodePath.join(relativePath, argName.replace('__REPLACE__', '')) console.log('find __REPLACE__', { argName, newPath }) path.get('arguments.0').node.value = newPath } } }, }) const { code: jsCode } = generate(ast, { sourceMaps: false }) compilation.updateAsset(chunk.name, new RawSource(jsCode)) }) callback() } ); } } module.exports = RelativeLibPathWebpackPlugin compiler.hooks compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。 源码路径: /node_modules/webpack/lib/Compiler.js const { Tapable, SyncHook, SyncBailHook, AsyncParallelHook, AsyncSeriesHook } = require(\"tapable\"); class Compiler extends Tapable { constructor() { this.hooks = { /** 在输出 asset 之前调用。返回一个布尔值，告知是否输出。 */ shouldEmit: new SyncBailHook([\"compilation\"]), /** 在 compilation 完成时执行。 */ done: new AsyncSeriesHook([\"stats\"]), /** 这个钩子允许你多做一次构建。 */ additionalPass: new AsyncSeriesHook([]), /** 在开始执行一次构建之前调用，compiler.run 方法开始执行后立刻进行调用。 */ beforeRun: new AsyncSeriesHook([\"compiler\"]), /** 在开始读取 records 之前调用。 */ run: new AsyncSeriesHook([\"compiler\"]), /** 生成资源到 output 目录之前。输出 asset 到 output 目录之前执行。 */ emit: new AsyncSeriesHook([\"compilation\"]), /** 在 asset 被输出时执行。此钩子可以访问被输出的 asset 的相关信息，例如它的输出路径和字节内容。 */ assetEmitted: new AsyncSeriesHook([\"file\", \"content\"]), /** 输出 asset 到 output 目录之后执行。 */ afterEmit: new AsyncSeriesHook([\"compilation\"]), /** 初始化 compilation 时调用，在触发 compilation 事件之前调用。 */ thisCompilation: new SyncHook([\"compilation\", \"params\"]), /** compilation 创建之后执行。 */ compilation: new SyncHook([\"compilation\", \"params\"]), /** NormalModuleFactory 创建之后调用。 */ normalModuleFactory: new SyncHook([\"normalModuleFactory\"]), /** ContextModuleFactory 创建之后调用。 */ contextModuleFactory: new SyncHook([\"contextModulefactory\"]), /** 在创建 compilation parameter 之后执行。 */ beforeCompile: new AsyncSeriesHook([\"params\"]), /** beforeCompile 之后立即调用，但在一个新的 compilation 创建之前。 */ compile: new SyncHook([\"params\"]), /** compilation 结束之前执行。 */ make: new AsyncParallelHook([\"compilation\"]), /** compilation 结束和封印之后执行。 */ afterCompile: new AsyncSeriesHook([\"compilation\"]), /** 在监听模式下，一个新的 compilation 触发之后，但在 compilation 实际开始之前执行。 */ watchRun: new AsyncSeriesHook([\"compiler\"]), /** 在 compilation 失败时调用。 */ failed: new SyncHook([\"error\"]), /** 在一个观察中的 compilation 无效时执行。 */ invalid: new SyncHook([\"filename\", \"changeTime\"]), /** 在一个观察中的 compilation 停止时执行。 */ watchClose: new SyncHook([]), /** 在配置中启用 infrastructureLogging 选项后，允许使用 infrastructure log(基础日志)。 */ infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]), /** 在编译器准备环境时调用，时机就在配置文件中初始化插件之后 */ environment: new SyncHook([]), /** 当编译器环境设置完成后，在 environment hook 后直接调用。 */ afterEnvironment: new SyncHook([]), /** 在初始化内部插件集合完成设置之后调用。 */ afterPlugins: new SyncHook([\"compiler\"]), /** resolver 设置完成之后触发。 */ afterResolvers: new SyncHook([\"compiler\"]), /** 在 webpack 选项中的 entry 配置项 处理过之后，执行插件。 */ entryOption: new SyncBailHook([\"context\", \"entry\"]) }; } } tapable 示例 const { SyncHook, AsyncSeriesHook } = require('tapable'); const hook1 = new SyncHook(['name']); hook1.tap('hello', (name) => { console.log(`hello ${name}`); }); hook1.tap('hello again', (name) => { console.log(`hello ${name}, again`); }); hook1.call('tommy'); const hook = new AsyncSeriesHook(['name']); console.time('cost'); hook.tapAsync('hello', (name, cb) => { setTimeout(() => { console.log(`hello ${name}`); cb(); }, 2000); }); hook.tapPromise('hello again', (name) => { return new Promise((resolve) => { setTimeout(() => { console.log(`hello ${name}, again`); resolve(); }, 2000); }); }); hook.callAsync('tommy', () => { console.log('done'); console.timeEnd('cost'); }); webpack的打包总体来说其实是分为三个阶段：初始化阶段、编译阶段、输出文件阶段 初始化阶段： 初始化参数: 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。 初始化默认参数配置: new WebpackOptionsDefaulter().process(options) 实例化Compiler对象:用上一步得到的参数初始化Compiler实例，Compiler负责文件监听和启动编译。Compiler实例中包含了完整的Webpack配置，全局只有一个Compiler实例。 加载插件: 依次调用插件的apply方法，让插件可以监听后续的所有事件节点。同时给插件传入compiler实例的引用，以方便插件通过compiler调用Webpack提供的API。 处理入口: 读取配置的Entrys，为每个Entry实例化一个对应的EntryPlugin，为后面该Entry的递归解析工作做准备。 编译阶段： run阶段：启动一次新的编译。this.hooks.run.callAsync。 compile: 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上compiler对象。 compilation: 当Webpack以开发模式运行时，每当检测到文件变化，一次新的Compilation将被创建。一个Compilation对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation对象也提供了很多事件回调供插件做扩展。 make:一个新的 Compilation 创建完毕主开始编译 完毕主开始编译this.hooks.make.callAsync。 addEntry: 即将从 Entry 开始读取文件。 _addModuleChain: 根据依赖查找对应的工厂函数，并调用工厂函数的create来生成一个空的MultModule对象，并且把MultModule对象存入compilation的modules中后执行MultModule.build。 buildModules: 使用对应的Loader去转换一个模块。开始编译模块,this.buildModule(module) buildModule(module, optional, origin,dependencies, thisCallback)。 build: 开始真正编译模块。 doBuild: 开始真正编译入口模块。 normal-module-loader: 在用Loader对一个模块转换完后，使用acorn解析转换后的内容，输出对应的抽象语法树（AST），以方便Webpack后面对代码的分析。 program: 从配置的入口模块开始，分析其AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。 文件输出阶段： seal: 封装 compilation.seal seal(callback)。 addChunk: 生成资源 addChunk(name)。 createChunkAssets: 创建资源 this.createChunkAssets()。 getRenderManifest: 获得要渲染的描述文件 getRenderManifest(options)。 render: 渲染源码 source = fileManifest.render()。 afterCompile: 编译结束 this.hooks.afterCompile。 shouldEmit: 所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。this.hooks.shouldEmit。 emit: 确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。 done: 全部完成 this.hooks.done.callAsync。 compiler.hooks 钩子函数可以同步也可以异步的方式处理 [来自于 tapable] // .tap 以同步方式触发钩子 // .tapAsync 以异步方式触发钩子 // .tapPromise 以异步方式触发钩子，返回 promise module.exports = class SyncPlugin { apply(compiler){ // tap 同步 compiler.hooks.emit.tap(\"tap\", (compilation) => { console.log(\"***** tap *****\") }) // tapAsync 参数cb未调用之前进程会暂停 compiler.hooks.emit.tapAsync(\"tapAsync\", (compilation,cb) => { start(0); function start(index){ console.log(index); if(index { start(++index); }, 1000); }else{ cb() } } }) // tapPromise 通过promise的方式调用 compiler.hooks.emit.tapPromise(\"tapPromise\", (compilation)=>{ return new Promise((resolve,reject)=>{ console.log(\"start tap-promise\"); setTimeout(()=>{ resolve() },2000) }) }) } } compilation compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用 源码路径: /node_modules/webpack/lib/compilation.js class Compilation extends Tapable { constructor(compiler) { this.hooks = { /** 在模块构建开始之前触发，可以用来修改模块。 */ buildModule: new SyncHook([\"module\"]), /** 在重新构建一个模块之前触发。 */ rebuildModule: new SyncHook([\"module\"]), /** 模块构建失败时执行。 */ failedModule: new SyncHook([\"module\", \"error\"]), /** 模块构建成功时执行。 */ succeedModule: new SyncHook([\"module\"]), /** 所有模块都完成构建并且没有错误时执行。 */ finishModules: new AsyncSeriesHook([\"modules\"]), /** 一个模块完成重新构建时执行，在都成功或有错误的情况下。 */ finishRebuildingModule: new SyncHook([\"module\"]), /** compilation 对象开始接收新模块时触发。 */ unseal: new SyncHook([]), /** compilation 对象停止接收新的模块时触发 */ seal: new SyncHook([]), /** 依赖优化开始时触发。 */ optimizeDependencies: new SyncBailHook([\"modules\"]), /** 依赖优化之后触发。 */ afterOptimizeDependencies: new SyncHook([\"modules\"]), /** 优化阶段开始时触发。 */ optimize: new SyncHook([]), /** 在模块优化阶段开始时调用。插件可以 tap 此钩子对模块进行优化。 */ optimizeModules: new SyncBailHook([\"modules\"]), /** 在模块优化完成之后调用。 */ afterOptimizeModules: new SyncHook([\"modules\"]), /** 在 chunk 优化阶段开始时调用。插件可以 tap 此钩子对 chunk 执行优化。 */ optimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]), /** chunk 优化完成之后触发。 */ afterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]), /** 在优化依赖树之前调用。插件可以 tap 此钩子执行依赖树优化。 */ optimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]), /** 在依赖树优化成功完成之后调用。 */ afterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]), /** 在树优化之后，chunk 模块优化开始时调用。插件可以 tap 此钩子来执行 chunk 模块的优化。 */ optimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]), /** 在 chunk 模块优化成功完成之后调用。 */ afterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]), /** 调用来决定是否存储 record。返回任何内容 !== false 将阻止执行所有其他 \"record\" 钩子 */ shouldRecord: new SyncBailHook([]), /** 从 record 中恢复模块信息 */ reviveModules: new SyncHook([\"modules\", \"records\"]), /** 在为每个模块分配 id 之前执行。 */ beforeModuleIds: new SyncHook([\"modules\"]), /** 调用来每个模块分配一个 id。 */ moduleIds: new SyncHook([\"modules\"]), /** 在模块 id 优化开始时调用。 */ optimizeModuleIds: new SyncHook([\"modules\"]), /** 在模块 id 优化完成时调用。 */ afterOptimizeModuleIds: new SyncHook([\"modules\"]), /** 从 record 中恢复 chunk 信息。 */ reviveChunks: new SyncHook([\"chunks\", \"records\"]), /** 在为每个 chunk 分配 id 之前执行。 */ beforeChunkIds: new SyncHook([\"chunks\"]), /** 在 chunk id 优化阶段开始时调用。 */ optimizeChunkIds: new SyncHook([\"chunks\"]), /** chunk id 优化结束之后触发。 */ afterOptimizeChunkIds: new SyncHook([\"chunks\"]), /** 将模块信息存储到 record 中。shouldRecord 返回 truthy 值时触发。 */ recordModules: new SyncHook([\"modules\", \"records\"]), /** 将 chunk 存储到 record 中。shouldRecord 返回 truthy 值时触发。 */ recordChunks: new SyncHook([\"chunks\", \"records\"]), /** 在 compilation 添加哈希（hash）之前。 */ beforeHash: new SyncHook([]), /** 在 compilation 添加哈希（hash）之后。 */ afterHash: new SyncHook([]), /** 将有关 record 的信息存储到 records 中。仅在 shouldRecord 返回 truthy 值时触发。 */ recordHash: new SyncHook([\"records\"]), /** 将 compilation 相关信息存储到 record 中。仅在 shouldRecord 返回 truthy 值时触发 */ record: new SyncHook([\"compilation\", \"records\"]), /** 在创建模块 asset 之前执行。 */ beforeModuleAssets: new SyncHook([]), /** 调用以确定是否生成 chunk asset。返回任何 !== false 将允许生成 chunk asset。 */ shouldGenerateChunkAssets: new SyncBailHook([]), /** 在创建 chunk asset 之前。 */ beforeChunkAssets: new SyncHook([]), /** 为 compilation 创建额外 asset。 这个钩子可以用来下载图像。 */ additionalAssets: new AsyncSeriesHook([]), /** 已弃用，可使用 Compilation.hook.processAssets 来代替。 */ optimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]), /** 已弃用，可使用 Compilation.hook.processAssets 来代替。 */ afterOptimizeChunkAssets: new SyncHook([\"chunks\"]), /** 优化存储在 compilation.assets 中的所有 asset。 */ optimizeAssets: new AsyncSeriesHook([\"assets\"]), /** asset 已经优化。 */ afterOptimizeAssets: new SyncHook([\"assets\"]), /** 调用来决定 compilation 是否需要解除 seal 以引入其他文件。 */ needAdditionalSeal: new SyncBailHook([]), /** 在 needAdditionalSeal 之后立即执行。 */ afterSeal: new AsyncSeriesHook([]), /** 触发来为每个 chunk 生成 hash。 */ chunkHash: new SyncHook([\"chunk\", \"chunkHash\"]), /** 一个模块中的一个 asset 被添加到 compilation 时调用。 */ moduleAsset: new SyncHook([\"module\", \"filename\"]), /** 一个 chunk 中的一个 asset 被添加到 compilation 时调用。 */ chunkAsset: new SyncHook([\"chunk\", \"filename\"]), /** 调用以决定 asset 的路径。 */ assetPath: new SyncWaterfallHook([\"filename\", \"data\"]), // TODO MainTemplate /** 调用以决定 asset 在输出后是否需要进一步处理。 */ needAdditionalPass: new SyncBailHook([]), /** 子 compiler 设置之后执行。 */ childCompiler: new SyncHook([ \"childCompiler\", \"compilerName\", \"compilerIndex\" ]), /** 从 webpack v5 开始，normalModuleLoader 钩子已经删除。现在要访问 loader 请改用 NormalModule.getCompilationHooks(compilation).loader。 */ normalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]) }; this.compiler = compiler } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/loader/":{"url":"pages/webpack/loader/","title":"webpack-loader","keywords":"","body":"webpack-loader loader template const loaderUtils = require('loader-utils') const cnchar = require('cnchar') const trad = require('cnchar-trad') cnchar.use(trad) module.exports = function (source) { const option = loaderUtils.getOptions(this); let newSource = '' newSource = cnchar.convert.simpleToTrad(source) const optionKeys = Object.keys(option) optionKeys.length && optionKeys.forEach(key => { newSource = newSource.replace(new RegExp(key, 'g'), option[key]) }) return newSource } loader 参数 https://www.npmjs.com/package/loader-utils const loaderUtils = require('loader-utils') const option = loaderUtils.getOptions(this); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/hmr/":{"url":"pages/webpack/hmr/","title":"hotModuleReplace","keywords":"","body":"webpack热更新 Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。 HMR的好处：节省宝贵的开发时间、提升开发体验。 该有的疑问： 1. 浏览器是如何知道本地代码重新编译了，并迅速请求了新生成的文件？ 2. 是谁告知了浏览器？ 3. 浏览器获得这些文件又是如何热更新成功的？ 4. HotModuleReplacementPlugin干了什么伟大的事情？ 1.刷新一般分为两种 一种是页面刷新，不保留页面状态，就是简单粗暴，直接window.location.reload()。 另一种是基于WDS (Webpack-dev-server)的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。 2.webpack的编译构建过程 3.webpack-dev-server热更新配置 devServer: { hot: true }, plugins: [ new webpack.NamedChunksPlugin(), new webpack.HotModuleReplacementPlugin() ] 4.热更新实现原理 原文地址：https://blog.csdn.net/chern1992/article/details/106893227 额外知识点 ndb调试 websocket memory-fs 内存文件系统 jsonp Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/webpack5/":{"url":"pages/webpack/webpack5/","title":"webpack5新特性","keywords":"","body":"webpack 5 新特性 1.构建速度优化 webpack5，可以通过 cache 特性来将 webpack 工作缓存到硬盘中。存放的路径为 node_modules/.cache/webpack // webpack.config.js module.exports = { cache: { // 1. 将缓存类型设置为文件系统 type: 'filesystem', // 默认是memory // 2. 将缓存文件夹命名为 .temp_cache, // 默认路径是 node_modules/.cache/webpack cacheDirectory: path.resolve(__dirname, '.temp_cache') } } 2.包代码体积的优化 1.代码分割 splitchunk 为了让我们的打出来的包体积更加小，颗粒度更加明确。我们经常会用到 webpack 的代码分割 splitChunks 以及 tree shaking。在 webpack5 中，这两者也得到了优化与加强 splitChunks: { chunks: 'all', minSize: { javascript: 30000, style: 50000, } }, // 默认配置 module.exports = { //... // https://github.com/webpack/changelog-v5#changes-to-the-configuration // https://webpack.js.org/plugins/split-chunks-plugin/ optimization: { splitChunks: { chunks: 'async', // 只对异步加载的模块进行处理 minSize: { javascript: 30000, // 模块要大于30kb才会进行提取 style: 50000, // 模块要大于50kb才会进行提取 }, minRemainingSize: 0, // 代码分割后，文件size必须大于该值 （v5 新增） maxSize: 0, minChunks: 1, // 被提取的模块必须被引用1次 maxAsyncRequests: 6, // 异步加载代码时同时进行的最大请求数不得超过6个 maxInitialRequests: 4, // 入口文件加载时最大同时请求数不得超过4个 automaticNameDelimiter: '~', // 模块文件名称前缀 cacheGroups: { // 分组，可继承或覆盖外层配置 // 将来自node_modules的模块提取到一个公共文件中 （又v4的vendors改名而来） defaultVendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10 }, // 其他不是node_modules中的模块，如果有被引用不少于2次，那么也提取出来 default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } }; 2.Tree Shaking Webpack 不能百分百安全地进行 tree-shaking，webpack4 有些场景是不能将无用代码剔除的。有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的 JavaScript 文件。值得注意的是这些副作用 webpack5 默认会进行 tree-shaking。 3.剔除 npm 包里面针对 Node.js 模块自动引用的 Polyfills v4 编译引入 npm 包，有些 npm 包里面包含针对 nodejs 的 polyfills，实际前端浏览器是不需要的 // index.js import CryptoJS from 'crypto-js'; const md5Password = CryptoJS.MD5('123123'); console.log(md5Password); v5 编译中，会出现 polyfill 添加提示，如果不需要 node polyfille , 按照提示 alias 设置为 false 即可 // webpack.config.js resolve: { // 1.不需要node polyfilss alias: { crypto: false }, // 2.手动添加polyfills // fallback: { // \"crypto\": require.resolve('crypto-browserify') // } } 3.持久化缓存的优化 webpack5 在 production 模式下 optimization.chunkIds 和 optimization.moduleIds 默认会设为 deterministic，webpack 会采用新的算法来计算确定性的 chunkID 和 moduleId。 4.模板联邦 // app_two的webpack 配置 export default { plugins: [ new ModuleFederationPlugin({ name: \"app_two\", library: { type: \"var\", name: \"app_two\" }, filename: \"remoteEntry.js\", exposes: { Search: \"./src/Search\" }, shared: [\"react\", \"react-dom\"] }) ] }; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/vite/":{"url":"pages/webpack/vite/","title":"vite","keywords":"","body":"vite vite 简介 Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 Rollup 打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。 Vite 这个单词是一个法语单词，意思就是轻快的意思。它和我们以前使用 Vue-cli 的作用基本相同，都是项目初始化构建工具，相当于 Vue 项目构建的第二代产品，当然它也包含了项目的编译功能。需要注意一下 Vite 的生产环境下打包是通过 Rollup 来完成的，也就是说 Vite 提供的是开发环境中的编译，打包工作是依靠的 Rollup。 vite 特性 Vite 主打特点就是轻快冷服务启动。冷服务的意思是，在开发预览中，它是不进行打包的。 开发中可以实现热更新，也就是说在你开发的时候，只要一保存，结果就会更新。 按需进行更新编译，不会刷新全部 DOM 节点。这功能会加快我们的开发流程度。 基本使用 step-1: node 版本切换到 >=14.18.0 step-2: 创建项目 npm init vite@latest my-project or yarn create vite my-project vite 原理 当浏览器解析 import HelloWorld from './components/HelloWorld.vue' 时，会向当前域名发送一个请求获取对应的资源（ESM支持解析相对路径）。 Vite 的基本实现原理，就是启动一个 koa 服务器拦截由浏览器请求 ESM 的请求。通过请求的路径找到目录下对应的文件做一定的处理最终以 ESM 的格式返回给客户端。 es-module-lexer 是一个可以对 ES Module 语句进行词法分析的工具包。其底层通过内联 WebAssembly 的方式来实现对 ES Module 语句的快速词法分析。 客户端注入本质上是创建一个 script 标签（type='module'），然后将其插入到 head 中，这样客户端在解析 html 是就可以执行代码了。 import { debounce } from 'lodash' 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图，一共发送了651个请求。Vite 为了优化这个情况，利用 esbuild 在启动的时候预先把 debounce 用到的所有内部模块全部打包成一个bundle，这样就浏览器在请求 debounce 时，便只需要发送一次请求了 当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取。App.vue?type=template 获取 template, App.vue?type=style 获取 style。 vite 插件 vite 插件钩子 通用钩子 在服务器启动时被调用： options buildStart export default (enforce: 'pre' | 'post') => { return { name: 'test', enforce, options(id) { console.log('options', { id }) }, async buildStart(id) { console.log('buildStart', { id }) } } } 在每个传入模块请求时被调用： resolveId + load：虚拟模块，在 node 环境下处理文件然后将数据传给浏览器环境。 transform：文件内容语法转换 export default (enforce: 'pre' | 'post') => { const virtualModuleId = 'virtual:floor' const resolvedVirtualModuleId = '\\0' + virtualModuleId return { name: 'generate', enforce, resolveId(id) { if (id === virtualModuleId) { return resolvedVirtualModuleId } }, load(id) { if (id === resolvedVirtualModuleId) { const gltfPath = `public/3D/gltf/${process.env.place}/inside` const regex = /\\d+/ const fold = fs .readdirSync(gltfPath) .sort((a: string, b: string) => Number(a.match(regex)) - Number(b.match(regex))) .join(\"','\") return `export const msg = ['${fold}']` } } transform(src, id) { if (src.includes('.glb')) console.log('transform', { src, id }) } } } 服务器关闭时被调用： buildEnd closeBundle export default (enforce: 'pre' | 'post') => { return { name: 'delete', enforce, closeBundle() { const gltfPath = `dist/${mode}/${process.env.place}/3D/gltf` fs.readdirSync(gltfPath) // 过滤掉机器人柜子等公用模型文件 .filter((name: string) => !name.includes('.')) // 过滤掉非本医院的模型文件夹 .filter((foldname: string) => foldname !== process.env.place) // 删除其他医院的模型文件及文件夹 .forEach((fold: string) => fs.removeSync(`${gltfPath}/${fold}`)) } } } Vite 独有钩子 config 在 Vite 配置文件被解析后，对配置进行更改或扩展。这个钩子接收一个 ResolvedConfig 对象，该对象表示 Vite 的完整配置，可以更改其中的选项、添加插件、修改插件配置等。 export default (enforce: 'pre' | 'post') => { return { name: 'test', enforce, config(config, { command }) { console.log('config', { config, command }) if (command === 'build') { config.root = 'foo' } } } } configResolved 在 Vite 解析完配置后，修改、扩展配置的机会。该钩子接收一个 ResolvedConfig 类型的参数，该参数包含了 Vite 解析配置后的详细信息，包括各种默认值和合并后的值。 configureServer 在 Vite 启动开发服务器前，修改服务器配置的机会。该钩子接收一个 ServerOptions 类型的参数，该参数包含了 Vite 配置开发服务器的所有选项。你可以在该钩子中修改服务器选项，例如配置代理、自定义中间件等。 configurePreviewServer 在 Vite 启动 HMR websocket 服务器前，修改服务器配置的机会。该钩子与 configureServer 类似，但它仅适用于 HMR websocket 服务器。 transformIndexHtml 用于在生成 HTML 文件之前对 HTML 内容进行转换处理。例如：改变 title 或者添加 script 引入。 const htmlPlugin = () => { return { name: 'html-transform', transformIndexHtml(html) { return html.replace( /(.*?)/, `Title replaced!`, ) }, } } handleHotUpdate 当一个模块发生变化时，Vite 会检测到这个变化，并调用 handleHotUpdate 函数来处理更新。这个函数会根据变化的模块信息，以及其它相关的信息，来生成一个用于更新浏览器页面的消息，从而实现模块的热更新。 vite 插件实际案例 根据环境变量动态生成数据 插件内容 import fs from 'fs-extra' export default (enforce: 'pre' | 'post') => { const virtualModuleId = 'virtual:floor' const resolvedVirtualModuleId = '\\0' + virtualModuleId return { name: 'generate', enforce, resolveId(id) { if (id === virtualModuleId) { return resolvedVirtualModuleId } }, load(id) { if (id === resolvedVirtualModuleId) { const gltfPath = `public/3D/gltf/${process.env.place}/inside` const regex = /\\d+/ const fold = fs .readdirSync(gltfPath) .sort((a: string, b: string) => Number(a.match(regex)) - Number(b.match(regex))) .join(\"','\") return `export const msg = ['${fold}']` } } } } 插件使用 import { msg } from 'virtual:floor' const floor = msg.map((item: string) => ({ label: `${item.match(/\\d+/)}L`, value: item.split('.')[0], disabled: true, percentage: 10 })) console.log(floor) 根据环境变量动态删除多余的模型文件 插件内容 import fs from 'fs-extra' export default (enforce: 'pre' | 'post', mode) => { return { name: 'delete', enforce, closeBundle() { const gltfPath = `dist/${mode}/${process.env.place}/3D/gltf` fs.readdirSync(gltfPath) // 过滤掉机器人柜子等公用模型文件 .filter((name: string) => !name.includes('.')) // 过滤掉非本医院的模型文件夹 .filter((foldname: string) => foldname !== process.env.place) // 删除其他医院的模型文件及文件夹 .forEach((fold: string) => fs.removeSync(`${gltfPath}/${fold}`)) } } } 插件使用 import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import deletePlugin from './plugins/vite-plugin-delete' import generatePlugin from './plugins/vite-plugin-generate' export default ({ mode }) => defineConfig({ ... plugins: [vue(), generatePlugin('pre'), deletePlugin('post', mode)], ... }) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/ndb/":{"url":"pages/webpack/ndb/","title":"ndb","keywords":"","body":"ndb调试node源码 ndb is an improved debugging experience for Node.js, enabled by Chrome DevTools ndb 是一次对 node 调试体验的升级，Chrome DevTools 原生支持 ndb ndb安装 npm install -g ndb 启动ndb 1.直接执行文件 ndb app.js 2.运行一个二进制可执行文件 ndb npm start 3.运行一个项目 ndb . ndb放置断点 和浏览器调试一致 chrome 浏览器调试快速定位文件快捷键： command + p Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/websocket/":{"url":"pages/webpack/websocket/","title":"websocket","keywords":"","body":"websocket 在热更新中的应用 服务端 const express = require('express'); const app = express(); const WebSocketServer = require('ws').Server const chokidar = require('chokidar') wss = new WebSocketServer({ port: 8181 }); wss.on('connection', (ws) => { const watch = chokidar.watch('dist', { persistent: true, ignoreInitial: true, disableGlobbing: false }) watch.on('change', (filePath) => { ws.send('reload') }) }) app.use('/', express.static('./dist')); app.listen(3001); chokidar 是基于 fs.watch 的文件监听第三方库 客户端 const ws = new WebSocket('ws://localhost:8181'); ws.onmessage = function (e) { console.log('message', e.data) window.location.reload() } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/rollup/":{"url":"pages/webpack/rollup/","title":"rollup与soucemap","keywords":"","body":"rollup及source map 基本使用 -c, --config Use this config file (if argument is used but value is unspecified, defaults to rollup.config.js) -d, --dir Directory for chunks (if absent, prints to stdout) -e, --external Comma-separate list of module IDs to exclude -f, --format Type of output (amd, cjs, es, iife, umd, system) -g, --globals Comma-separate list of moduleID:Global pairs -h, --help Show this help message -i, --input Input (alternative to ) -m, --sourcemap Generate sourcemap (-m inline for inline map) -n, --name Name for UMD export -o, --file Single output file (if absent, prints to stdout) -p, --plugin Use the plugin specified (may be repeated) -v, --version Show version number -w, --watch Watch files in bundle and rebuild on changes rollup -w -c rollup.config.js -m rollup.config.js import custom from './plugins/custom.js' export default{ input:'src/index.js', //入口 plugins:[ custom() ], output: { file: 'build/bundle.js', format: 'umd' //兼容 规范 script导入 amd commonjs } } source map 打包后的文件尾部会加上一行代码 //@ sourceMappingURL=bundle.js.map mappings属性 第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。 第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。 第三层是位置转换，以VLQ编码表示，代表该位置对应的转换前的源码位置。 例如: mappings:\"AAAAA,BBBBB;CCCCC\" 表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。 'AAAAA'，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。 - 第一位，表示这个位置在（转换后的代码的）的第几列。 - 第二位，表示这个位置属于sources属性中的哪一个文件。 - 第三位，表示这个位置属于转换前代码的第几行。 - 第四位，表示这个位置属于转换前代码的第几列。 - 第五位，表示这个位置属于names属性中的哪一个变量。 VLQ编码(Variable-length quantity) 原文地址：http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/webpack/gulp/":{"url":"pages/webpack/gulp/","title":"gulp与yargs","keywords":"","body":"gulp 命令行传参 // 命令语句 gulp build --type=mock // gulp任务中获取参数 const gulp = require('gulp') const argv = require('yargs').argv console.log({ argv }) gulp基本用法 /** * 清除文件 */ const argv = require('yargs').argv const fs = require('fs-extra') // 直接导出 const clean = function(done) { const { type } = argv // dist if (type === 'dist') { fs.removeSync('../dist'); } // mock if (type === 'mock') { fs.removeSync('../dist/mock') fs.removeSync('../dist/npm/mockjs') } done() } exports.clean = gulp.series(clean) // api gulp.task('clean', function(done) { const { type } = argv // dist if (type === 'dist') { fs.removeSync('../dist'); } // mock if (type === 'mock') { fs.removeSync('../dist/mock') fs.removeSync('../dist/npm/mockjs') } done() }) gulp常用api gulp.src() // glob gulp.dest() gulp.task('pack', () => {}) exports.pack = pack gulp.watch() exports.watch = watch 流文件处理 through2是对node.js原生stream.Transform进行的封装。源码中定义了一个DestroyableTransform。 一般gulp的插件都会用through2，这是因为gulp使用了vinyl-fs，而vinyl-fs使用了through2。 const gulp = require('gulp'); const through = require('through2'); gulp.src(\"./src/*.js\") .pipe(minify()) .pipe(through.obj(function (chunk, enc, cb) { console.log('chunk', chunk) cb(null, chunk) })) gulp热更新之watch const gulp = require('gulp'); gulp.task('watch', () => { const watcher = gulp.watch(\"./src/*.js\", pack) watcher.on('change', function(event) { console.log({ event }) }); }) 任务流程控制 gulp.series 任务将按顺序执行 gulp.parallel 任务将并发执行 gulp.src glob 匹配规则 gulp 内部使用了 node-glob 模块来实现其文件匹配功能。 第一个参数是文件匹配模式，用来匹配文件路径(包括文件名)，直接是某个具体的文件路径，也可以是一个数组。 还有一个 options 参数 pattern 含义 * 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾 ** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。 ? 匹配文件路径中的一个字符(不会匹配路径分隔符) […] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法 “{}” 匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)； !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)? +(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern) pattern 示例 * 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js *.* 能匹配 a.js,style.css,a.b,x.y */*/*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js ** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,在未尾时能用来匹配所有的目录和文件 **/*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.js a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js,b.js,c.js a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js 多种匹配模式时，使用数组 gulp.src([‘js/.js’, ‘css/.css’, ‘*.html’]) 排除模式 gulp.src([*.js, ‘!b*.js’]) // 匹配所有js文件，但排除掉以b开头的js文件 gulp.src([‘!b*.js’, *.js]) // 不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 展开模式 a{b,c}d 会展开为 abd,acd a{b,}c 会展开为 abc,ac a{0..3}d 会展开为 a0d,a1d,a2d,a3d a{b,c{d,e}f}g 会展开为 abg,acdfg,acefg a{b,c}d{e,f}g 会展开为 abdeg,acdeg,abdeg,abdfg options参数 options： 类型(可选)：Object，有3个属性buffer、read、base options.buffer： 类型：Boolean 默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用； options.read： 类型：Boolean 默认：true 设置false，将不执行读取文件操作，返回null； options.base： 类型：String 设置输出路径以某个路径的某个组成部分为基础向后拼接 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/codeReview/":{"url":"pages/codeReview/","title":"Code Review","keywords":"","body":"Code Review 标准待制定 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/codeReview/cyclomaticComplexity/":{"url":"pages/codeReview/cyclomaticComplexity/","title":"Cyclomatic Complexity","keywords":"","body":"Cyclomatic Complexity 1. 定义 圈复杂度 (Cyclomatic complexity) 是一种代码复杂度的衡量标准，也称为条件复杂度或循环复杂度，它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。简称 CC。 2. 衡量标准 代码复杂度低，代码不一定好，但代码复杂度高，代码一定不好。 1 - 10: 清晰 10 - 20: 复杂 20 - 30: 非常复杂 30+ : 不可读 3. 圈复杂度检测方法 3-1. eslint规则 module.exports = { root: true, parserOptions: { ecmaVersion: 7, sourceType: \"module\" }, parser: \"vue-eslint-parser\", plugins: [ 'html' ], 'rules': { 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, complexity: [ 'warn', { max: 1 } ] } } 3-2. CLIEngine const eslint = require('eslint'); console.log(eslint) const { CLIEngine } = eslint; const cli = new CLIEngine({ parserOptions: { ecmaVersion: 2018, }, rules: { complexity: [ 'error', { max: 0 } ] } }); const reports = cli.executeOnFiles(['.']).results; console.log({ reports }) 3-3. c-scan // npm i c-scan --save const scan = require('c-scan'); scan({ extensions:'**/*.js', rootPath:'src', defalutIgnore:'true', ignoreRules:[], ignoreFileName:'.gitignore' }).then(res => { console.log({ res }) }); 3-4. c-complexity // npm i c-complexity --save const cc = require('c-complexity'); cc({},0).then(res => { console.log({ res }, res.result) }); 3-5. conard(cli 工具) // npm i conard -g conard cc conard cl Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/projects/":{"url":"pages/projects/","title":"Projects","keywords":"","body":"STAR 法则 Situation（情景）; Task（任务）; Action（行动）; Result（结果）; XXX 项目出现 XXX 问题，我作为 XXX，负责其中的 XXX 部分，我通过 XXX 方式（或技术方案）成功解决了该问题，使 XXX 提高了 XXX，XXX 增长了 XXX。 做过的项目 拍卖小程序埋点 集团数据中心(按需加载、ui中间层) websocket大屏展示/拍卖/webpack 热更新通讯 lxs-cli脚手架 前端样式生成系统 uni-app升级 typescript/router限制 storybook + 组件库中间层 + lerna gitlab CI/CD 小程序代码上传后台 websocket 改造 框架升级 wepy -> taro 服务端渲染 国际化 canvas 可视化配置 拍卖小程序 数据埋点，wx.getRealtimeLogManager() 国际化 i18n -> translate 框架升级 wepy -> taro 签合同线下改在线 拍卖出价方式由轮询改为 websocket 为主流程添加自动化测试 版本自动更新 图片上传CDN 项目分包 CI/CD 改造 自动化代码上传 拍卖动画及音效 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/":{"url":"pages/interview/","title":"Interview","keywords":"","body":"目的 面试驱动学习 学习项目 ucma: wepy -> taro wrap-element-ui low-code threeJS particles 前端核心面试题 rem 原理 组件库设计，按需引入 MVVM AST NODE 错误处理，进程守护 koa 中间件 事件循环 ✅ cdn 回源策略，cdn 部署，节点 🔥 ✅ xss 和 csrf， 攻击原理和防范方式 🔥 http1.0, http1.1, http2.0, https 的区别 🔥 ✅ https 如何实现安全通讯 ✅ 常用的加密算法，安全等级排序 对称加密和非对称加密的区别，https 证书的作用 ✅ 浏览器渲染机制，事件处理机制 小程序异常监控，染色测试 nginx 负载均衡，常用 nginx 负载均衡算法。延伸场景：单点登录 requestAnimation 的作用说明，重排和重绘 简单请求和复杂请求的区别 vue nextTick 实现原理 ✅ vue 数组双向绑定 【push、pop、shift、unshift、reverse、sort、splice】 浏览器缓存，协商缓存，强缓存 ✅ 性能优化，首屏时间优化策略，各个指标的计算 js weakMap vs map hashmap 的实现方式和数据结构 part-1 Vue2、Vue3 与 React 的区别 ssr: Nuxt.js 用不了的生命周期？ axios如何做node、浏览器？ 大文件下载暂停 前端工程化: webpack babel: polyfill 优化的指标: 计算首屏时间 前端错误监控: sentry git: husky 原理 微前端 单元测试 part-2 Promise.all 和 Promise.race ✅ 深浅拷贝 ✅ Set 和 Map ✅ 原型链与继承 闭包 防抖节流 发布订阅 性能优化及指标 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/eventLoop/":{"url":"pages/interview/eventLoop/","title":"事件循环","keywords":"","body":"你了解浏览器的事件循环吗？ 1. 为什么js在浏览器中有事件循环机制？ js是单线程的 event loop 2. 有哪两种任务？ 宏任务：整体代码，setTimeout，setInterval，setImmediate(node + ie)，MessageChannel，requestAnimationFrame,I/O操作，UI rendering，script（整体代码） 微任务：new Promise().then，queueMicrotask，MutationObserver(监听 dom 更新)，process.nextTick(node) 3. 为什么要引入微任务的概念，只有宏任务可以吗？ 宏任务：先进先出，每执行一个宏任务后都会把所有的微任务清掉，就是插队。 4. 一个完整的 Event Loop 过程，包括哪些阶段？ a. 执行并出队一个 macro-task。注意如果是初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。这时首先执行并出队的就是 script 脚本； b. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。这个过程本质上是队列的 macro-task 的执行和出队的过程； c. 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空； d. 执行渲染操作，更新界面； e. 检查是否存在 Web worker 任务，如果有，则对其进行处理。 5. Node中的事件循环和浏览器中的事件循环有什么区别？ node v10 之后与浏览器中的事件循环趋同，这里的趋同指的是宏任务的执行机制。v10 之前不一样。 node v10 之前，清空当前阶段对应宏任务队列里的所有任务，而浏览器的宏任务队列是一个一个清空的，每个宏任务之间，还会去清空微任务队列。 Node 三个组成部分 应用层：这一层就是我们最熟悉的 Node.js 代码，包括 Node 应用以及一些标准库。 桥接层：Node 底层是用 C++ 来实现的。桥接层负责封装底层依赖的 C++ 模块的能力，将其简化为 API 向应用层提供服务。 底层依赖：这里就是最最底层的 C++ 库了，支撑 Node 运行的最基本能力在此汇聚。其中需要特别引起我们注意的就是 V8 和 libuv： V8 是 JS 的运行引擎，它负责把 JavaScript 代码转换成 C++，然后去跑这层 C++ 代码。 libuv：它对跨平台的异步I/O能力进行封装，Node 中的事件循环就是由 libuv 来初始化的。 libuv 中的 Event-Loop 实现 https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/ timers（定时器阶段）：执行 setTimeout 和 setInterval 中定义的回调； pending callbacks（待定回调阶段）：直译过来是“被挂起的回调”，如果网络I/O或者文件I/O的过程中出现了错误，就会在这个阶段处理错误的回调（比较少见，可以略过）； idle, prepare：仅系统内部使用。这个阶段我们开发者不需要操心。（可以略过）； poll（轮询阶段）：重点阶段，这个阶段会执行I/O回调，同时还会检查定时器是否到期； check（检查阶段）：处理 setImmediate 中定义的回调； close callbacks（关闭回调函数阶段）：处理一些“关闭”的回调，比如socket.on('close', ...)就会在这个阶段被触发。 Node 事件循环各个阶段 a. 执行全局的 Script 代码（与浏览器无差）； b. 把微任务队列清空：注意，Node 清空微任务队列的手法比较特别。在浏览器中，我们只有一个微任务队列需要接受处理；但在 Node 中，有两类微任务队列：next-tick 队列和其它队列。其中这个 next-tick 队列，专门用来收敛 process.nextTick 派发的异步任务。在清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务； c. 开始执行 macro-task（宏任务）。注意，Node 执行宏任务的方式与浏览器不同：在浏览器中，我们每次出队并执行一个宏任务；而在 Node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务（除非达到了系统限制），v10 之后与浏览器一致了； Poll 阶段对定时器的处理 poll 队列不为空。直接逐个执行队列内的回调并出队、直到队列被清空（或者到达系统上限）为止； poll 队列本来就是空的。它首先会检查有没有待执行的 setImmediate 任务，如果有，则往下走、进入到 check 阶段开始处理 setImmediate；如果没有 setImmediate 任务，那么再去检查一下有没有到期的 setTimeout 任务需要处理，若有，则跳转到 timers 阶段。 6. 什么是 MutationObserver？ Mutation Observer API 用来监视 DOM 变动。比如节点的增减、属性的变动、文本内容的变动。它是一个微任务。 当你使用 observer 监听多个 DOM 变化时，并且这若干个 DOM 发生了变化，那么 observer 会将变化记录到变化数组中，等待一起都结束了，然后一次性的从变化数组中执行其对应的回调函数。 // Firefox和Chrome早期版本中带有前缀 const MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver // 选择目标节点 const target = this.$refs.bi; // 创建观察者对象 const observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { console.log('mutation', mutation); }); }); // 配置观察选项: const config = { attributes: true, childList: true, characterData: true, attributeFilter: ['class', 'id'] } // 传入目标节点和观察选项 observer.observe(target, config); // 停止观察 // observer.disconnect(); config 参数 属性 描述 childList 子节点 attributes 属性 characterData 节点内容或节点文本 subtree 后代节点 attributeOldValue 表示观察attributes变动时，是否需要记录变动前的属性值 characterDataOldValue 表示观察characterData变动时，是否需要记录变动前的值 attributeFilter 特定属性 【除了 attributeFilter 的类型为数组，其他参数均为布尔值】 MutationRecord 对象 [例子中打印的 mutation] type：观察的变动类型（attribute、characterData或者childList）。 target：发生变动的DOM节点。 addedNodes：新增的DOM节点。 removedNodes：删除的DOM节点。 previousSibling：前一个同级节点，如果没有则返回null。 nextSibling：下一个同级节点，如果没有则返回null。 attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。 oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/deepClone/":{"url":"pages/interview/deepClone/","title":"深浅拷贝","keywords":"","body":"浅拷贝与深拷贝 js 数据类型 基本数据类型：string, number, boolean, null, undefine, symbol 引用数据类型：object, array, function 区别： 基本数据类型存储在栈内存中。 引用数据类型在栈内存中存储的的是应用地址，这个应用地址指向堆内存对象。 赋值，浅拷贝和深拷贝 赋值：基本数据类型没问题，引用数据类型会指向同一个堆内存地址。 浅拷贝：引用数据类型的浅拷贝，只会拷贝第一层。 Array.concat() Object.assign() es6 解构 const clone = source => { if (Object.prototype.toString.call(source)=== '[object Object]') { const newObj = {} for (let i in source) { if (source.hasOwnProperty(i)) { newObj[i] = source[i] } } return newObj } if (Object.prototype.toString.call(source)=== '[object Array]') { const newArr = [] for (let [i, item] of source.entries()) { newArr[i] = item } return newArr } } const objects = {test: [{ 'a': 1 }, { 'b': 2 }]}; const newObj = clone(objects); console.log({ objects, newObj }, newObj.test === objects.test); const arr = [{ 'a': 1 }, { 'b': 2 }]; const newArr = clone(arr); console.log({ arr, newArr }, newArr[0] === arr[0]); 深拷贝：引用数据类型的深拷贝，不仅会拷贝第一层，还会递归深层次拷贝。 JSON.parse()和JSON.stringify() 无法识别 Symbol 类型, 无法识别循环引用的问题。 递归 特别注意：arr.entries() 是数组特有的方法，Object.entries(target) 适合数组和对象。 Object.prototype.toString.call: 判断数据类型 Object.prototype.toString.call(Symbol()) === '[object Symbol]' Object.prototype.toString.call(new Date()) === '[object Date]' Object.prototype.toString.call(new RegExp()) === '[object RegExp]' Object.prototype.toString.call(null) === '[object Null]' const deepClone = target => { let result, targetType = Object.prototype.toString.call(target) if (targetType === '[object Object]') { result = {} } else if (targetType === '[object Array]') { result = [] } else { return target } for (let [key, value] of Object.entries(target)) { result[key] = deepClone(value) } return result } const objects = {test: [{ 'a': 1 }, { 'b': 2 }]}; const newObj = deepClone(objects); console.log(newObj.test[0]) 上面的深拷贝代码，未考虑各种特殊类型的数据，例如：Date、RegExp、Symbol，最重要的是未考虑循环引用的问题。 for (let [key, value] of Object.entries(obj)) 无法识别 Symbol 作为 key 的情形 WeakMap 的特性：弱引用，游离于垃圾回收机制以外; hash.add() hash.has() Object.keys() 与 Reflect.ownKeys() 的区别：Reflect.ownKeys() 可以遍历对象和数组 typeof: 判断数据类型 typeof null === 'object' typeof new Date() === 'object' typeof new RegExp() === 'object' typeof Symbol() === 'symbol' typeof function() {} === 'function' const deepClone = (obj, hash = new WeakSet()) => { if (obj === null) { return null } if (obj instanceof Date) { return new Date(obj) } if (obj instanceof RegExp) { return new RegExp(obj) } if (typeof obj !== 'object') { return obj } console.log({ hash, obj }) if (hash.has(obj)) { return undefined } const resObj = Array.isArray(obj) ? [] : {} hash.add(obj) Reflect.ownKeys(obj).forEach(key => { resObj[key] = deepClone(obj[key], hash) }) return resObj } 深浅拷贝函数参数判断：对象和数组的判断方法 instanceof const arr = [1, 2, 3, 4] const obj = { a: 1 } console.log(arr instanceof Array) console.log(obj instanceof Object) console.log(arr.__proto__ === Array.prototype) console.log(obj.__proto__ === Object.prototype) constructor const arr = [1, 2, 3, 4] const obj = { a: 1 } console.log(arr.constructor === Array) console.log(obj.constructor === Object) toString const arr = [1, 2, 3, 4] const obj = { a: 1 } console.log(Object.prototype.toString.call(arr) === '[object Array]') console.log(Object.prototype.toString.call(obj)=== '[object Object]') Array.isArray() const arr = [1, 2, 3, 4] const obj = { a: 1 } console.log(Array.isArray(arr)) console.log(Array.isArray(obj)) length const arr = [1, 2, 3, 4] const obj = { a: 1 } console.log(typeof arr && !isNaN(arr.length)) console.log(typeof obj && !isNaN(obj.length)) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/CDN/":{"url":"pages/interview/CDN/","title":"CDN","keywords":"","body":"CDN (Content Delivery Network) 内容分发网络 CDN 回源策略 当用户访问一个 url 的时候，如果被解析到的那个 CDN 节点没有缓存需要响应的内容，或者说缓存到期了，就会回源站去获取。如果没有人访问，那么 CDN 节点是不会主动去源站拿的。 通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用域名回源方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。 什么是域名回源？ 域名回源就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容而不是存在各个节点（CDN）上的缓存内容。 如何配置？ 源站和回源HOST的区别： 源站：源站决定了回源时请求到的具体IP地址。 回源HOST：回源HOST决定了回源请求访问到该IP地址上的具体站点。 回源HOST即回源域名，当源站服务器上提供多个域名服务时，CDN节点回源时在源站访问的具体站点域名。 例子一：源站是域名【域名回源】 如果源站为 www.a.com，回源 HOST 为www.b.com。那么实际回源是请求到 www.a.com 解析到的 IP 地址其对应主机上的 www.b.com 站点。 例子二：源站是IP地址【ip回源】 源站为1.1.1.1，回源 HOST 为 www.b.com。那么实际回源的是1.1.1.1对应主机上的 www.b.com 站点。 cdn 部署 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/safety/":{"url":"pages/interview/safety/","title":"网络安全","keywords":"","body":"网络安全 xss 和 csrf 的区别 XSS（Cross Site Scripting）：跨域脚本攻击 CSRF（Cross-site request forgery）：跨站请求伪造 区别一： CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。 区别二：（原理的区别） CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。 XSS的攻击方式 1、反射型 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。 2、存储型存 储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。 防范方式 CSRF如何防御 方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个token； （2）客户端提交的表单中带着这个token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌： 把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。 方法三、Referer 验证： Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。 XSS的防范措施主要有三个： 1、编码： 对用户输入的数据进行 HTML Entity 编码。 2、过滤： 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正 避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签 CSP https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP https://juejin.cn/post/6844903780228530183 https://www.cnblogs.com/itsuibi/p/10752868.html 实际项目做法 pc 端： csrf-token=1632470165##4090b1b6900c78d6136537e4af4a41337a241f2a; 扫码前：session=cc40ca33-4bef-4425-976b-d6cedbe3f33f; 扫码后：session=cc40ca33-4bef-4425-976b-d6cedbe3f33f; CSRF (Cross-site request forgery) Token：通常是植入到页面中的一串随机字符串，每次请求都会变，提交表单的时候带上。服务器可以通过一定的规则来校验是否是自己发出的，。因为只有己方的网页有合法的 CSRF-Token，己方网页上的表单提交可以正常通过。这一操作是为了避免表单提交被第三方网站伪造，进而给用户造成损失。 session 本身是用户跟服务器建立会话之后，服务器生成的一串随机字符串，相当于用户会话ID，请求中有这个session，则表示请求是这个用户的这次会话中发出的，相当于临时身份证。 客户端用企业微信扫码登录前后 session 是一样的，因为登陆后，服务器把该会话与该用户绑定，在服务端完成，用户从 session 看不出来。 csrf-token 并发请求的时候，如何解决因为 token 刷新只有一次请求成功的问题 每次 csrf-token 刷新后，设置一个宽限时间，让其在 n 秒之内仍然可用即可。 https://juejin.cn/post/6844903689602220046 小程序： access-token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MzIzOTYxNDgsInd1aWQiOjg4ODUsInVzZXJfaWQiOjExNzYsImFwcGlkIjoid3g0NjJlZWMzNGY4ZDExZDU2In0.42K3lvTqDlJAcx2jCDvs_meS_nDFF10gPXAgLI_hM5o https://jwt.io/#debugger-io 采用 JWT 加密， 由三部分构成，header（头部）、payload（载荷）和 signature（签名）。 头部 { \"typ\": \"JWT\", \"alg\": \"HS256\" } typ 属性表示令牌的类型，JWT令牌统一写为 JWT。 alg 属性表示签名使用的算法，默认为HMAC SHA256（写为HS256); 有效载荷 JWT 的主体内容部分，也是一个JSON对象，包含需要传递的数据。 { \"exp\": 1632396148, // expired_at 过期时间 \"wuid\": 8885, // weixin_user_id 微信用户 id \"user_id\": 1176, // 我们自己的用户 id \"appid\": \"wx462eec34f8d11d56\" } 签名 签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。 首先，需要指定一个密码（secret），该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名。 HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload),secret) jwt-simple 例子： const jwt = require('jwt-simple'); const payload = { appid: 'wx462eec34f8d11d56' }; const secret = '033Yo2000puDtM1Ipd300FpWau4Yo20S'; // HS256 secrets are typically 128-bit random strings, for example hex-encoded: // var secret = Buffer.from('fe1a1915a379f3be5394b64d14794932', 'hex') // encode const token = jwt.encode(payload, secret); console.log(token); // decode const decoded = jwt.decode(token, secret); console.log(decoded); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-14 23:27:21 "},"pages/interview/http/":{"url":"pages/interview/http/","title":"http问题","keywords":"","body":"http1.0, http1.1, http2.0, https 的区别 https://www.cnblogs.com/heluan/p/8620312.html HTTP 1.0/1.1/2.0在并发请求上主要区别是什么? HTTP/1.0：每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接. HTTP/1.1：默认采用持续连接(TCP连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive).增加了管道机制，在同一个TCP连接里，允许多个请求同时发送，但响应还是要按顺序返回，存在队头阻塞的问题。 HTTP/2.0：加了双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求。 使用多路复用的技术，每个二进制帧的头部帧都有一个 ID 来标识属于哪个流。成功解决队头阻塞问题。 HTTP1.0 和 HTTP1.1 的缓存策略区别？ HTTP/1.0：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since, Expires 来做为缓存判断的标准。 HTTP/1.1：HTTP1.1 引入了更多的缓存控制策略例如：Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 HTTP2.0 对性能进行了哪些改进？ 二进制分帧： 在 HTTP1.x 中，数据以文本的格式进行传输，解析起来比较低效。 HTTP2.0 在传输消息时，首先会将消息划分为更小的消息和帧，然后再对其采取二进制格式的编码，确保高效的解析。 https://blog.csdn.net/weixin_34122604/article/details/91443727 头部压缩: HTTP2.0 中，客户端和服务器分别会维护一份相同的静态字典，这个字典用来存储常见的头部名称，以及常见的头部名称和值的组合。同时还会维护一份相同的动态字典，这个字典可以实时被更新。 如此一来，第一次相互通信过后，后面的请求只需要发送与前面请求之间头部不同的地方，其它的头部信息都可以从字典中获取。相对于 HTTP1.x 中每次都要携带整个头部跑来跑去的笨重操作来说，大大节省了网络开销。 多路复用: 请求与请求间完全不阻塞，A 请求的响应就算没回来，也不影响 B 请求收到自己的响应。请求与请求间做到了高度的独立，真正实现了并行请求。由此，彻底规避了队头阻塞问题。 服务端推送: 允许服务器主动向客户端 push 资源。 浏览器缓存策略是怎么样的？强缓存和协商缓存的区别有哪些？ 强缓存：直接从缓存中获取资源，不会再与服务端发生通信 expires expires: Wed, 11 Sep 2019 16:12:18 GMT expires 是一个时间戳，对比本地时间与 expires 设定的过期时间来判断是否直接去缓存中取资源。问题：服务器与客户端可能存在时差。 cache-control cache-control: max-age=31536000 Cache-Control 中，我们通过 max-age 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度，单位是：秒。 注意: max-age 是一个相对时间，这就意味着它有能力规避掉 expires 可能会带来的时差问题：max-age 机制下，资源的过期判定不再受服务器时间戳的限制。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的两个时间节点（起始时间和当前时间）都来源于客户端，由此便能够实现更加精准的判断。 Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 cache-control: max-age=3600, s-maxage=31536000 s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。 cache-control: public max-age=3600, s-maxage=31536000 public & private 如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。 cache-control: no-cache no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，走协商缓存的路线。 cache-control: no-store no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。 协商缓存：浏览器需要向服务器去询问缓存的相关信息，进而判断是否重新发起请求 Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT Last-Modified & If-Modified-Since Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回。 If-Modified-Since 每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值。 使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景： 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。 ETag: W/\"2a3b-1602480f459\" If-None-Match: W/\"2a3b-1602480f459\" Etag & If-None-Match Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。当首次请求时，我们会在响应头里获取到一个最初的标识符字符串。 If-None-Match 下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对，它的值正是上一次 response 返回给它的 Etag 值。 Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。 说下对 https 的理解，以及与 http 的区别有哪些？ HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，主要解决了防劫持的一个大问题。 明文传输：刚开始的 http 就是明文传输，客户端发送请求，服务端发送响应，双方都不对自己的请求/响应内容做加密的情况。这种情况下，请求/响应一旦被中间人（比如邱小冬）拦截，就可以对其中的内容一览无余、为所欲为。 对称加密：客户端和服务器约定一个共同的“公钥”，加密和解密都依赖这一个公钥这种情况。这种情况下，一旦公钥失窃了，那么双方传输的密文信息就会再次进入裸奔状态，仍然无法规避中间人的攻击。 非对称加密：公钥+私钥配合加密。公钥和私钥是多对一的关系，公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开。这样一来，就算中间人截获了公钥，但由于手里没有私钥，仍然没法正确地对数据进行解密。即便如此，仍然没办法完全规避中间人伪造公钥的这种场景，所以我们还需要第三方认证。 第三方认证：CA（Catificate Authority）。它的作用就是提供证书，证书中包含的主要信息有：域名、公司信息、序列号、签名信息。客户端获取到证书里的机构信息之后，就会取出对应机构的公钥来解析证书里的签名和服务器发来的公钥信息。用签名来校验对方的身份，若校验通过，就可以顺利地使用当前解读出的公钥进行通信了。这个过程，就是“第三方认证”。 https 流程 step-1: 客户端访问一个 https 协议的网站 step-2: 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 step-3: 客户端的\"证书管理器\"，有\"受信任的根证书颁发机构\"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。受信任证书验证： 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出警告。 step-4: 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 如何解决跨域的问题？ 同源策略：同源指的是在url中协议、域名、端口号均相同。同源策略是浏览器的一个安全功能，不同源的脚本在没有明确授权的情况下，不能读写对方资源。主要限制了以下三个方面： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 跨域解决方案： JSONP CORS：全称是\"跨域资源共享\"（Cross-origin resource sharing） Access-Control-Allow-Origin: * CORS 和 JSONP 的对比: CORS 的优势，往往是相对于 JSONP 来说的：JSONP只支持GET请求，而CORS支持所有类型的HTTP请求。但相应地，JSONP在低版本 IE 上也可以畅通无阻，CORS 就没有这么好的兼容性了。 postMessage 跨域 iframe 跨域 cookie 跨域 反向代理跨域 http 与 cookie 的关系？ HTTP 是⼀种⽆状态协议, 在单纯HTTP这个层⾯，协议对于发送过的请求或响应都不做持久化 处理 使⽤Cookie做状态管理: 服务端返回的头信息上有可能会携带Set-Cookie, 那么当客户端接收到响应后, 就会在本地种上 cookie. 在下⼀次给服务端发送请求的时候, 就会携带上这些cookie。 常用的加密算法有哪些？请按安全等级排序。 https://blog.csdn.net/baidu_22254181/article/details/82594072 https://www.cnblogs.com/wjrblogs/p/13730128.html MD5 算法 SHA1 算法 HMAC 算法 AES 算法 DES 算法 3DES 算法 RSA 算法 ECC 算法 http 与 ws 的区别 先看看一个最简单的 websocket 的例子： 客户端 Document const ws = new WebSocket('ws://localhost:8181'); ws.onmessage = function (e) { console.log('message', e.data) } 服务端 const WebSocketServer = require('ws').Server wss = new WebSocketServer({ port: 8181 }); wss.on('connection', (ws) => { setInterval(() => { ws.send('reload') }, 1000) }) 区别 单向与双向： HTTP是单向的，客户端发送请求，服务器发送响应。 WebSocket是双向的，与HTTP不同，它以ws://或wss://开头。 协议状态： HTTP是在TCP之上运行的无状态协议，TCP是一种面向连接的协议，它使用三向握手方法保证数据包传输的传递并重新传输丢失的数据包。 WebSocket在客户端-服务器通信的场景中使用的全双工协议，它是一个有状态协议，这意味着客户端和服务器之间的连接将保持活动状态，直到被任何一方终止。 实际应用例子 拍卖小程序：https://github.com/weapp-socketio/weapp.socket.io 实际例子：拍卖大厅 const io = require('./weapp.socket.io.js') const socketIoUrl = 'https://lxcx.com/auction_car' const socketEvents = [ { name: 'connect', // 连接成功，包括重连成功都会触发. handle: this.socketOnConnect }, { name: 'disconnect', handle: this.socketOnDisconnect }, { name: 'reconnect_attempt', handle: this.socketOnReconnectAttempt }, { name: 'connect_error', handle: this.socketOnConnectError }, { name: 'reconnecting', handle: this.socketOnReconnecting }, { name: 'error', // 发生错误时触发。比如 后端return false时触发。error (Object) error object handle: this.socketOnError }, { name: 'pong', // 心跳包 handle: this.socketOnPong }, { name: 'bidding', // 有人出价广播 handle: this.socketOnBidding }, { name: 'bid_latest_info_resp', // 拉取最新的拍卖信息 handle: this.socketOnLatestInfo }, { name: 'unsold', // 流拍广播 handle: this.socketBiddingOnCompleted }, { name: 'sold', // 拍卖结束广播 handle: this.socketBiddingOnCompleted }, { name: 'sync_resp_info', // emit发送后的回应 handle: this.socketOnResp } ] // 判断避免重复创建socket实例。 if (this.socketIsExist) { this.joinAuctionRoom() return } const accessToken = wx.getStorageSync('access_token') // 创建连接 const socket = io(this.socketIoUrl, { transports: ['websocket'], timeout: 10000, // 连接超时上线 query: { access_token: accessToken, user_id: this.userId, name: this.userName } }) // 绑定事件 this.socketEvents.forEach((element) => { socket.on(element.name, element.handle.bind(this)) }) 官方例子：聊天室 const io = require('./yout_path/weapp.socket.io.js') const socketIoUrl = 'https://socket-io-chat.now.sh' // const socket = io(socketIoUrl, { // transports: ['websocket'], // timeout: 10000, // 连接超时上线 // query: { // access_token: '...', // user_id: 1, // name: 'Jack' // } // }) const socket = io(socketIoUrl) socket.on('connect', () => { console.log('connection created.') }); socket.on('new message', d => { const { username, message } = d; console.log('received: ', username, message) }); /** * Aboud connection */ socket.on('connect', () => { this.popMessage() this.pushMessage(createSystemMessage('连接成功')) }) socket.on('connect_error', d => { this.pushMessage(createSystemMessage(`connect_error: ${d}`)) }) socket.on('connect_timeout', d => { this.pushMessage(createSystemMessage(`connect_timeout: ${d}`)) }) socket.on('disconnect', reason => { this.pushMessage(createSystemMessage(`disconnect: ${reason}`)) }) socket.on('reconnect', attemptNumber => { this.pushMessage( createSystemMessage(`reconnect success: ${attemptNumber}`) ) }) socket.on('reconnect_failed', () => { this.pushMessage(createSystemMessage('reconnect_failed')) }) socket.on('reconnect_attempt', () => { this.pushMessage(createSystemMessage('正在尝试重连')) }) socket.on('error', err => { this.pushMessage(createSystemMessage(`error: ${err}`)) }) /** * About chat */ socket.on('login', d => { this.pushMessage( createSystemMessage(`您已加入聊天室，当前共有 ${d.numUsers} 人`) ) }) socket.on('new message', d => { const { username, message } = d this.pushMessage(createUserMessage(message, username)) }) socket.on('user joined', d => { this.pushMessage( createSystemMessage(`${d.username} 来了，当前共有 ${d.numUsers} 人`) ) }) socket.on('user left', d => { this.pushMessage( createSystemMessage(`${d.username} 离开了，当前共有 ${d.numUsers} 人`) ) }) socket.on('typing', d => {}) socket.on('stop typing', d => {}) socket.emit('add user', this.me.nickName) 不同域名(多域名)下共享登录状态 登录的关键点：https://zhuanlan.zhihu.com/p/459448211 响应头 response headers: Set-Cookie 可以将 cookie 种植到浏览器 请求头 request headers: X-CSRF-Token 可以将 cookie 带给后台 方案一：在cookie里面的 domain 属性设置需要跨域的域名，这样就可以在多个站点实现共享cookie，也就是可以通过这种方式共享登录状态。这种方式比较简单快捷，但是有一个缺陷就是，共享cookie的站点需要是同一个顶级域名 方案二：在一个域名下登录后，跳转到另一个需要共享登录状态的域名时，可以将token一起携带过去，这样，目标站点获取到携带的token后存储下来，这样就算是实现共享登录状态了。但是这样也有一个缺陷，那就是假如在xx1站点下登录了，有token，如果不通过xx1站点的链接跳转到xx2站点，而是直接访问xx2站点，这样就无法把token携带过去了。 单点登录：https://developer.aliyun.com/article/636281 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/mqtt/":{"url":"pages/interview/mqtt/","title":"mqtt","keywords":"","body":"MQTT MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传递协议，旨在在低带宽、不稳定网络环境下实现高效的设备间通信。MQTT 最初是为物联网（IoT）设备设计的。 mqtt 发布订阅模式 一个设备（发布者）可以将消息发布到一个特定的主题，而其他设备（订阅者）可以订阅相同的主题来接收消息。这使得设备之间可以实现异步通信，并支持多对多的通信。 mqtt 代码举例 import * as mqtt from 'mqtt' const { VITE_MQTT_BROKER_URL, VITE_MQTT_USERNAME, VITE_MQTT_PASSWORD } = import.meta.env const mqttDeviceClient = mqtt.connect(VITE_MQTT_BROKER_URL, { username: VITE_MQTT_USERNAME, password: VITE_MQTT_PASSWORD, keepalive: 30, connectTimeout: 60 * 1000 }) const deviceTopic = `/real-time-medical-device-status-history-production/${hospitalId}` mqttDeviceClient.on('connect', () => { mqttDeviceClient!.subscribe(deviceTopic) }) mqttDeviceClient.on('message', (topic, message) => { if (device.value === null) return const action = JSON.parse(message.toString()) switch (action.dataType) { // 机器人底盘 case 'ROBOT': if (action.floorName === floorName) { const robot = group.getObjectByName(action.name) const center = originData[`${process.env.place}`][action.floorName] const [x, z] = calWankeDedivation(action.coordinates, center) } break // 柜子 case 'HIVE': if (action.floorName === floorName) { const hive = group.getObjectByName(action.name) const center = originData[`${process.env.place}`][action.floorName] const [x, z] = calWankeDedivation(action.coordinates, center) } break // 充电桩 case 'DOCK': device.value.dockList.forEach((item: any, index: number) => { if (item.id === action.id && device.value) { device.value.dockList[index] = action } }) break default: break } }) // 本地调试 MQTT 成本控制 setTimeout(() => { mqttDeviceClient?.end() }, 1200000) mqtt 与 WebSocket 的区别 应用场景： MQTT：主要用于物联网（IoT）领域，特别是在低带宽、不稳定网络环境下的设备间通信。MQTT 专注于高效的消息传递和订阅发布模式，适用于需要实时推送和异步通信的场景。 WebSocket：用于在 Web 应用程序中实现双向通信，允许服务器和客户端之间建立持久性的连接，实时地传递数据。适用于需要实时更新、实时聊天和多人协作等场景。 通信模式： MQTT：支持发布-订阅模式，其中一个设备可以将消息发布到一个特定的主题，其他设备可以订阅相同主题来接收消息。这种模式适合广播消息和多对多通信。 WebSocket：提供全双工双向通信，客户端和服务器可以同时发送和接收数据，适合双向的实时通信。 连接性： MQTT：通常在连接时会经过一些握手和协商，然后保持长时间的持久连接，以便实现设备之间的实时通信。 WebSocket：使用单个 TCP 连接来实现持久的双向通信，适用于客户端和服务器之间需要频繁通信的情况。 数据格式： MQTT：可以传输任何格式的数据，通常使用二进制数据，但也可以使用 JSON 等格式。 WebSocket：传输的数据可以是文本（如 JSON、XML）或二进制数据。 协议特点： MQTT：具有轻量级、消息传递确认、保留消息、QoS 等级等特点，非常适合资源有限的设备和网络。 WebSocket：是基于 HTTP 协议的，具有更大的灵活性和实时性，适合用于 Web 应用程序中的实时通信。 总结： MQTT 适用于物联网领域，特别是需要低带宽、高效传输和订阅发布模式的场景。WebSocket 适用于 Web 应用程序中的实时通信，支持双向通信和持久连接。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/Internet/":{"url":"pages/interview/Internet/","title":"url输入到展示","keywords":"","body":"从输入 url 到页面展示都发生了什么？ 域名解析 发起请求 HTML解析 CSS解析 布局 绘制 域名解析 在计算机⽹络中，我们只能通过 IP 地址访问到具体的主机。我们不能通过域名直接访问。我们的前端的静态资源等，都是存储在服务器上。 当输⼊⼀个域名的时候，我们⾸先要做的就是将域名转化成IP地址。在转换的过程中，有以下⼏个步骤： ⾸先浏览器会查询⾃身的缓存中，有没有此条域名的解析，如果有的话，就返回这个解析后的地址。 如果浏览器⾃身的缓存中，没有找到与此条域名对应的 IP 地址，那么就会去操作系统中的缓存中查找是否有这条域名的解析。 如果在操作系统中也没有找到的话，那么就需要通过 DNS(域名系统)帮助我们解析。 如果浏览器在⾃身缓存中，以及操作系统的缓存中，并未命中该域名的匹配的话，那么就会查找 TCP/IP 参数中设置的⾸选DNS服务器，我们把他叫做本地 DNS，如果本地 DNS 服务器的缓存中命中了该域名，就返回该域名的解析。如果解析不到，那么会根据本地 DNS 服务器的设置，看是否设置了转发模式，如果设置了转发模式，那么他就会⼀级⼀级的去查找，直到找到。如果还没有找到的话，并且这个时候，DNS 服务器已经没有启⽤转发模式，那么就会向根 DNS 服务器发起查询请求。 当向 DNS 根服务器发起请求的时候，根服务器会返回当前他所已知的顶层域名服务器，然后，接着向这些顶层域名服务器去发起请求，如果某个顶层域名服务器解析，是属于他所管辖的范畴，那么就会返回他所管辖的⼆级 DNS 域名服务器，以此类推，直到找到或者找不到。 DNS 的全称是 domain name system，也就是域名系统。他⼯作在应⽤层，主要作⽤是帮我们完成域名到 IP 的转化。他的体系结构是 分布式集群 ，顶层为 根服务器 ，接下来是 顶层域名服务器 ，接下来是 次级域名服务器 。 发起请求 当域名解析完毕之后，就会发起请求。我们在这⾥假定这个域名从来没有被访问过。那么它会经过以下⼏个阶段：如果是第⼀次请求，那么在请求后，收到的响应中，会有⼀些关于强弱缓存的字段，⽐如： 强缓存 expires cache-control 弱缓存 Last-Modified & If-Modified-Since Etag & If-None-Match HTML解析 在请求到资源之后，浏览器需要解析 HTML，⽣成 dom 树，cssRule 树。结合之后形成 render 树，之后再渲染。 浏览器在解析 HTML 的时候，主要所做的事情是两个：词法分析和语法分析。 词法分析 所谓的词法分析就是将⼀⼤段字符串转根据规则解析成⼀个个最⼩有意义的单元，之后再根据这个最⼩意义单元的相应数据⽣成⼀个token。 词法分析阶段采⽤的算法是：标记化算法（将 html 从左到右依次的读⼊字符，内部使⽤状态机来断⾔当前的状态，根据语法规则匹配出可以分解的 htmlToken，最后将这个 htmlToken 提供给语法分析阶段） 语法分析 语法分析的作⽤是根据词法分析阶段⽣成的htmlToken，将其转化成⼀颗树状结构，也就是我们所说的dom树。在将这些分好的词转化成dom树的时候，我们需要⽤到⼀种数据结构：栈。 在开始之前，先向栈顶压⼊根元素，等到解析完成之后，这个根元素就是最后的dom树。当解析完⽣成⼀个词的时候，就会将他⼊栈，有以下⼏种操作的可能： 如果是⼀个开始节点的话，那么直接⼊栈。不做任何操作 如果前⼀个是⽂本节点，并且本次⼊栈的也是⽂本节点的话，会将最后⼊栈的⽂本节点与前⼀个⽂本节点进⾏合并。先把它添加到当前栈顶元素的⼦节点数组中，然后⼊栈。 如果是注释节点，那么直接添加到当前栈顶元素的⾃⼰诶单数组中。 如果是属性的话，直接添加到当前栈顶元素的属性中。 遇到⼀个结束节点，就向前找到第⼀个与之匹配的开始节点，并且出栈。 此处如果 header 中同步存在 js 脚本解析，会阻止 GUI 渲染线程。 CSS解析 在⽣成 dom 树的时候，也会解析 css，这两个是并⾏执⾏的，⼀旦存在 css 样式（包括但不限于⾏内样式，外部样式引⼊等），就会根据语法规范进⾏解析和标记。解析完成后，会⽣成⼀个 stylesheet 对象，这个对象⾥⾯包含着解析好的 css 规则，css 规则是由选择器和声明对象组成。 布局 render树的⽣成 等到css的rule树与dom树都解析完毕之后，那么就会根据这两个树⽣成最终的render树。 render树的⽣成，就是遍历当前⽣成的dom树，根据当前的dom树的⼦节点信息以及对应的css规则，最终⽣成⼀个或多个render⼦节点。 遍历render树，根据render节点的类型，确定元素的⼤⼩以及位置。 绘制 在绘制阶段，系统会遍历render树，并调render树的⼦节点的“paint”⽅法，将render树的⼦节点的内容显示在屏幕上。绘制⼯作是使⽤⽤户界⾯基础组件完成的。 CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进⼊堆栈样式上下⽂的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下： 背景颜⾊ 背景图⽚ 边框 ⼦代 轮廓 浏览器的进程与线程 在浏览器中，进程主要有以下几个： GPU 进程。浏览器全局只有这么一个进程。主要是与图形渲染有关。 其他插件的进程，比如你给你浏览器装了一个插件，那么这一个插件就是一个进程。 Browser 进程：浏览器的主进程（负责协调、主控），只有一个。主要功能有以下: 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 浏览器渲染进程，也被称为浏览器内核。分类有： Google Chrom: Chrome 28开发版本的版本说明中还在使用WebKit，而从Chrome 28.0.1469.0后已经替换为Blink。 **Internet Explorer： Trident内核，也是俗称的IE内核 Mozilla Firefox： Gecko内核，俗称Firefox内核。 Safari： WebKit Opera： 最初是自己的Presto内核，后来是Webkit，现在是Blink内核 浏览器渲染进程 在以上进程中，我们最需要关心的进程是: 浏览器渲染进程，他的主要作用有：负责页面的渲染，脚本执行，时间处理，网络请求等功能。 在一个进程中，至少有一个线程。线程被称为CPU任务调度的最小执行单位。那么在浏览器的渲染进程中，有以下几个线程： GUI渲染线程： 解析html文档，生成DOM树与CSS树（需要注意的是css树不会阻塞dom树的生成）。当生成DOM树与CSS树之后，就根据这两 个数生成一个render树（在生成render树的时候，如果有一方没有解析完毕就会等待解析完成。此时此刻是双方会互相阻塞），然后将这个render树渲染到界面上。 JS线程：用来执行JS代码。具体执行过程详见JS运行过程详解: https://juejin.cn/post/6950114500289036301 定时器线程：用来处理定时器线程，当定时器到期的时候，将回调放到任务队列里面，等待JS线程的执行。那么有了JS线程，我们为啥还需要定时器线程呢？看下面代码解释： function test() { setTimeout(() => { console.log('我是计时器1'); }, 1000); setTimeout(() => { console.log('我是计时器2'); }, 2000); }; test(); 假如没有定时器线程，又因为JS是单线程的，我只能一个一个的压入栈中执行，那么首先是计时器1入栈，接着是计时器2入栈。但是因为计时器1的时间小于计时器2的时间，那么应该计时器1首先出栈。但是因为栈是一个先进后出的数据结构。那么这就与栈的定义发生了冲突。因为计时器2还没有到时间，没有出栈，所以计时器1也就不能出栈。 事件触发线程。用来管理事件的触发，例如：点击事件，鼠标移动事件。当这些个事件被触发的时候，就会将这些事件的回调添加到任务队列里，等待JS执行。 异步HTTP请求线程。在XMLHttpRequest在连接后新启动的一个线程，线程如果检测到请求的状态变更，如果设置有回调函数，该线程会把回调函数添加到事件队列，同理，等待JS引擎空闲了执行。 JS线程与GUI线程互斥的原因 主要是因为当一个文档在加载的时候，如果此时JS线程也在加载执行，例如要获取一个id为demo1的节点，此时此刻我们渲染过程中，还并没有生成render树，也就不会进行布局和渲染。那么此时这个节点是没有的，那么肯定就会找不到。因此为了避免这种情况的发生，在浏览器中，JS线层和GUI线程是互斥的，当一个执行的时候，另外一个就会被强制挂起。这样就会导致一个问题，当JS执行一个时间复杂度非常高的算法的时候，因为迟迟不能执行完毕，导致GUI渲染线程被挂起太久，就会导致页面看起来卡顿，事件响应变慢。解决办法，可以通过Web Worker解决。 http://www.ruanyifeng.com/blog/2018/07/web-worker.html Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/typescript/":{"url":"pages/interview/typescript/","title":"TypeScript","keywords":"","body":"TypeScript 1. 你觉得使用ts的好处是什么? TypeScript是JavaScript的加强版，它给JavaScript添加了可选的静态类型和基于类的面向对象编程，它拓展了JavaScript的语法。所以ts的功能比js只多不少. Typescript 是纯面向对象的编程语言，包含类和接口的概念. TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。 作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。 ts中有很多很方便的特性, 比如可选链. 2. type 和 interface的异同 重点：用interface描述数据结构，用type描述类型 3. tsconfig.json如何配置？ { \"exclude\": [\"node_modules\"], \"include\": [\"src/**/*.ts\"], \"compilerOptions\": { \"target\": \"ES6\", // 目标 JavaScript 版本 \"module\": \"CommonJS\", // 模块系统 \"outDir\": \"./dist\", // 编译输出目录 \"rootDir\": \"./src\", // TypeScript 源代码目录 \"strict\": true, // 启用严格类型检查 \"esModuleInterop\": true // 启用 ECMAScript 模块系统互操作性 } } 4. 什么是泛型？ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-13 19:58:49 "},"pages/interview/BFC/":{"url":"pages/interview/BFC/","title":"BFC","keywords":"","body":"BFC BFC 的理解 块级格式化上下文，它是指一个独立的会计渲染区域，只有块级盒子参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 从一个现象说起 一个没有高度的盒子，子元素浮动，该盒子会出现高度塌陷，无法撑起自身。--这个盒子没有形成 BFC。 如何创建 BFC 方法一：float 的值不是 none 方法二：position 的值不是 static 或者 relative 方法三：display 的值是 inline-block、flex 或者 inline-flex 方法四：overflow: hidden BFC 的作用 可以取消盒子 margin 塌陷 可以阻止元素被浮动元素覆盖 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/import/":{"url":"pages/interview/import/","title":"按需引入","keywords":"","body":"按需引入和全量引入 export与export default的区别 1.在一个js文件中，export可以多次使用，export default只能使用一次 2.export最后导出的是一个对象，其导出的内容会被放入此对象中，在导入时用解构赋值来取值比较方便；export default导出时是什么，导入时就是什么。 3.export default后面不可以用 var、let、const， 可用 export default function(){} function add(){} export // @lx-frontend/wrap-element-ui export { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } // 导入 import { SearchSelect } from '@lx-frontend/wrap-element-ui' export default // @lx-frontend/wrap-element-ui export default { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } // 导入 import wrapElement from '@lx-frontend/wrap-element-ui' export + export default // @lx-frontend/wrap-element-ui export { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } export default { install, DemoComponent, AuditSteps, Ellipsis, SearchForm, LxTable, SearchSelect, AddMembers, PopoverForm } // 导入 import wrapElement, { SearchSelect } from '@lx-frontend/wrap-element-ui' Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/interview/projects/":{"url":"pages/interview/projects/","title":"总结","keywords":"","body":"summary ucma: wepy -> taro wepy 的缺点 框架并存 页面跳转代理 灰度策略 wepy 打包 taro 打包 打补丁 wrap-element-ui 存在的问题：1.element-ui 组件的升级问题；2. 物料组件的重复开发问题 low-code threejs-demo Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/":{"url":"pages/others/","title":"Others","keywords":"","body":"主要知识 浏览器缓存机制 http/https url解析过程 跨域问题 MVC/MVVM的理解 首屏渲染时间计算（performance） linux命令 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/gitlab/":{"url":"pages/others/gitlab/","title":"GitLab CI/CD","keywords":"","body":"GitLab CI/CD 一、CentOS 环境下安装 gitlab-runner JDK 安装: https://www.oracle.com/java/technologies/downloads/#jdk19-mac m1: Arm 64 DMG INSTALLER intel: X64 DMG INSTALLER (base) ➜ ~ java --version java 19.0.2 2023-01-17 Java(TM) SE Runtime Environment (build 19.0.2+7-44) Java HotSpot(TM) 64-Bit Server VM (build 19.0.2+7-44, mixed mode, sharing) 安装 Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装 gitlab-runner https://www.freesion.com/article/79431185053/ sudo brew install gitlab-runner 注册 gitlab-runner URL + TOKEN: gitlab -> settings - CI/CD - Runners sudo gitlab-runner register # 将 gitlab-runner 加入 docker 用户组 (base) ➜ ~ usermod -aG docker gitlab-runner 启动 gitlab-runner sudo gitlab-runner install --user=gitlab-runner sudo gitlab-runner start 二、GitLab CI/CD 流水线语法 https://www.shuzhiduo.com/A/A2dm8kmA5e/ https://zhuanlan.zhihu.com/p/510820543 &、＜＜、 : 重复的节点（对象）首先由锚（&）定义别名，然后用星号（）引用别名, variables 环境变量: 变量可以分为全局变量和局部变量；全局变量是整个流水线可以用的，局部变量是仅在作业中生效的 局部变量优先级高于全局变量 variables: DEPLOY_ENV: \"dev\" deploy_job: stage: deploy tags: - maven variables: DEPLOY_ENV: \"test\" script: - echo ${DEPLOY_ENV} 常用的内置变量： $CI_COMMIT_BRANCH：当前提交所在的分支名称。 $CI_COMMIT_SHA：当前提交的 SHA 值。 $CI_COMMIT_MESSAGE：当前提交的提交消息。 $CI_PIPELINE_ID：当前流程的 ID。 $CI_PROJECT_DIR：GitLab CI/CD 系统中当前项目的根目录。 job: 作业，每个作业独立执行，必须有唯一的名称（不能使用关键字）且只包含一个 script，script 可以是 shell 命令。 stages: - dep - build - deploy dep: stage: dep script: - yarn install --quite --registry=http://192.168.14.248:8181/repository/npm-groups/ build: stage: build script: - yarn --registry=http://192.168.14.248:8181/repository/npm-groups/ - ls -al - rm -rf dist/pre - yarn run build:pre deploy: stage: deploy before_script: - mc alias set minio $MINIO_HOST $MINIO_ACCESS_KEY $MINIO_SECRET_KEY - mc rm --recursive --force minio/$MINIO_BUCKET_DEV_NAME script: - mc cp -r dist/pre/ minio/$MINIO_BUCKET_DEV_NAME 作业运行的顺序控制：整体由 stages 控制，单个可以借助 dependencies 和 needs dependencies: deploy 依赖于 build 打包到 dist 目录下的文件 needs: 是一个数组，比如：pre:deploy 的 needs: ['pre:build']; prod:deploy 的 needs: ['prod:build']; .pre & .post: .pre 始终是整个 pipeline 的第一个运行阶段，.post 始终是整个 pipeline 的最后一个运行阶段，无法修改，用户自定义的 stage 则在这两者之间，如果一个 pipeline 仅包含 .pre 和 .post，则不会创建 pipeline tags: 用于指定特定的 job 在特定的 runner 运行，如果 job 不指定 tags，则默认在共享的 runner 运行 allow_failure: allow_failure 表示是否允许作业失败，默认值 false 不允许失败，改为 true 后，如果该作业失败也不会被阻塞 when: 用于控制作业运行, 比如指定手动运行 on_success：前面阶段的所有作业成功才执行该作业，默认 on_success on_failure：前面阶段出现失败时执行 always：总是执行作业 manual：手动执行作业 delayed：延迟执行作业 retry：配置作业失败后重试作业的次数，比如由于网络差的原因导致安装依赖失败，从而主动退出作业流程，可以适当设置重试次数解决这个问题 rules：允许按顺序评估单个规则，直到匹配为止 when：指定作业运行方式 variables: DOMAIN: example.com test: stage: test script: - \"...\" rules: # DOMAIN值匹配,则手动运行,否则 - if: '$DOMAIN == \"example.com\"' when: manual - if: '$DOMAIN == \"example2.com\"' when: delayed start_in: '5' - when: on_success changes: 指定文件发生变化 test: stage: test script: - \"...\" rules: - changes: - fimeName # 文件名 when: manual - when: on_success exists：指定文件存在 job1: stage: test script: - \"...\" rules: - exists: - fimeName # 文件名 when: manual - when: on_success workflow-rules：适用于整个管道，并确定是否创建管道 stages: - dep - build - deploy variables: MINIO_BUCKET_DEV_NAME: cti-scheduling-admin-dev MINIO_BUCKET_PROD_NAME: cti-scheduling-admin-prod MINIO_HOST: http://company-pvt.minio.ctirobot.com:9100 workflow: rules: - if: '$CI_COMMIT_BRANCH == \"master\"' when: always # 默认always,可以设置never - when: never cache: 存储编译项目时所需的运行时依赖项，指定项目工作空间中需要在 job 之间缓存的文件或目录; 全局 cache 定义在 job 之外，针对所有 job 生效，job 中的 cache 优于全局 key：用于指定缓存项的键值 paths: 缓存目录地址 policy: 缓存策略 pull: 每次流程运行时都会尝试从先前的流程缓存中拉取缓存。如果找不到任何缓存，则将创建一个新的缓存。 push: 在流程完成后，会将所有缓存项推送到 GitLab CI/CD 系统中，并将其存储在该项目的缓存池中。在下次流程运行时，将从该缓存池中提取缓存。 pull-push 表示只有当本地没有相应的镜像或者镜像过期时，才会从远程仓库拉取镜像，并且如果存在本地镜像，会先删除本地镜像然后再从远程仓库拉取最新的镜像，并将拉取到的镜像推送到 GitLab 内置容器镜像仓库，以供后续使用。 pull+push 表示不管本地是否存在相应的镜像，每次都会从远程仓库拉取最新的镜像，并将拉取到的镜像推送到 GitLab 内置容器镜像仓库，以供后续使用 expires_in: 缓存项的过期时间。例如 1 day、2 weeks 或 3 months cache: paths: # 在全局定义缓存 - my/files job: script: \"npm install\" cache: key: job # 为缓存设置唯一key,会为该job分配一个独立的cache paths: # 在job中定义缓存,缓存target目录下的所有.jar文件,该缓存将覆盖全局缓存 - node_modules/ policy: pull # pull:不下载缓存,push不上传缓存,默认会在job执行之前下载缓存,并在结束之后上传缓存 expires_in: 10 months artifacts：用于指定作业成功或失败时应附加到作业的文件或目录的列表，可以轻松地将文件和数据传递到下一个 Job 或 Pipeline 阶段，从而实现更高级别的自动化和持续集成/交付流程。 paths: 作业的文件或目录列表 expire_in: 作业的文件或目录过期时间 name: 指定持久化文件的名称。如果未指定，则使用默认名称 artifacts. untracked: 是否包含未被 Git 跟踪的文件。默认情况下，artifacts 只包含已被 Git 跟踪的文件。 when: 指定何时保存持久化文件。默认情况下，只有在 Job 成功执行时才会保存。 reports: 定义需要在 Job 结束后保存为报告的路径或文件。类似于 paths，但这些文件被标记为报告，并且可以通过 GitLab UI 查看。 expose_as: 将指定路径或文件公开为构建的 artifact，使其可供外部使用。 dependencies: 定义需要在此 Job 执行前完成的 Jobs，以便在此 Job 中使用其 artifacts。 artifacts: ## 产物 paths: ## 产物的路径 - dist expire_in: 10 mins ## 过期时间 extends: 继承作业配置，相同配置覆盖，不同则继承 .tests: script: mvn test stage: test only: refs: - tags test-job: extends: .tests script: mvn clean test only: variables: - $RSPEC image: 首先注册一个工作类型为 docker 的 runner，只要使用该类型的 runner，所有运行操作都会在容器中运行 image: cr.lixinio.com/frontend/node:12.16.2 parallel：表示作业的并行度，可以是一个整数或一个字符串表达式。例如，parallel: 2 表示在一个 runner 中最多有两个并行的作业在运行，而 parallel: \"10/5/3\" 表示在三个 runner 中，第一个可以运行10个并行的作业，第二个可以运行5个并行的作业，第三个可以运行3个并行的作业。 stages: - build - test - deploy build: stage: build script: - npm run build tags: - docker test_job_1: dependencies: - build stage: test script: - echo \"Running test job 1\" tags: - docker test_job_2: dependencies: - build stage: test script: - echo \"Running test job 2\" tags: - docker test_job_3: dependencies: - build stage: test script: - echo \"Running test job 3\" tags: - docker .parallel: 3 deploy: stage: deploy script: - cho \"deploy...\" needs: - ['test_job_1', 'test_job_2', 'test_job_3'] 三、当前项目中存在的问题： 问题-1：部分项目依赖安装的作业流程每次都会运行，浪费大量时间 原因分析：未设置依赖安装的作业流程的运行条件 解决方案：只有当 yarn.lock 被修改时，才执行 yarn install dep: stage: dep image: company-pvt.harbor.ctirobot.com/yarnpkg/node-yarn:node7 cache: policy: pull-push 问题-2：部分项目打包失败也能将错误的代码部署到线上 原因分析：allow_failure: true 解决方案：allow_failure: true -> allow_failure: false 问题-3：不同环境的作业流程无法同时运行，浪费了等待的时间和并发作业运行时间 原因分析：预发布环境和正式环境都打包到 dist 目录，导致无法同时部署 解决方案：对不同环境的打包目录进行隔离，并针对不同环境的作业流程使用不同的 runner 对不同环境的打包目录进行隔离: vite 打包 import { defineConfig } from 'vite'; import react from '@vitejs/plugin-react'; export default ({ mode }) => defineConfig({ base: mode === 'production' ? '/prod' : '/stag', build: { outDir: mode === 'production' ? 'dist/prod' : 'dist/stag' }, plugins: [react()], ... }); umi 打包 import { defineConfig } from 'umi'; // pre 环境 export default defineConfig({ outputPath: 'dist/pre', .... }); // prod 环境 export default defineConfig({ outputPath: 'dist/prod', .... }); ci 改造: 1. 打包目录修改；2. 使用不同的 runner 加速作业运行 stag:build: 问题-4: master 未受保护，任何分支都能直接部署代码到正式环境，弱化了 gitlab 用户角色权限，同时给项目带来了极大的风险 原因分析：未对正式环境的作业流行设置分支条件 解决方案：对正式环境的作业流行设置分支条件，同时加强对 gitlab 用户角色权限的管理，做到一个项目只能一个人有发布正式环境的权限，其他人只能提 MR。 prod:build: Env: Development\\n >Application: candela-ota-system \\\"} }\"' needs: - ['prod:build'] rules: - if: '$CI_COMMIT_BRANCH == \"master\"' ## 只有 master 分支才能运行此作业 其他潜在优化： GitLab Runner: shell executor VS image executor parallel 并发运行提升效率 stages: - build - test - deploy build: stage: build script: - npm run build tags: - docker test_job_1: dependencies: - build stage: test script: - echo \"Running test job 1\" tags: - docker test_job_2: dependencies: - build stage: test script: - echo \"Running test job 2\" tags: - docker test_job_3: dependencies: - build stage: test script: - echo \"Running test job 3\" tags: - docker .parallel: 3 deploy: stage: deploy script: - cho \"deploy...\" needs: - ['test_job_1', 'test_job_2', 'test_job_3'] 四、gitlab-runner image executor step-1: 从服务器上下载 docker 镜像 docker pull gitlab/gitlab-runner step-2: 运行 docker 版 gitlab-runner docker run -d --name gitlab-runner gitlab/gitlab-runner:latest step-3: gitlab runnser 注册 docker exec gitlab-runner gitlab-runner register -n \\ --url http://company-pvt.gitlab.ctirobot.com/ \\ --registration-token xxxxxxxxxxxxxxxxxxxxxxxx \\ --tag-list runInDocker \\ --executor docker \\ --docker-image docker \\ --description \"runInDocker\" 五、实际项目例子 .commons: commons_cache: &commons_cache # 声明cache key: files: # 用此文件作为cache的key,只要此文件不变,node_modules不会变 - yarn.lock paths: # 声明cache的目录 - node_modules/ - .yarn # 声明cache策略 policy: pull-push commons_build: &commons_build allow_failure: true ## 使用node:lts docker 镜像运行 image: node:lts cache: Env: Development\\n >Application: tong-frontend-demo \\\"} }\"' needs: - dev:build 特别注意：使用本地 runner，并且设置了 npm 私服，其他项目安装依赖需要重置 registry，此处建议设置淘宝源。 终端里输入 npm config list 来获取npm的配置 npm config list 找到userconfig一项，打开 .npmrc 文件 code /Users/dsc/.npmrc 删除私服设置 # registry=http://192.168.14.248:8181/repository/npm-groups/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/linux/":{"url":"pages/others/linux/","title":"云服务器","keywords":"","body":"云服务器相关操作（CentOS） ssh 云服务器安装mysql 云服务器安装nodejs + pm2 nginx 配置 ssh // 远程登录云服务器 ssh root@106.54.87.199 // 批量远程上传文件夹 scp -r ~/demo root@106.54.87.199:/data/www // 批量远程上传文件夹下面的所有文件和文件夹 scp -r ./_book/* root@106.54.87.199:/data/www/gitbook/summary // 批量远程下载文件夹 scp -r root@106.54.87.199:/data/www/gitbook/share/_book ./Desktop/test // 批量远程下载文件夹 scp -r root@106.54.87.199:/data/www/gitbook/share/_book/* ./Desktop/test // 远程云服务器重装系统，删除known_hosts记录 vim ~/.ssh/known_hosts 云服务器安装mysql 1. 从MySQL社区Yum Repository下载所需MySQL版本的RPM wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 2. 安装RPM软件包 rpm -ivh mysql57-community-release-el7-9.noarch.rpm 3. 开始安装MySQL yum install mysql-server 4. 启动MySQL，并验证是否已启动 # systemctl start mysqld # systemctl status mysqld 5. 获取默认的root密码 grep 'temporary password' /var/log/mysqld.log 6. 获取默认密码后，运行MySQL安全脚本 mysql_secure_installation 7. 测试MySQL服务 mysqladmin -u root -p version 8. 修改密码 // 1. 先登录 mysql -u root -p // 2. 降低密码强度 set global validate_password_policy=LOW; set global validate_password_length=6; // 3. 设置新密码 set password for root@localhost = password('tomgou'); 9. 本地Mysql Workbench远程连接云服务器中的MySQL // 让用户从任何主机连接到mysql服务器 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'tomgou' WITH GRANT OPTION; FLUSH PRIVILEGES; // 允许用户从ip为118.184.1.3的主机连接到mysql服务器 GRANT ALL PRIVILEGES ON *.* TO 'root'@'118.184.1.3' IDENTIFIED BY 'tomgou' WITH GRANT OPTION; FLUSH PRIVILEGES; 云服务器安装nodejs + pm2 1. 新建安装目录 cd / && mkdir app && cd app 2. 下载node压缩包 wget https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3-linux-x64.tar.xz 3. 解压并重命名 tar -xvf node-v8.9.3-linux-x64.tar.xz mv node-v8.9.3-linux-x64 nodejs 4. 建立node全局链接 ln -s /app/nodejs/bin/npm /usr/local/bin/ ln -s /app/nodejs/bin/node /usr/local/bin/ 5. 检查node是否生效 node -v 6. 安装pm2 npm install -g pm2 7. 建立pm2全局链接 ln -s /app/nodejs/bin/pm2 /usr/local/bin/pm2 8. pm2 守护node进程 cd /data/www/think/demo pm2 list pm2 start production.js pm2 stop production.js pm2 delete production.js pm2 reload all pm2 delete 0 云服务器安装nginx 1. gcc 安装 rpm -qa|grep gcc 2. PCRE pcre-devel 安装 yum install gcc-c++ 3. zlib 安装 yum install -y pcre pcre-devel 4. OpenSSL 安装 yum install -y openssl openssl-devel 5. wget 命令下载安装包 wget -c https://nginx.org/download/nginx-1.10.1.tar.gz 6. 解压安装包 tar -zxvf nginx-1.10.1.tar.gz mv nginx-1.10.1 nginx cd nginx ./configure 7. 编译安装 make make install // 查找安装路径 whereis nginx 8. 修改nginx路由 location / { root /data/www/gitbook/_book; index index.html index.htm; } 9. 启动、停止nginx cd /usr/local/nginx/sbin/ ./nginx ./nginx -s stop ./nginx -s quit ./nginx -s reload 常用命令 1. curl(client + URL) // -v参数输出通信的整个过程，用于调试。 curl -v http://127.0.0.1:80 // --trace参数也可以用于调试，还会输出原始的二进制数据。 curl --trace - http://127.0.0.1:80 2. chmod 修改权限 // 修改权限 chmod -R 777 /usr // 查看权限 ls -l index.js // 删除文件 rm -rf * 2. which 查看安装目录 which vue Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/mysql/":{"url":"pages/others/mysql/","title":"mysql","keywords":"","body":"mysql 基本操作 重置密码 基本操作 操作 语句 登录 mysql -u root -p 退出 exit or quit 查询数据库 show databases; 创建数据库 create database test character set utf8 collate utf8_general_ci; 删除数据库 drop database test; 连接数据库 use test; 创建数据表 CREATE TABLE IF NOT EXISTS USER(); 查看数据表 show tables; 删除数据表 truncate table user; 查看表字段 desc user; 修改表名称 RENAME TABLE USER TO USERS; 修改表字段 ALTER TABLE USER MODIFY COLUMN name VARCHAR(20); 插入记录 INSERT INTO USER (name, score) VALUES ('Tommy', 80); 查看记录 SELECT * FROM USER WHERE name = 'Tommy'; 修改记录 UPDATE USER SET score = 100 WHERE name = 'Tommy'; 删除记录 DELETE FROM USER WHERE name = 'Tommy'; 条件查询 SELECT name, score FROM USER WHERE score > 60 ORDER BY score DESC; 按组查询 SELECT name, AVG(score) FROM USER GROUP BY name; 连表查询 SELECT a.name, a.score, b.position FROM USER a LEFT JOIN POSITION b ON a.name=b.name; 1. 创建数据库：create database test character set utf8 collate utf8_general_ci; create database test：代表的是创建数据库 test。 character set utf8：代表的是将该库的默认编码格式设置为utf8格式。 collate utf8_general_ci：代表的是数据库校对规则。 utf8_bin将字符串中的每一个字符用二进制数据存储，区分大小写。 utf8_general_ci不区分大小写，ci为case insensitive的缩写，即大小写不敏感。 utf8_general_cs区分大小写，cs为case sensitive的缩写，即大小写敏感。 2. 创建表格：CREATE TABLE IF NOT EXISTS USER(id INT UNSIGNED AUTO_INCREMENT, name VARCHAR(100) NOT NULL, score INT UNSIGNED NOT NULL, PRIMARY KEY (id)); id INT UNSIGNED AUTO_INCREMENT：字段 id 整型自增。 name VARCHAR(100) NOT NULL：字段 name 100长字符型。 score INT UNSIGNED NOT NULL：字段 score 整型不为空。 PRIMARY KEY (id)：以 id 为 primary key。 3. 条件查询：SELECT name, score FROM USER WHERE name = 'Tommy' AND score > 60 ORDER BY score DESC; SELECT name, score FROM USER：查询字段 name, score。 WHERE name = 'Tommy' AND score > 60：2个条件，名字为 Tommy，分数大于 60。 ORDER BY score DESC：排序, DESC 为降序，ASC 为升序。 4. 连表查询：SELECT a.name, a.score, b.position FROM USER a LEFT JOIN POSITION b ON a.name=b.name; SELECT a.name, a.score, b.position：查询字段，a 和 b为别名。 FROM USER a：user 表对应别名 a。 LEFT JOIN POSITION b：position 表对应别名 b，LEFT JOIN 表示左关联，以 a 为主表，b 为副标。 ON a.name=b.name：关联条件为 name 相同。 5. 字段类型 1．INT[(M)] 型： 正常大小整数类型。 2．DOUBLE[(M,D)] [ZEROFILL] 型： 正常大小(双精密)浮点数字类型。 3．DATE 日期类型：支持的范围是1000-01-01到9999-12-31。MySQL以YYYY-MM-DD格式来显示DATE值，但是允许你使用字符串或数字把值赋给DATE列。 4．CHAR(M) 型：定长字符串类型，当存储时，总是是用空格填满右边到指定的长度。 5．BLOB TEXT类型，最大长度为65535(2^16-1)个字符。 6．VARCHAR型：变长字符串类型。 重置密码 1. 偏好设置中找到MySQL，关闭MySQL 2. 跳过权限认证 // 进入数据库指令文件 cd /usr/local/mysql/bin // 跳过权限认证 sudo ./mysqld_safe --skip-grant-tables 3. 免密码进入数据库, 在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下： // 执行mysql指令 /usr/local/mysql/bin/mysql // 进入名为的数据库 use mysql // 刷新权限 flush privileges; // 修改密码 但不适用于8.0+的版本 set password for 'root'@'localhost' = password('新的密码'); // 8.0+版本修改密码 alter user 'root'@'localhost' identified by '新密码'; // 退出mysql exit Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/cloud/":{"url":"pages/others/cloud/","title":"微信小程序云开发","keywords":"","body":"微信小程序云开发 订阅消息推送 数据库操作 订阅消息推送 数据库操作 1. add(增) const db = wx.cloud.database() db.collection('history').add({ data: { name: '中国平安', price: 186.98 }, success: res => { // 在返回结果中会包含新创建的记录的 _id wx.showToast({ title: '新增记录成功', }) console.log('[数据库] [新增记录] 成功，记录 _id: ', res._id) }, fail: err => { wx.showToast({ icon: 'none', title: '新增记录失败' }) console.error('[数据库] [新增记录] 失败：', err) } }) 2. remove(删) const db = wx.cloud.database() db.collection('history').where({name: '五粮液'}).remove({ success: res => { wx.showToast({ title: '删除成功', }) }, fail: err => { wx.showToast({ icon: 'none', title: '删除失败', }) console.error('[数据库] [删除记录] 失败：', err) } }) 3. update(改) const db = wx.cloud.database() db.collection('history').where({name: '中国平安'}).update({ data: { name: '五粮液', price: 86.98 }, success: res => { wx.showToast({ title: '更新成功', }) }, fail: err => { icon: 'none', console.error('[数据库] [更新记录] 失败：', err) } }) 4. query(查) db.collection('history') .where({ price: _.gt(10) // price大于10 }) .field({ name: true, price: true }) // 只展示name和price两个字段 .orderBy('price', 'desc') // 排序 .skip(5) // 跳过前5条数据 .limit(10) // 最多返回10条数据 .get() Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/lerna/":{"url":"pages/others/lerna/","title":"lerna","keywords":"","body":"Lerna 使用说明 使用教程 安装 $ npm install --global lerna 起步 创建项目 $ mkdir lerna-example && cd lerna-example $ npx lerna init 添加第一个包 命令：lerna create [loc] 文档： https://github.com/lerna/lerna/tree/master/commands/create#readme 举例 这里包名为 lerna-pkg-util lerna create lerna-pkg-util 添加依赖 命令：lerna add [globs..] 文档：https://github.com/lerna/lerna/tree/master/commands/add#readme 举例 这里往 lerna-pkg-util 包添加依赖 dayjs lerna add dayjs --scope=lerna-pkg-util 如果是 dev 依赖加上命令 lerna add gulp --scope=lerna-pkg-util --dev 安装依赖 命令：lerna bootstrap 文档：https://github.com/lerna/lerna/tree/master/commands/bootstrap#readme 包发布 命令：lerna publish [bump] 文档：https://github.com/lerna/lerna/tree/master/commands/publish#readme 推荐采用 lerna publish from-package --yes 方式来发布，因为如果直接采用 lerna publish 与 lerna publish from-git 则需要 git commit 没提交，才能 publish 成功。而采用 lerna publish from-package --yes 则只需要 npm 包的版本号没有发不过，则可以继续发布。这样很方便集成在 CI 里。 常见问题 1. 如何把 node_modules 安装到根目录 在项目 lerna.json 增加如下配置 \"command\": { \"bootstrap\": { \"hoist\": true } } 2. 如何解决 CI 环境下发布权限问题？ 在 lerna 项目根目录下，创建 .npmrc，里面代码如下： //registry.npmjs.org/:_authToken=${NPM_TOKEN} 在 npmjs 后台创建 Access Tokens ，然后在 CI 设置 NPM_TOKEN 的环境变量为 Access Tokens 的值即可。 参考资料 官网：https://lerna.js.org/ Github：https://github.com/lerna/lerna Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/charles/":{"url":"pages/others/charles/","title":"charles","keywords":"","body":"charles 的破解和使用 破解 破解网址：https://www.zzzmode.com/mytools/charles/ 使用 tools -> Rewrite 【上面的地址替换为下面的地址】 前端代理 url // https://boss.test.dos.lixinchuxing.cn/((?!(api|auth|store_config)).*) // http://localhost:8000/$1 联调代理 url // http://lxcx.com:5000/(((api|auth|store_config)).*) // http://localhost:8000/$1 接口代理 url // http://style.spacex.lan.cheanjia.net/(((api|static|resource)).*) // http://localhost:8360/$1 Host 代理 // 192.168.102.23 // lxcx.com tools -> Map Local Setting 可以串改接口返回的数据 正则解释 ((?!(api|auth|store_config)).*) 非 $1 正则占位符（） 正则测试地址：https://regex101.com/ or https://jex.im/regulex/ 竞品 whistle http://wproxy.org/whistle/install.html Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/whistle/":{"url":"pages/others/whistle/","title":"whistle","keywords":"","body":"联调后端或者产品测试访问前端本地项目的方式 merchant-frontend为例 前端: 一. 运行项目 npm run dev 获取Network https://192.168.106.196:8000 二. 关闭防火墙 或者 打开指定端口供外部访问 关闭防火墙 Windows系统 windows + q -> 控制面板 系统与安全 Windows防火墙 启用或者关闭Windows防火墙 部份情况需要禁用 Security Center mac系统(保证防火墙选项阻止所有传入链接不勾选，即可) mac 只禁止1024以下的端口访问，超过1024端口若不关闭权限可以访问 打开指定端口外部访问权限 8000 为列 windows系统 windows + q -> 控制面板 系统与安全 windows防火墙 高级设置 入站规则 -> 右侧新建规则 选择端口 下一步 特定本地端口 输入8000端口 保存 mac 系统（10.6版本 ipfw?）mac 系统较高版本禁用了1024端口以下的访问 但是就算打开防火墙，超过1024的端口也可以在外部访问 所以mac 电脑只要运行之后将url告诉对应的访问者就可以了。 保证防火墙选项阻止所有传入链接不勾选 打开 Terminal sudo -i pfctl -d 结束pfctl vim /etc/pf.conf 将\"pass in inet proto tcp from any to any port 8000 no state\" 添加到最后一行 保存退出vim pfctl -f /etc/pf.conf 载入修改 pfctl -e 开始pfctl 访问者: 使用 （whistle + SwitchOmeoga） 或者 fiddle 或者 Charles 使用 whistle(npm 包) + SwitchyOmega(谷歌浏览器插件) 安装node npm install whistle -g 打开Terminal -> w2 start open link http://192.168.x.xxx:8899/ 点击安装证书 设置正则替换 安装谷歌插件 SwitchOmeoga 点击选项进入设置SwitchOmeoga 选择设置的情景模式 当需要访问前端对应项目 命令行工具 w2 start + 步骤6 + 步骤9 使用 fiddle 或者 Charles 安装fiddle 或者 Charles 安装证书 设置配置可代理 将前端交与的正则填入到对应的配置中 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/docker/":{"url":"pages/others/docker/","title":"docker","keywords":"","body":"docker docker常用命令 docker pull docker push docker images docker run -d -p 8080:80 nginx docker exec -it 92 bash docker ps docker rm -f 92 docker commit 92 tomgou docker tag image username/repository:tag docker push username/repository:tag docker run -d -p 8080:80 username/repository:tag docker build -t tomgou . echo hello > index.html cat index.html vim dockerfile // vim编辑dockerfile mkdir page // 创建page文件夹 touch index.js // 创建index.js文件 rm index.js 删除index.js文件 rm -r page // 删除page文件夹 mv ~/Downloads/geckodriver /usr/local/bin/ // 将geckodriver文件从~/Downloads/移到/usr/local/bin/ pbcopy /usr/local/bin/ // 粘贴到/usr/local/bin/ chmod u+x,g+x,o+x geckodriver // u：所有者; g：所属组; o：其他人 a：所有人; // +：为用户增加权限; -：为用户减少权限; =：为用户赋予权限; // r：读权限; w：写权限; x：执行权限; ls -l geckodriver // 查看geckodriver文件的权限信息 Dockerfile FROM: 基础镜像 RUN：让它干啥（命令加上RUN） WORKDIR：当前工作目录 EXPOSE：打开的端口 ADD：加点文件，会自动解压 VOLUME：目录挂载，存文件的地方 COPY： CMD： docker-compose常用命令 docker-compose --help docker-compose up --help docker-compose up -d // 创建并启动容器 docker-compose -f docker-kafka.yml up -d // 指定docker-compose文件名 docker-compose up -d db //单独启动db服务 docker-compose down // 停止并移除容器镜像 docker-compose exec db bash // 进入db容器中 docker-compose restart db // 重启db容器 docker-compose build db // 构建db镜像 docker-compose logs db // 查看db的日志 docker-compose logs -f db // 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息 docker-compose pause db // 暂停db服务 docker-compose unpause db // 恢复db服务 docker-compose stop db // 停止db服务 docker-compose start db // 启动db服务 docker-compose rm db // 删除db容器 docker-compose.yml image: 从指定的镜像中启动容器，如果镜像不存在，Compose 会自动拉去镜像; container_name: 指定自定义容器名称，而不是生成的默认名称; ports: 定义端口映射，比如80:9901将容器上的公开端口 80 转接到主机上的外部端口 9901; volumes: 挂载一个目录或者一个已存在的数据卷容器; env_file: 定义环境变量的文件， 从这个文件中读取变量设置为容器中的环境变量； environment: 定义容器的环境变量， 可以覆盖 env_file 的值； restart: 定义容器自动重启策略(restart_policy) environment: 定义环境变量和配置； depends_on: 定义依赖关系, 也就是容器启动顺序； docker 实战 1.创建 Dockerfile 文件 FROM nginx COPY dist/ /usr/share/nginx/html COPY nginx/nginx.conf /etc/nginx/conf.d/default.conf 2.nginx 配置文件 server { listen 80; server_name localhost; root /usr/share/nginx/html/; index index.html index.htm; location / { try_files $uri $uri/ /index.html; } location = /health { default_type text/plain; access_log off; error_log off; return 200 'ok\\n'; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 监听 80 端口，并设置虚拟主机为 localhost。 将网站根目录设置为 /usr/share/nginx/html，并设置默认文档为 index.html 或 index.htm。 配置了一个 location 规则用于处理除了 /health 之外的所有请求，该规则将尝试匹配请求的文件，如果不存在则重定向到 /index.html。 配置了另一个 location 规则用于处理 /health 请求，并返回一个 200 OK 响应。 配置了一个自定义错误页面 /50x.html 用于处理 500、502、503、504 等错误，如果出现这些错误则会显示该页面。 3.构建镜像 docker build -t nginx-test . 4.启动镜像容器 docker run -p 8080:80 -it nginx-test 5.浏览器访问页面 http://localhost:8080/ 6.编写 docker-compose.yml version: '3' services: web: image: nginx-test volumes: - ./dist:/usr/share/nginx/html - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf ports: - \"8080:80\" 7.docker-compose 启动容器 docker-compose up 8.浏览器访问页面 http://localhost:8080/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/git/":{"url":"pages/others/git/","title":"git","keywords":"","body":"git 操作 git 配置流程 step-1: 设置 git 的 user name 和 email // 配置 git config --global user.name \"tommy.tang\" git config --global user.email \"1071679828@qq.com\" // 查看是否配置成功 code ~/.gitconfig 生成SSH密钥 // 生成 SSH 密钥 ssh-keygen -t rsa // 查看是否生成成功 cd ~/.ssh 复制公钥到 github 设置中 // 查看 id_rsa.pub 里面的公钥 code ~/.ssh/id_rsa.pub // github 配置路径 https://github.com/ -> 右上角的头像 setting -> SSH and GPG keys -> New SSH key // github 配置路径 https://gitlab.lixinio.com/ -> 右上角的头像 setting -> SSH Keys 测试是否链接成功 ssh git@github.com ssh -T git@gitlab.lixinio.com git 常用操作 核心：一次修改一次提交 一个功能一次提交 以少见细 避免出现复杂情况操作 git status 可以让我们时刻掌握仓库当前的状态 git diff +(文件路径) 可以让我们查看difference 文件上一次的修改 git add +(修改文件的路径) 把文件添加进去，实际上就是把文件修改添加到暂存区； git commit -m \"当次修改的说明\" 提交更改，实际上就是把暂存区的所有内容提交到当前分支。 git reset +(文件路径) 撤销本次操作 不写表示全部撤销 git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 git reset --hard HEAD^ 回退到上一个版本 HEAD^^ 回退两次 HEAD~100 回退多次 3628164 commitID git log 可以查看提交历史，以便确定要回退到哪个版本 git reflog 查看命令历史，以便确定要回到未来的哪个版本。用来记录你的每一次命令 版本回退时的查询时间点 git cheackout -b dev 创建并切换到dev的分支 git branch -m oldbranchname newbranchname 修改本地分支名称 git checkout -- filename 可以丢弃工作区的修改,让这个文件回到最近一次git commit或git add时的状态其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 git rm test.txt + git commit：文件就从版本库中被删除了 git stash 可用来暂存当前正在进行的工作， 先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。 基础命令：git stash —》 “do some work”—》 git stash pop git remote prune origin 移除本地对应线上某个被删除的分支。（也就是说你可以刷新本地仓库与远程仓库的保持这些改动的同步） git fetch 对于已有的工程，可以通过git remote set-url origin来设置新的git remote 地址。 如对于ros/qiye-web工程： git remote set-url origin git@gitlab.cheanjiait.com:ros/qiye-web.git 如果install出现npm ERR! Unexpected token git push origin : 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 第一次： git push -u origin +(分支号) 之后： git push origin +(分支号) 用git remote -v 要查看远程库的信息，显示更详细的信息： 总结： 1.要随时掌握工作区的状态，使用git status命令 2.git status告诉你有文件被修改过，用git diff可以查看修改内容。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 git rebase git rebase的两种用法：【==变基 + 合并多个分支==】 vim下多行同时编辑与删除技巧 git rebase变基应用场景 git rebase master 替代 git merge master // 自己的分支合并主分支的时候将基准变为master， 合并后主分支的更新就不算自己的修改，方便code review git rebase合并多个分支 step-1: git rebase -i [某次commit的hash] step-2: 进入vi界面【pick -> squash】 # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop = remove commit # l, label = label current HEAD with a name # t, reset = reset HEAD to a label # m, merge [-C | -c ] [# ] step-3: 编辑commit message step-4: git push -f 更新远程仓库 vim下多行同时编辑与删除技巧 // i: 进入插入模式 // esc: 推出插入模式 // shift + 冒号： 进入底行模式 // wq: write & quite 强制写入然后退出 // ctrl + v: 进入进入visual block模式 // 【在visual block模式下， j(jump)代表选中行， l(line)代表选中列， d(delete)代表删除】 // %s/pick/s: 将pick全部替换成s 先建项目再创建远程 git 仓库 git init git remote add origin => 【git remote add origin git@github.com:TOMGOU/demo.git】 // my-token: github icon => Settings => Personal access tokens => Generate new token // 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 git remote add origin https://@github.com/TOMGOU/candela-smart-city git remote set-url origin https://@github.com/TOMGOU/candela-smart-city git remote add origin https://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@github.com/TOMGOU/candela-smart-city git remote set-url origin https://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@github.com/TOMGOU/candela-smart-city git push --set-upstream origin master 回退版本 git reflog git reset 541366a 将 dist 推送到 gh-pages 分支 git subtree push --prefix dist origin gh-pages git push origin `git subtree split --prefix dist master`:gh-pages --force 使用chmod修改.sh的权限 chmod u+x *.sh Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/slidev/":{"url":"pages/others/slidev/","title":"sli.dev","keywords":"","body":"slidev https://cn.sli.dev/guide/ Slidev 旨在为开发者提供灵活性和交互性，通过使用他们已经熟悉的工具和技术，使他们的演示文稿更加有趣、更具表现力和吸引力。 Slidev 得益于 Vite，Vue 3 和 Windi CSS，为你带来了最美妙的创作体验。你所做的每一个改变都会立即反映到你的幻灯片上。 安装 node 版本 >= 14.0.0 npm init slidev 使用 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/iTerm/":{"url":"pages/others/iTerm/","title":"iTerm","keywords":"","body":"iTerm 配置 https://www.jianshu.com/p/ba08713c2b19 插件 高亮插件位置：/Users/tangyong/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting 【插件可以放到两个位置：1./Users/tangyong/.oh-my-zsh/custom/plugins；2./Users/tangyong/.oh-my-zsh/plugins/；】 git地址：https://github.com/zsh-users/zsh-syntax-highlighting.git 配置文件位置：/Users/tangyong/.zshrc source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 环境变量配置文件位置：/Users/tangyong/.bash_profile 生效：source ~/.bash_profile 安装步骤 step-1: 切换到 zsh-syntax-highlighting 安装目录 cd /Users/tangyong/.oh-my-zsh/custom/plugins or cd /Users/tangyong/.oh-my-zsh/plugins step-2: clone 仓库 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git cho \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc step-3: 激活语法高亮 source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh step-4: 使用 vscode 打开环境变量配置文件 code /Users/tangyong/.bash_profile step-5: 激活配置 source ~/.bash_profile HotKey Window配置 路径：iterm2 -> preferences -> keys -> configure HotKey Window Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/chrome/":{"url":"pages/others/chrome/","title":"chrome","keywords":"","body":"chrome Capture full size screenshot F12 -> command + shift + p -> Capture full size screenshot Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/husky/":{"url":"pages/others/husky/","title":"husky","keywords":"","body":"Husky https://github.com/typicode/husky https://typicode.github.io/husky/#/ 基础使用 step-1: 安装 husky 包 npm install husky -D step-2: 生成 .husky 文件 // package.json 添加脚本 { \"prepare\": \"husky install\" } // 执行脚本 npm run prepare step-3: 添加 hook npx husky add .husky/pre-commit \"npm run lint\" Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/others/typora/":{"url":"pages/others/typora/","title":"typora 破解","keywords":"","body":"Typora 破解 step-1: 找到 Typora.app 目录 code /Applications/Typora.app/Contents/Resources/TypeMark/ step-2: 找到 LicenseIndex 文件 https://store.typora.io/ => LicenseIndex step-3: 修改 hasActivated 状态为 true (e.hasActivated = \"true\" == e.hasActivated) => (e.hasActivated = \"true\" == \"true\") step-4: 自动关闭弹窗（随便找个合适的位置） window.Setting.close(); 还不完美，后面继续摸索。。。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:33:23 "},"pages/js/jsStorage/":{"url":"pages/js/jsStorage/","title":"JS内存管理机制","keywords":"","body":"JS 内存管理机制 JS 内存生命周期 分配内存 内存的读与写 内存回收 栈内存与堆内存 其中基本类型包括：String、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是大小固定、体积轻量、相对简单，它们被放在 JS 的栈内存里存储。 而排除掉基本类型，剩下的 Object 类型就是引用类型，又名“复杂类型”。顾名思义，引用类型的数据往往相对复杂、占用空间较大、且大小不定，它们被放在 JS 的堆内存里存储。 垃圾回收机制 引用计数 const students = ['修言', '小明', 'bear'] 这行代码首先是开辟了一块内存，把右侧这个数组塞了进去，此时这个数组就占据了一块内存。随后 students 变量指向它，这就是创建了一个指向该数组的 “引用”。此时数组的引用计数就是 1 。 const students = ['修言', '小明', 'bear'] students = null 在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。 引用计数的问题，无法识别循环引用 function badCycle() { var cycleObj1 = {} var cycleObj2 = {} cycleObj1.target = cycleObj2 cycleObj2.target = cycleObj1 } badCycle() 标记清除 自 2012 年起，所有浏览器都使用了标记清除算法。可以说，标记清除法是现代浏览器的标准垃圾回收算法。在标记清除算法中，一个变量是否被需要的判断标准，是它是否可抵达 。 标记清除算法有两个阶段，分别是标记阶段和清除阶段： 标记阶段：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为“可抵达 ”。 清除阶段： 没有被标记为“可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除 内存泄漏 该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏。 内存泄漏成因分析 全局变量 function test() { me = 'xiuyan' } 忘记清除的 setInterval 和 setTimeout 清除不当的 DOM const myDiv = document.getElementById('myDiv') function handleMyDiv() { // 一些与myDiv相关的逻辑 } // 使用myDiv handleMyDiv() // 尝试”删除“ myDiv document.body.removeChild(document.getElementById('myDiv')); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 17:32:02 "},"pages/algorithm/":{"url":"pages/algorithm/","title":"数据结构与算法","keywords":"","body":"数据结构与算法 https://tomgou.github.io/algorithm-study/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 17:47:00 "},"pages/selenium/":{"url":"pages/selenium/","title":"Selenium","keywords":"","body":"selenium https://tomgou.github.io/share_automation/pages/selenium/ Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-09-07 17:39:51 "}}